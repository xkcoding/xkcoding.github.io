<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决 MacOS BigSur JD-GUI 打开失败的问题]]></title>
    <url>%2F2022%2F01%2F04%2Ffix-error-about-jd-gui-on-big-sur.html</url>
    <content type="text"><![CDATA[前言 JD-GUI 是一款轻量级的 Java 反编译工具，对于一些没有源码的 Jar 包，直接拖进去就可以反编译源码，十分的方便。 在 MacOS 还是 Mojave 的时候，JD-GUI 使用一切正常。 当系统升级到 BigSur 和 Monterey 的时候，打开 JD-GUI 就会提示找不到 JDK 环境。（即使你的电脑已经存在 JDK 环境并且配置了环境变量，依然会提示找不到 JDK 环境） 大致错误提示如下： 12345ERROR launching &apos;JD-GUI&apos;No suitable Java version found on your system!This program requires Java 1.8+Make sure you install the required Java version. 解决办法 起初，我第一感觉可能是新版的 MacOS 和老版本的 JD-GUI 不兼容导致的，然后在官网下载最新的 1.6.6 版本，安装后，依然报同样的错误信息。 这肯定不可能是我一个人遇到这个问题，于是我在官方仓库找到了这个问题 Update universalJavaApplicationStub to be able to launch on macOS Big Sur #336 我们需要替换 JD-GUI 程序文件里一个脚本文件，参考步骤如下： 先将下载下来的 jd-gui-osx-1.6.6.tar 解压，然后将 JD-GUI.app 文件拷贝到 Applications 目录下 右击 JD-GUI.app 点击显示包内容 将 Contents/MacOS/universalJavaApplicationStub.sh 文件的内容替换为 https://github.com/tofi86/universalJavaApplicationStub/blob/v3.2.0/src/universalJavaApplicationStub 中的内容，保存。 注意：确保本地已存在 Java 环境 此时，再次打开 JD-GUI.app，则可以正常运行了。]]></content>
      <categories>
        <category>技术相关</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愉快的本地开发体验之YAPI接口文档管理]]></title>
    <url>%2F2021%2F05%2F20%2Fhappy-dev-yapi.html</url>
    <content type="text"><![CDATA[前言 博文渲染失败，o(╥﹏╥)o 麻烦看到小伙伴，联系下作者，谢谢啦~]]></content>
      <categories>
        <category>技术相关</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>yapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愉快的本地开发体验之Traefik代理]]></title>
    <url>%2F2021%2F05%2F11%2Fhappy-dev-traefik-proxy.html</url>
    <content type="text"><![CDATA[前言 博文渲染失败，o(╥﹏╥)o 麻烦看到小伙伴，联系下作者，谢谢啦~]]></content>
      <categories>
        <category>技术相关</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>traefik</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[愉快的本地开发体验之本地DNS]]></title>
    <url>%2F2021%2F05%2F01%2Fhappy-dev-run-local-dns-server.html</url>
    <content type="text"><![CDATA[写在前面 大家在本地环境进行联调或者运行一些服务的时候，是不是经常通过 ip:port 进行测试。有时候服务一多，经常性的需要记住很多 ip:port 信息。 本文将介绍如何通过自定义域名的方式去替换 ip:port，减去我们的记忆负担，提升我们的开发体验。 方案一：修改本地 Hosts 文件 + Nginx Proxy 这里推荐一款工具，SwitchHosts（记忆中，之前的版本叫做 SwitchHosts!），页面简洁，操作一目了然。 配置 Hosts 文件，只需要将域名的地址跟 IP 做映射即可。 测试 123456789➜ ~ ping a.dev.ioPING a.dev.io (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.098 ms64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.086 ms64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.093 ms^C--- a.dev.io ping statistics ---3 packets transmitted, 3 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 0.086/0.101/0.118/0.012 ms 修改 Hosts 文件这种方式，如果我们在本机又部署了一个 b 服务，此时需要加一个 b.dev.io，则需要额外新增一条记录，并不能做到泛域名解析（*.dev.io）。如果要在本地支持泛域名解析，那么就只能通过方案二来实现了。 方案二：dnsmasq 原生的 dnsmasq 是不具备界面的，这里推荐一款带有 web 界面的 dnsmasq，同时还支持「Hot Reload」机制。 我们通过 docker 快速启动一个 dnsmasq 服务，首先新建一个配置文件 dnsmasq.conf，并将配置文件存放在 config 目录下。 1234567log-queriesno-resolvserver=8.8.8.8server=114.114.114.114strict-orderaddress=/dev.io/127.0.0.1 这里我们使用 jpillora/dnsmasq:latest 这个镜像，下面是编排文件： 123456789101112131415161718version: "3.8"services: dns-server: image: jpillora/dnsmasq:latest ports: - "53:53/udp" - 8080:8080 environment: - HTTP_USER=root - HTTP_PASS=root volumes: - ./config/dnsmasq.conf:/etc/dnsmasq.conf restart: unless-stopped logging: driver: "json-file" options: max-size: "1m" 运行 docker-compose up 启动服务，访问管理界面 http://localhost:8080 测试（记得把方案一的 Hosts 记录重置一下😉） 12➜ ~ ping a.dev.ioping: cannot resolve a.dev.io: Unknown host 哦豁，失败了，需要修改本机 DNS 配置，如图所示： 再次测试 123456789➜ ~ ping a.dev.ioPING a.dev.io (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.043 ms64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.044 ms64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.133 ms^C--- a.dev.io ping statistics ---3 packets transmitted, 3 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 0.043/0.099/0.144/0.045 ms 此时，如果测试一下 b.dev.io 呢？ 123456789➜ ~ ping b.dev.ioPING b.dev.io (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.052 ms64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.143 ms64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.142 ms^C--- b.dev.io ping statistics ---3 packets transmitted, 3 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 0.052/0.112/0.143/0.043 ms 没错，天然支持泛域名解析，还记得我们上面的配置么？ 1address=/dev.io/127.0.0.1 这里配置就意味着 *.dev.io 都会指向到 127.0.0.1。 方案三：go-dnsmasq（2021.09.16 更新） 运行了一段时间方案二之后，发现我的 MBP 越来越卡，通过 docker stats 发现可能存在内存泄漏的问题。经过折腾群群主(苏洋)的建议，更换了另外一个 dns 镜像，可解决内存泄漏的问题，同时苏大还对该镜像进行了精简（镜像大小约2.7M）。 新增配置文件 config/hosts.conf 1127.0.0.1 *.dev.io 创建编排文件 123456789101112version: "3.8"services: dns-server: image: soulteary/go-dnsmasq:test command: dnsmasq -l 0.0.0.0:53 -f /hosts.conf -p 1s -n 114.114.114.114:53 -n 8.8.8.8:53 ports: - "53:53/udp" - "53:53/tcp" volumes: - ./config/hosts.conf:/hosts.conf:rw restart: unless-stopped 运行 docker-compose up 启动服务，同时别忘了参考方案二，需要修改本机 DNS 配置。 测试一下： 123456789101112131415161718➜ ~ ping a.dev.ioPING a.dev.io (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.049 ms64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.084 ms64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.162 ms^C--- a.dev.io ping statistics ---3 packets transmitted, 3 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 0.049/0.098/0.162/0.047 ms➜ ~ ping b.dev.ioPING b.dev.io (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.061 ms64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.186 ms64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.125 ms^C--- b.dev.io ping statistics ---3 packets transmitted, 3 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 0.061/0.124/0.186/0.051 ms 泛域名解析已经可以支持了。最重要的是，这个方案至少不会让我的电脑越用越卡。😁 如果想要知道 DNS 的解析日志，可以通过 docker-compose logs -f 查看，如果你不想通过命令行的方式查看，也可以通过配置 Dozzle 来查看容器的日志，具体使用方式可以参考苏大的博文：https://soulteary.com/2020/11/15/view-container-logs-in-realtime.html 小插曲 苏大当时未编译 arm 架构的镜像，因此我这边 clone 了源码，在本地的 m1 芯片的电脑上重新编译了一个本地镜像，所以小伙伴们可以看到上述编排文件的镜像 TAG 为 soulteary/go-dnsmasq:test。 如果也有小伙伴是 m1 芯片想要体验该镜像的话，可以参考我的方案进行本地编译。 首先 clone 仓库地址，git clone https://github.com/soulteary/go-dnsmasq.git 修改 Dockfile 内容，将 npx 注释一下，代码如下： 1234567891011121314151617FROM golang:1.16-alpine AS BuilderWORKDIR /appCOPY . .RUN go env -w GO111MODULE=on &amp;&amp; \ go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct &amp;&amp; \ go mod downloadARG VERSION=1.1.0# RUN apk add upxRUN go build -o dnsmasq -ldflags "-w -s -X main.Version=$&#123;VERSION&#125;" -tags="netgo" -trimpath cmd/dnsmasq/main.go# RUN upx -9 -o dnsmasq.min dnsmasqFROM scratch# COPY --from=Builder /app/dnsmasq.min /bin/dnsmasqCOPY --from=Builder /app/dnsmasq /bin/dnsmasqENV DNSMASQ_LISTEN=0.0.0.0:53EXPOSE 53 53/udpCMD ["/bin/dnsmasq"] 打包本地镜像 docker build . -t soulteary/go-dnsmasq:test 另外，群主已经答应后面会更新 arm 架构的镜像啦，小伙伴们后面应该可以直接从官方的镜像仓库 soulteary/go-dnsmasq 拉取。 下一篇，我们来聊聊如果通过 Traefik 代理本地容器服务来提升本地的开发体验。 参考 https://little-star.love/posts/f114e298/ https://soulteary.com/2021/08/19/dns-for-local-development.html]]></content>
      <categories>
        <category>技术相关</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当 Lombok 遇见了 MapStruct の「坑」]]></title>
    <url>%2F2021%2F04%2F22%2Fwhen-lombok-met-mapstruct.html</url>
    <content type="text"><![CDATA[前言 2021 年了，相信搞 Java 的小伙伴们不会还没有人没用过 Lombok 吧？ Lombok 是一款通过「注解」的形式简化并消除冗余代码的 Java 插件，利用「Annotation Processor」原理，在编译时生成一些「重复」代码。另外需要注意的是，在 IDEA 环境下，需要额外安装一个 Lombok 插件。（本文不会专门介绍 Lombok 的使用方法，想要深入学习的小伙伴可以去 官方文档 学习 Lombok 提供的所有注解的使用方法。） 可能一些朋友对 MapStruct 就有点陌生了，但是我敢肯定的是，你们一定用过和他功能类似的工具。比如 Apache Commons BeanUtils、Spring BeanUtils、BeanCopier、Dozer 等等。没错，MapStruct 也是为了解决对象属性拷贝这一个通用需求的。传统使用「反射」进行属性拷贝的方式，在大数据量的场景下，性能低下，效率堪忧。MapStruct 底层则是通过 getter/setter 的方式提升属性拷贝的性能的，跟 Lombok 一样利用「Annotation Processor」的原理，在编译时生成代码。 踩坑 首先我们按照 MapStruct 官方文档介绍，搭一个简单的栗子🌰~ 引入依赖： 123456789101112131415161718192021222324252627282930313233&lt;properties&gt; &lt;mapstruct.version&gt;1.4.2.Final&lt;/mapstruct.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;!-- MapStruct 在编译时会通过这个插件生成代码 --&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 创建两个类，用于属性拷贝。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// 源对象public class CarDO &#123; private String make; private int numberOfSeats; private CarType type; public CarDO() &#123; &#125; public CarDO(String make, int numberOfSeats, CarType type) &#123; this.make = make; this.numberOfSeats = numberOfSeats; this.type = type; &#125; public String getMake() &#123; return make; &#125; public void setMake(String make) &#123; this.make = make; &#125; public int getNumberOfSeats() &#123; return numberOfSeats; &#125; public void setNumberOfSeats(int numberOfSeats) &#123; this.numberOfSeats = numberOfSeats; &#125; public CarType getType() &#123; return type; &#125; public void setType(CarType type) &#123; this.type = type; &#125;&#125;// 测试枚举public enum CarType &#123; /** * 普通 */ COMMON, /** * 老爷车 */ OLD, /** * 跑车 */ SPORTS;&#125;// 目标对象public class CarDTO &#123; private String make; private int seatCount; private String type; public CarDTO() &#123; &#125; public CarDTO(String make, int seatCount, String type) &#123; this.make = make; this.seatCount = seatCount; this.type = type; &#125; public String getMake() &#123; return make; &#125; public void setMake(String make) &#123; this.make = make; &#125; public int getSeatCount() &#123; return seatCount; &#125; public void setSeatCount(int seatCount) &#123; this.seatCount = seatCount; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125;&#125; 创建一个对象拷贝接口，用于告诉 MapStruct 需要生成哪个对象的属性拷贝。 注意：这里 @Mapper / Mappers / @Mapping 都是 org.mapstruct 包下的，当和 Mybatis 一起使用时，不要引用错了~ 1234567@Mapperpublic interface CarMapper &#123; CarMapper INSTANCE = Mappers.getMapper(CarMapper.class); @Mapping(source = "numberOfSeats", target = "seatCount") CarDTO carToCarDto(CarDO car);&#125; 最后创建测试类，测试一把！ 12345678910111213141516public class TestMapStruct &#123; @Test public void shouldMapCarToDto() &#123; //given CarDO car = new CarDO("Morris", 5, CarType.SPORTS); //when CarDTO carDto = CarMapper.INSTANCE.carToCarDto(car); //then Assert.assertNotNull(carDto); Assert.assertEquals("Morris", carDto.getMake()); Assert.assertEquals(5, carDto.getSeatCount()); Assert.assertEquals("SPORTS", carDto.getType()); &#125;&#125; 按照官方文档的做法，十分顺利，测试通过！ 如果我们把 2 个实体类里的 getter/setter 替换成 Lombok，会发生什么事情呢？ 我们先改造 pom.xml 文件，增加 Lombok 相关依赖： 1234567891011121314151617&lt;properties&gt;+ &lt;lombok.version&gt;1.18.12&lt;/lombok.version&gt; &lt;mapstruct.version&gt;1.4.2.Final&lt;/mapstruct.version&gt;&lt;/properties&gt;&lt;dependencies&gt;+ &lt;dependency&gt;+ &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;+ &lt;artifactId&gt;lombok&lt;/artifactId&gt;+ &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;+ &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 此时，我们的实体类代码应该是这样子的： 12345678910111213141516171819// 源对象@Data@NoArgsConstructor@AllArgsConstructorpublic class CarDO &#123; private String make; private int numberOfSeats; private CarType type;&#125;// 目标对象@Data@NoArgsConstructor@AllArgsConstructorpublic class CarDTO &#123; private String make; private int seatCount; private String type;&#125; 再来执行一遍测试类，编译时就会出现类似这种「java: 找不到符号 符号: 方法 getXXX()」错误提示，具体如下图： 当出现这种错误，分明就是 Lombok 没有生效嘛，那么该怎么解决这个问题呢？ 解坑 还记得文章开头介绍的，Lombok 和 MapStruct 都是利用「Annotation Processor」在程序编译时生成代码的吗？ 了解原理，问题就容易解决了。 前文我们在测试 MapStruct 的时候，在 pom.xml 文件中添加了一个一个插件，用于告诉 Maven 编译时，需要额外执行 MapStruct 的代码生成逻辑，但是我们没有告诉 Maven 在编译时，Lombok 也需要生成代码。 我们在 pom.xml 文件的 build 节点中加上这么一段： 123456789101112131415161718192021222324252627&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;!-- Lombok 在编译时会通过这个插件生成代码 --&gt;+ &lt;path&gt;+ &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;+ &lt;artifactId&gt;lombok&lt;/artifactId&gt;+ &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;+ &lt;/path&gt; &lt;!-- MapStruct 在编译时会通过这个插件生成代码 --&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;$&#123;mapstruct.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 这个时候，再去运行一下通过测试类，就不会出现上述找不到 get 方法的错误了~ 配套代码：https://github.com/xkcoding/practice_demo/tree/master/lombok-with-mapstruct]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>lombok</tag>
        <tag>mapstruct</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 docker 快速启动本地 ZooKeeper 集群]]></title>
    <url>%2F2021%2F04%2F14%2Frun-local-zookeeper-cluster-with-docker.html</url>
    <content type="text"><![CDATA[前言 ZooKeeper ，翻译过来就是：动物园管理员，而这也是它 logo 的由来。它是一个为分布式应用提供一致性服务的软件，是大数据场景下的一个重要的基础组件。所以安装 ZooKeeper，也是入门学习大数据的第一步。 曾几何时，我们在学习大数据技术的时候，总是先在本地环境启动虚拟机应用，然后开始初始化虚拟机配置和环境，紧接着开始安装软件。此时如果需要模拟一些集群环境，还需要进行大量重复的苦不堪言的配置工作。 今天我们便利用 Docker 来快速的在本地启动一个 ZooKeeper 环境。 实操 环境 自行在本机安装 Docker 和 Docker Compose 软件，如果网络环境差的，可以配置阿里的镜像源地址，本文不再赘述。 寻找合适的镜像 前往 镜像仓库 可以很轻松的搜索到 ZooKeeper，发现已经提供了 官方镜像，美滋滋，省去了我们鉴别镜像甚至自己封装镜像的步骤。 启动单机版 ZooKeeper 你可以简单的执行下面的命令运行一个单节点的 ZooKeeper，这里我们选择目前最新的 3.7.0 版本。 1$ docker run -d -p 2181:2181 --name dev-zk zookeeper:3.7.0 此时你就得到了一个单机版的 ZooKeeper，这里更推荐使用 Compose 的方式把参数持久化到文件中，方便后续调整为集群模式。 1234567version: '3.8'services: zookeeper: image: zookeeper:3.7.0 ports: - 2181:2181 将上述内容保存为 docker-compose.yml 文件之后，在命令行执行： 1$ docker-compose up -d 注意：这里你也可以不加 -d 参数，观察启动日志，方便排查问题，确保没问题后，下次再加上 -d 参数进行后台运行 启动集群版 ZooKeeper 这里我们利用 Docker Compose 的 Services 网络互通的特性，来组成一个集群。 修改上面的 Compose 文件内容： 1234567891011121314151617181920212223242526272829version: '3.8'services: zoo1: image: zookeeper:3.7.0 hostname: zoo1 ports: - 2181:2181 environment: ZOO_MY_ID: 1 ZOO_SERVERS: server.1=0.0.0.0:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo2: image: zookeeper:3.7.0 hostname: zoo2 ports: - 2182:2181 environment: ZOO_MY_ID: 2 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=0.0.0.0:2888:3888;2181 server.3=zoo3:2888:3888;2181 zoo3: image: zookeeper:3.7.0 hostname: zoo3 ports: - 2183:2181 environment: ZOO_MY_ID: 3 ZOO_SERVERS: server.1=zoo1:2888:3888;2181 server.2=zoo2:2888:3888;2181 server.3=0.0.0.0:2888:3888;2181 在命令行执行 docker-compose up 启动，观察启动日志。 此时你就得到了一个 3 个节点的 ZooKeeper 集群，分别暴露在本机环境的 2181/2182/2183 端口。 其他 有些小伙伴在运行 spring-boot-demo 项目的 demo-zookeeper 模块时，出现了获取不到集群地址的错误，提了相关 ISSUE，如下所示： 12345678910111213142021-04-14 15:52:18.630 ERROR 23630 --- [ain-EventThread] o.a.c.f.imps.CuratorFrameworkImpl : Background exception was not retry-able or retry gave upjava.lang.NullPointerException: null at org.apache.curator.utils.Compatibility.getHostAddress(Compatibility.java:116) ~[curator-client-5.1.0.jar:na] at org.apache.curator.framework.imps.EnsembleTracker.configToConnectionString(EnsembleTracker.java:185) ~[curator-framework-5.1.0.jar:5.1.0] at org.apache.curator.framework.imps.EnsembleTracker.processConfigData(EnsembleTracker.java:206) ~[curator-framework-5.1.0.jar:5.1.0] at org.apache.curator.framework.imps.EnsembleTracker.access$300(EnsembleTracker.java:50) ~[curator-framework-5.1.0.jar:5.1.0] at org.apache.curator.framework.imps.EnsembleTracker$2.processResult(EnsembleTracker.java:150) ~[curator-framework-5.1.0.jar:5.1.0] at org.apache.curator.framework.imps.CuratorFrameworkImpl.sendToBackgroundCallback(CuratorFrameworkImpl.java:892) [curator-framework-5.1.0.jar:5.1.0] at org.apache.curator.framework.imps.CuratorFrameworkImpl.processBackgroundOperation(CuratorFrameworkImpl.java:649) [curator-framework-5.1.0.jar:5.1.0] at org.apache.curator.framework.imps.WatcherRemovalFacade.processBackgroundOperation(WatcherRemovalFacade.java:152) [curator-framework-5.1.0.jar:5.1.0] at org.apache.curator.framework.imps.GetConfigBuilderImpl$2.processResult(GetConfigBuilderImpl.java:222) [curator-framework-5.1.0.jar:5.1.0] at org.apache.zookeeper.ClientCnxn$EventThread.processEvent(ClientCnxn.java:630) [zookeeper-3.6.0.jar:3.6.0] at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:551) [zookeeper-3.6.0.jar:3.6.0] 解决方式如下： 在本机配置 hosts 文件，推荐使用 SwitchHosts! 软件配置。 1127.0.0.1 zoo1 zoo2 zoo3 修改 Curator 连接 ZooKeeper 集群地址，通过 hostname 方式连接上 ZooKeeper。 12- 127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183+ zoo1:2181,zoo2:2182,zoo3:2183 此时该问题就可以解决了。]]></content>
      <categories>
        <category>技术相关</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在本地快速启动一个 K8S 集群]]></title>
    <url>%2F2021%2F03%2F15%2Frun-local-k8s-cluster-quickly.html</url>
    <content type="text"><![CDATA[背景 最近在阅读《每天5分钟玩转Kubernetes》 这本书，个人感觉是一本不错的 K8S 的入门书籍。 我们在刚开始学习一项技术的时候，不论是通过官方文档、书籍，亦或是视频的形式，如果仅仅是去看，而不去练习实践的话，那么是很难将其真正应用起来的。 然而当我开始准备实践的时候，发现要想在本地将 K8S 跑起来，并不像我们想象的那么容易。存在以下几点「问题」： 网络环境：K8S 里面的一些镜像在国内很难将其 pull 下来，当然这可以通过代理、镜像站等方式解决。 资源消耗：在内存资源不这么充裕的本地开发环境，去部署一个 K8S 集群，这无疑不是一个明智的选择。 那么有没有什么方案可以更优雅更轻量更快速搭建一个 K8S 集群呢？答案就是 k3d。 其实有很多种方式可以在本地运行 k8s，比如： minikube 仅支持单节点，但是我们期望可以跑一个集群的方式，方便我们去 Mock 节点宕机之后 K8S 自动调度的 case ✖️ microk8s 是 Ubuntu 生态里提供的一个可以单机运行的 k8s 版本，配合 Ubuntu 生态的 multipass，可以模拟多节点，但是在本就资源紧张的本地环境，通过虚拟机的方式模拟多节点，显然并不是我想要的 ✖️ kind 是一个基于 docker 构建 Kubernetes 集群的工具，Kubernetes in Docker ✔️ k3d 是一个可以让 k3s 运行在 Docker 中的工具，相比于 kind ，启动速度更快，占用资源更小，也是我采取的一种方案 ✅ 当然了，如果只是学习 k8s 的使用，那么以上方案均可以使用。 关于 k3d 以及 kind 的对比，可以参考 K3d vs Kind 谁更适合本地研发。 1. 什么是 k3d + k3s ？ k3s 是一种非常快速且轻量级的完全兼容的 Kubernetes 发行版（CNCF 认证）。 k3d 是一个可以让 k3s 运行在 Docker 中的工具，它提供了一个简单的 CLI 来创建、运行和删除具有 1 到 N 个节点的 Kubernetes 集群。 k3s 包括以下一些组件： Containerd：一个类似 Docker 的运行时容器，但是它不支持构建镜像 Flannel：基于 CNI 实现的网络模型，默认使用的是 Flannel，也可以使用 Calico 等其他实现替换 CoreDNS：集群内部 DNS 组件 SQLite3：默认使用 SQLite3 进行存储，同样也支持 etcd3, MySQL, Postgres Traefik：默认安装 Ingress controller 是 traefik 1.x 的版本 Embedded service loadbalancer：内嵌的一个服务负载均衡组件 k3s 是一种模块化的发行版，可以很方便的替换上面的组件。 2. 安装 k3d 在 Mac 下，使用 Homebrew 可以很方便的安装 k3d： brew install k3d。 顺手安装一下 kubectl 和 kubecm： 12brew install kubectlbrew install kubecm 3. 小试牛刀 我们通过 k3d 的命令可以轻易的在本地启动一个或 N 个 k8s 集群。 首先我们尝试创建一个 1主2从 的集群： 1k3d cluster create first-cluster --port 8080:80@loadbalancer --port 8443:443@loadbalancer --api-port 6443 --servers 1 --agents 2 初次创建可能会比较慢，因为会从 Docker 仓库拉取最新的 rancher/k3s 镜像。 当出现下面的日志时，k8s 集群就创建成功了 😉 12345678910111213141516171819202122INFO[0000] Prep: NetworkINFO[0000] Created network 'k3d-first-cluster'INFO[0000] Created volume 'k3d-first-cluster-images'INFO[0001] Creating node 'k3d-first-cluster-server-0'INFO[0001] Creating node 'k3d-first-cluster-agent-0'INFO[0001] Creating node 'k3d-first-cluster-agent-1'INFO[0001] Creating LoadBalancer 'k3d-first-cluster-serverlb'INFO[0001] Starting cluster 'first-cluster'INFO[0001] Starting servers...INFO[0001] Starting Node 'k3d-first-cluster-server-0'INFO[0008] Starting agents...INFO[0008] Starting Node 'k3d-first-cluster-agent-0'INFO[0020] Starting Node 'k3d-first-cluster-agent-1'INFO[0028] Starting helpers...INFO[0028] Starting Node 'k3d-first-cluster-serverlb'INFO[0029] (Optional) Trying to get IP of the docker host and inject it into the cluster as 'host.k3d.internal' for easy accessINFO[0031] Successfully added host record to /etc/hosts in 4/4 nodes and to the CoreDNS ConfigMapINFO[0031] Cluster 'first-cluster' created successfully!INFO[0031] --kubeconfig-update-default=false --&gt; sets --kubeconfig-switch-context=falseINFO[0031] You can now use it like this:kubectl config use-context k3d-first-clusterkubectl cluster-info 此时，我们按照日志提示，运行 kubectl cluster-info 查看下当前集群的信息： 123Kubernetes master is running at https://0.0.0.0:6443CoreDNS is running at https://0.0.0.0:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxyMetrics-server is running at https://0.0.0.0:6443/api/v1/namespaces/kube-system/services/https:metrics-server:/proxy 运行 kubectl get nodes 查看下当前集群的节点情况： 1234NAME STATUS ROLES AGE VERSIONk3d-first-cluster-agent-1 Ready &lt;none&gt; 178m v1.20.2+k3s1k3d-first-cluster-server-0 Ready control-plane,master 178m v1.20.2+k3s1k3d-first-cluster-agent-0 Ready &lt;none&gt; 178m v1.20.2+k3s1 注意，这里的“节点”其实是本机 Docker 运行的容器，通过 docker ps 查看下当前本机运行的容器吧 12345CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa757151daf14 rancher/k3d-proxy:v4.2.0 "/bin/sh -c nginx-pr…" 4 hours ago Up 4 hours 0.0.0.0:6443-&gt;6443/tcp, 0.0.0.0:8080-&gt;80/tcp, 0.0.0.0:8443-&gt;443/tcp k3d-first-cluster-serverlb6fcb1bbaf96e rancher/k3s:latest "/bin/k3s agent" 4 hours ago Up 4 hours k3d-first-cluster-agent-1cef7277e43b9 rancher/k3s:latest "/bin/k3s agent" 4 hours ago Up 4 hours k3d-first-cluster-agent-05d438c1b5087 rancher/k3s:latest "/bin/k3s server --t…" 4 hours ago Up 4 hours k3d-first-cluster-server-0 解释一下我们创建集群时配置的端口映射： --port 8080:80@loadbalancer 会将本地的 8080 端口映射到 loadbalancer 的 80 端口，然后 loadbalancer 接收到 80 端口的请求后，会代理到所有的 k8s 节点。 --api-port 6443 默认提供的端口号，k3s 的 api-server 会监听 6443 端口，主要是用来操作 Kubernetes API 的，即使创建多个 Master 节点，也只需要暴露一个 6443 端口，loadbalancer 会将请求代理分发给多个 Master 节点。 如果我们期望通过 NodePort 的形式暴露服务，也可以自定义一些端口号映射到 loadbalancer 来暴露 k8s 的服务，比如：-p 10080-20080:10080-20080@loadbalancer 现在我们集群和主机的网络通信是这样子的： 4. 测试 创建一个 nginx 的 Deployment 1kubectl create deployment nginx --image=nginx 创建一个 Service 通过 ClusterIP 的方式暴露服务 1kubectl create service clusterip nginx --tcp=80:80 创建一个 Ingress，k3s 默认安装的是 traefik 1.x 作为 Ingress Controller 12345678910111213141516171819cat &lt;&lt;EOF | kubectl apply -f -apiVersion: networking.k8s.io/v1kind: Ingressmetadata: name: nginx annotations: ingress.kubernetes.io/ssl-redirect: "false"spec: rules: - http: paths: - path: / pathType: Prefix backend: service: name: nginx port: number: 80EOF 此时，打开浏览器，访问 http://localhost:8080/ 就可以看到熟悉的 nginx 默认页。 这是不是太酷了~ 😎 5. 其它 5.1. 管理集群 停止集群：k3d cluster stop first-cluster 重启集群：k3d cluster start first-cluster 删除集群：k3d cluster delete first-cluster 5.2. 创建指定版本的k8s集群 当使用 Helm Chart 安装 Rancher 时，可能会出现如下错误日志： 1chart requires kubeVersion: &lt; 1.20.0-0 which is incompatible with Kubernetes v1.20.0+k3s2 测试时 Rancher 版本号为 2.5.5，目前最新的 2.5.6 已经可以支持 1.20.x 版本了 要创建一个 k8s 版本号为 v1.19.8-k3s1 的 k8s 集群，可以在创建集群的命令后面加 --image 参数，指定版本号：k3d cluster create first-cluster xxxxx --image rancher/k3s:v1.19.8-k3s1 5.3. 快速切换 kubectl context 还记得在第二步顺手安装的 kubecm 吗？ 当我们在本地使用 k3d 创建了多个集群之后，我们可以通过 kubecm 快速切换 context。 123456789101112$ kubecm sUse the arrow keys to navigate: ↓ ↑ → ← and / toggles searchSelect Kube Context 😼 k3d-first-cluster(*) k3d-dev k3d-rancher-test &lt;Exit&gt;--------- Info ----------Name: k3d-first-clusterCluster: k3d-first-clusterUser: admin@k3d-first-cluster 参考 k3s：https://k3s.io/ k3d：https://k3d.io/ kubecm：https://github.com/sunny0826/kubecm 下一篇，我将介绍下如何在我们的k8s集群中，部署 Rancher 来简化我们的 k8s 操作。]]></content>
      <categories>
        <category>技术相关</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
        <tag>k3d</tag>
        <tag>k3s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 MacOS BigSur 使用 pip 安装依赖失败的问题]]></title>
    <url>%2F2021%2F03%2F10%2Ffix-error-about-python-package-install-on-big-sur.html</url>
    <content type="text"><![CDATA[前言 年后到现在，我已经被基金伤透了心🤕 于是乎，为了争取不做 韭零后，我打算学习一下关于量化交易方面的内容。 学习量化交易，首先得先拿到交易的数据，这里我使用的是 聚宽数据 提供的本地数据接口，官方提供了 Python SDK，所以我就开始照着文档安装 SDK …… 照着文档的安装步骤，其实很简单： 1$ pip install jqdatasdk 如果一切正常，那么你可以直接关掉本文了。 可如果你的环境和我一样： 系统版本：MacOS BigSur 11.2.3 Python 版本：3.9 IDE 版本：PyCharm Professional 2020.3 那么很有可能会安装失败，并且错误日志如下（截取部分日志）： 1234567891011121314151617181920$ pip install jqdatasdk Collecting jqdatasdk Using cached jqdatasdk-1.8.8-py3-none-any.whl (151 kB)Requirement already satisfied: six in /usr/local/lib/python3.9/site-packages (from jqdatasdk) (1.15.0)......(省略部分日志)Requirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in /usr/local/lib/python3.9/site-packages (from requests-&gt;jqdatasdk) (1.26.3)Building wheels for collected packages: thriftpy2 Building wheel for thriftpy2 (setup.py) ... error ERROR: Command errored out with exit status 1: command: /usr/local/opt/python@3.9/bin/python3.9 -u -c 'import sys, setuptools, tokenize; sys.argv[0] = '"'"'/private/var/folders/tx/_rv7b39127d289cpmm3dpylr0000gn/T/pip-install-p9oxcpjv/thriftpy2_42f75cad7b3842908525f1c376f2eb3d/setup.py'"'"'; __file__='"'"'/private/var/folders/tx/_rv7b39127d289cpmm3dpylr0000gn/T/pip-install-p9oxcpjv/thriftpy2_42f75cad7b3842908525f1c376f2eb3d/setup.py'"'"';f=getattr(tokenize, '"'"'open'"'"', open)(__file__);code=f.read().replace('"'"'\r\n'"'"', '"'"'\n'"'"');f.close();exec(compile(code, __file__, '"'"'exec'"'"'))' bdist_wheel -d /private/var/folders/tx/_rv7b39127d289cpmm3dpylr0000gn/T/pip-wheel-vdjkejow cwd: /private/var/folders/tx/_rv7b39127d289cpmm3dpylr0000gn/T/pip-install-p9oxcpjv/thriftpy2_42f75cad7b3842908525f1c376f2eb3d/ Complete output (93 lines): running bdist_wheel The [wheel] section is deprecated. Use [bdist_wheel] instead.......(省略部分日志) creating build/temp.macosx-11-x86_64-3.9/thriftpy2/transport clang -Wno-unused-result -Wsign-compare -Wunreachable-code -fno-common -dynamic -DNDEBUG -g -fwrapv -O3 -Wall -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk -I/usr/local/include -I/usr/local/opt/openssl@1.1/include -I/usr/local/opt/sqlite/include -I/usr/local/opt/tcl-tk/include -I/usr/local/Cellar/python@3.9/3.9.2_1/Frameworks/Python.framework/Versions/3.9/include/python3.9 -c thriftpy2/transport/cybase.c -o build/temp.macosx-11-x86_64-3.9/thriftpy2/transport/cybase.o clang: error: invalid version number in 'MACOSX_DEPLOYMENT_TARGET=11' error: command '/usr/bin/clang' failed with exit code 1 ---------------------------------------- 此时，我们可以发现日志里的关键信息： 1clang: error: invalid version number in 'MACOSX_DEPLOYMENT_TARGET=11' 解决办法 1. 检查当前系统 clang 版本 12345$ clang --versionApple clang version 11.0.3 (clang-1103.0.32.62)Target: x86_64-apple-darwin20.3.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/bin 2. 再次检查系统CommandLineTools版本 12345$ softwareupdate --all --install --forceSoftware Update ToolFinding available softwareNo updates are available. 这里其实是个坑，通过 softwareupdate 其实发现不了，我们通过另外一个工具检查下 1234567891011121314151617$ brew doctorPlease note that these warnings are just used to help the Homebrew maintainerswith debugging if you file an issue. If everything you use Homebrew for isworking fine: please don't worry or file an issue; just ignore this. Thanks!......(省略部分日志)Warning: Your Command Line Tools (CLT) does not support macOS 11.It is either outdated or was modified.Please update your Command Line Tools (CLT) or delete it if no updates are available.Update them from Software Update in System Preferences or run: softwareupdate --all --install --forceIf that doesn't show you any updates, run: sudo rm -rf /Library/Developer/CommandLineTools sudo xcode-select --installAlternatively, manually download them from: https://developer.apple.com/download/more/. 华生你发现了一个盲点！果然，homebrew 真是好用！🌝 1Your Command Line Tools (CLT) does not support macOS 11. 3. 重新安装CommandLineTools 12$ sudo rm -rf /Library/Developer/CommandLineTools$ sudo xcode-select --install 根据网络环境，等待安装成功即可~ 4. 再次检查 clang 版本 12345$ clang --versionApple clang version 12.0.0 (clang-1200.0.32.29)Target: x86_64-apple-darwin20.3.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/bin 5. 重新安装 SDK 试试？ 123$ pip install jqdatasdk......(省略部分日志)Successfully installed SQLAlchemy-1.3.23 jqdatasdk-1.8.8 msgpack-1.0.2 pandas-1.2.3 pymysql-1.0.2 requests-2.25.1 thriftpy2-0.4.14 Enjoy~ 后记 测试一下，踏出第一步： 1234567from jqdatasdk import *auth('xxxxxx', 'xxxxxx')# 查询 贵州茅台[600519.XSHG] 近5天的交易数据df = get_price('600519.XSHG', count=5, end_date='2021-03-10', frequency='daily')print(df) 此时得到如下结果： 123456789提示：当前环境 pandas 版本高于 0.25，get_price 与 get_fundamentals_continuously 接口 panel 参数将固定为 False注意：0.25 以上版本 pandas 不支持 panel，如使用该数据结构和相关函数请注意修改auth success open close high low volume money2021-03-04 2095.00 2033.00 2096.00 2010.10 6508829.0 1.329730e+102021-03-05 2000.00 2060.11 2095.00 1988.00 6377920.0 1.310032e+102021-03-08 2074.96 1960.00 2085.00 1960.00 6309959.0 1.272425e+102021-03-09 1955.00 1936.99 2000.00 1900.18 8226581.0 1.610077e+102021-03-10 1977.00 1970.01 1999.87 1967.00 5117174.0 1.013691e+10 得到数据的同时，记得去专业的股票交易等网站去核对查询出来的数据是否准确哦~ 因为这会直接影响到后面量化的指标！！ 参考 https://stackoverflow.com/questions/63972113/big-sur-clang-invalid-version-error-due-to-macosx-deployment-target]]></content>
      <categories>
        <category>技术相关</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020.Q4&年度总结]]></title>
    <url>%2F2021%2F01%2F18%2FQ4-2020-and-year-summary.html</url>
    <content type="text"><![CDATA[我们都在用力的活着 前言 Q4 算是我在涂鸦迎接的第一个挑战，今年的 Q4 对我个人来说也是意义非凡的。 2020，当实「鼠」不易；2021，望「牛」转乾坤！ 1. 我的 Q4 Q4 是我在涂鸦所经历的第一个完整的 Q，涉及到季度 KPI 的考核，所以说 Q4 是我在涂鸦迎接的第一个挑战。 Q4 我也完成了一些人生角色的转变，所以对我个人来说也是意义非凡的。 1.1. 工作 Q4 是 2020 年的尾巴，产品经理要做年度汇报，收尾工作要做的到位、做的漂亮，开发的工作量必然少不了。Q4 的工作是富有难度且极具挑战的。 10-11 月，根据埋点数据进行精准营销的功能。11-12 月，设计并实现了一套营销自动化流程的功能。 目前均已上线投入使用，营销工具的覆盖场景已覆盖公司 100% 的运营同学，同时代码质量我自己也是比较满意，Q4 的工作整体应该是达标状态。 1.2. 生活 国庆加完班，就带着老爸老妈去了趟襄阳，带我爸妈去见妞爸妞妈。整体还算是顺利。 后面错过了 10.24、11.11，终于是在 11.22 带着妞去领了个证，从此以后，xkcoding 也是已婚人士啦。 11.22 这个日子我和妞其实是讨论过的，也被赋予了一些含义： 我的阳历生日是 11.22 我希望 1 + 1 = 2 + 2 这个等式成立，就是希望我俩后面可以生俩宝宝的意思 其他的一些纪念照就不晒啦，哈哈哈~ 1.3. 其他 今年圣诞，去了一趟长沙和如梦技术团队的朋友玩了 3 天，很幸运可以遇到这样一群牛逼的人，亦师亦友的存在。这一次聚会，发现自己站的视角不如他们高，还有很多地方需要学习进步，同时大家也给了一些发展的建议，收获颇丰，我们 21 年再聚！ 2. 年度总结 今年一年抛开疫情对整个社会的影响，对我来说其实挺难的，离职的时机、亲人的离世、经济的压力、个人状态的下滑、身体的不适等等。 但是一切都在变好不是吗？ 入职涂鸦、独立负责且设计技术方案、领证成家、结交一些贵人，我知道我在变得更好。 今年一年坚持下来最正确的事情，就是写日记。写日记可以帮助我回忆、复盘、总结，不至于将一些或痛苦、或美好的回忆淹没在时间的长河里。我也推荐大家尝试记录自己的点滴，不管是日记、照片、还是 vlog … … 3. 来年规划 21 年年初（1.4-1.15）就已经经历了一场「极速」编程的体验，所幸基本功还算扎实，在各方面（deadline、需求复杂、人手不够）的压力下，依然能保质保量的将功能完成并上线。 21 年有一项很重要的事情，就是婚礼，初步定的是 10.3 号，不知道后面会不会受到疫情的影响，好事多磨。 年初申请了一个域名：https://xkcoding.wiki 还在走备案的流程中，后面打算新建一个小站，准备码下一些文字，希望对你有所帮助。 下面就是一些 FLAG 了： 完善 xkcoding.wiki 站点 持续完善 spring-boot-demo 做一个Chat/专栏/小册的尝试 办婚礼（如果疫情影响不大的话） 学习并实践理财知识 读 10 本书（3/10） 参加如梦技术线下聚会 还钱/攒钱 2021，做正确的事，不做容易的事！]]></content>
      <categories>
        <category>总结展望</category>
      </categories>
      <tags>
        <tag>总结展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速运行一个你自己的「一言」程序]]></title>
    <url>%2F2020%2F11%2F02%2Fquick-run-you-own-yiyan.html</url>
    <content type="text"><![CDATA[前言 动漫也好、小说也好、网络也好，不论在哪里，我们总会看到有那么一两个句子能穿透你的心。我们把这些句子汇聚起来，形成一言网络，以传递更多的感动。如果可以，我们希望我们没有停止服务的那一天。 简单来说，一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。 或是感动，或是开心，有或是单纯的回忆。来到这里，留下你所喜欢的那一句句话，与大家分享，这就是一言存在的目的。 ——选自「一言」简介 1. 为什么要自己搭建？ 「一言」其实提供了在线的 api 地址访问，因为「一言」是一个免费的服务，因此必然是对访问频率存在一定的限制，同时也有可能存在一定的网络延迟（考虑地域/网络环境等影响因素）。 「一言」官网：https://hitokoto.cn/ 在线 API 地址：https://v1.hitokoto.cn/ API 文档：https://developer.hitokoto.cn/ 2. 快速运行 本着快速运行的目的，Docker 自然会成为我们的首选工具，好在「一言」提供了官方的 Docker 镜像，简直就是懒人神器~ 首先我们创建一个文件夹存放程序启动时相关的文件 12mkdir -p hitokotocd hitokoto 接着我们创建「一言」的配置文件 config.yml 12345678910111213141516name: 'demo' # 服务名称，例如：hitokotourl: 'hitokoto_api:8000' # 服务地址，例如：https://v1.hitokoto.cnapi_name: 'demo_api_name' # 服务表示，例如：cd-01-demoserver: # 配置 HTTP 服务的信息 host: hitokoto_api # 监听的地址，因为我们采用 docker-compose 启动，因此设置为 service 名称即可 port: '8000' # 监听的端口 compress_body: true # 是否使用 GZIP 压缩redis: # 配置 Redis host: hitokoto_db # Redis 主机名，因为我们采用 docker-compose 启动，因此设置为 service 名称即可 port: 6379 # Redis 端口 password: '' # Redis 密码 database: 0 # Redis 数据库sentences_ab_switcher: # 本节是服务 AB 异步更新的配置，如果您不知道这个是什么意思，请保持默认 a: 1 # a 状态对应的 redis 数据库 b: 2 # b 状态对应的 redis 数据库remote_sentences_url: https://cdn.jsdelivr.net/gh/hitokoto-osc/sentences-bundle@latest/ # 语句库地址，通常默认即可。如果您想使用您自己打包部署的语句库，您可以修改此项 然后再创建 docker-compose.yml 编排文件 12345678910111213version: "3.8"services: hitokoto_db: image: redis:6.0.8 hitokoto_api: image: hitokoto/api ports: - 8000:8000 depends_on: - hitokoto_db volumes: - ./config.yml:/usr/src/app/data/config.yml:ro 最后运行一下 docker-compose up ，待得运行成功之后，我们在终端测试一下接口 123456789101112131415161718$ curl localhost:8000 | json_pp % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 316 100 316 0 0 11285 0 --:--:-- --:--:-- --:--:-- 11285&#123; "creator_uid" : 5655, "commit_from" : "web", "creator" : "Muzi.言寺", "hitokoto" : "曾盛开过一朵，曾不会败落，曾在他眼中流淌过浩瀚的银河。", "uuid" : "d6e59b5a-6a12-4d14-ac64-fc0977de6853", "created_at" : "1585293655", "reviewer" : 4756, "from" : "不痛", "from_who" : "南语", "type" : "h", "length" : 27, "id" : 5358&#125; 此时一个内网的「一言」程序就已经搭建成功了~ 3. 快速使用 如何在 html 文件快速集成，这里贴个官方文档给出的代码，同时自己做了点改造~ 创建 index.html 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=100, initial-scale=1.0" /&gt; &lt;title&gt;一言&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id="hitokoto" style=" text-align: center; border: 2px dashed black; padding: 10%; font-weight: 600; " &gt; :D 获取中... &lt;/p&gt; &lt;/body&gt; &lt;script&gt; fetch("http://localhost/api") .then((response) =&gt; response.json()) .then((data) =&gt; &#123; const hitokoto = document.getElementById("hitokoto"); let from; switch (data.type) &#123; case "a": from = `《$&#123;data.from&#125;》//动画`; break; case "b": from = `《$&#123;data.from&#125;》//漫画`; break; case "g": from = `《$&#123;data.from&#125;》//其他`; break; case "h": from = `《$&#123;data.from&#125;》//影视`; break; case "i": from = `《$&#123;data.from&#125;》//诗词`; break; case "k": from = `《$&#123;data.from&#125;》//哲学`; break; case "d": from = `《$&#123;data.from&#125;》//文学`; break; case "e": from = `「$&#123;data.from&#125;」//原创`; break; case "c": from = `「$&#123;data.from&#125;」//游戏`; break; case "f": from = `「$&#123;data.from&#125;」//来自网络`; break; case "j": from = `「$&#123;data.from&#125;」//网易云`; break; case "l": from = `「$&#123;data.from&#125;」//抖机灵`; break; default: from = `「$&#123;data.from&#125;」//其他`; break; &#125; hitokoto.innerText = `$&#123;data.hitokoto&#125; —— $&#123;from&#125;`; &#125;) .catch(console.error); &lt;/script&gt;&lt;/html&gt; 我们使用 nginx 部署这个HTML 文件，同时反向代理「一言」的 API 接口，此时需要创建 nginx 的配置文件 default.conf 123456789101112131415161718192021222324252627282930server &#123; listen 80; listen [::]:80; server_name localhost; location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; location /api &#123; proxy_pass http://hitokoto_api:8000/; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_buffering off; sendfile off; proxy_max_temp_file_size 0; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_temp_file_write_size 64k; proxy_http_version 1.1; proxy_request_buffering off; &#125;&#125; 同时将 docker-compose.yml 文件修改一下，去掉 api 暴露的8000端口，同时增加nginx的编排配置： 1234567891011121314151617181920version: "3.8"services: hitokoto_db: image: redis:6.0.8 hitokoto_api: image: hitokoto/api depends_on: - hitokoto_db volumes: - ./config.yml:/usr/src/app/data/config.yml:ro nginx: image: nginx:1.18.0 ports: - 80:80 depends_on: - hitokoto_api volumes: - ./default.conf:/etc/nginx/conf.d/default.conf:ro - ./index.html:/usr/share/nginx/html/index.html 再次执行 docker-compose up ，待运行成功之后，打开浏览器，输入 localhost 即可查看到页面，同时因为去掉了8000 端口的暴露，之前的http://localhost:8000的接口地址就变更为了 http://localhost/api了，是不是很方便呢~ 代码示例 https://github.com/xkcoding/practice_demo/tree/master/quick-run-hitokoto]]></content>
      <categories>
        <category>技术相关</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在 Spring 环境下优雅的实现策略模式]]></title>
    <url>%2F2020%2F10%2F11%2Fhow-to-use-strategy-design-pattern-in-spring.html</url>
    <content type="text"><![CDATA[背景 最近在忙一个需求，大致就是给满足特定条件的用户发营销邮件，但是用户的来源有很多方式：从 ES 查询的、从 csv 导入的、从 MongoDB 查询…… 需求很简单，但是怎么写的优雅，方便后续扩展，就存在很多门道了。 我们的项目是基于 Spring Boot 开发的，因此这篇文章也会基于 Spring Boot 作为基础框架，教你如何使用 Spring 依赖注入的特性，优雅的实现策略模式。 1. 简单粗暴 最简单粗暴直接的方式莫过于 if...else… 了，伪代码如下： 1234567if(来源 == ES)&#123; // TODO: ES Query&#125;else if(来源 == CSV)&#123; // TODO: Read CSV File&#125;else if(来源 == MongoDB)&#123; // TODO: MongoDB Query&#125; 如果后面还需要从其他平台获取，那就在接着添加 else if...，这种方式固然简单直接，但是当后续扩展的方式越来越多，相应的if...else...也会越来越长，emmm……怎么说呢，黑猫白猫，能抓到老鼠的就是好猫。 2. 策略模式 在 Spring 环境下实现策略模式异常简单，毕竟 Spring 提供的依赖注入简直就是开发利器~ 既然是策略模式，那么定义策略肯定是首当其冲，策略我们使用枚举实现最佳。 1234567891011121314public enum GroupType &#123; /** * 从 ES 查询 */ ES, /** * 从 MongoDB 查询 */ MONGODB, /** * 从 文件 读取 */ FILE&#125; 下一步，我们定义一个接口，用于抽象通用的功能。 123456789101112131415161718192021222324252627282930313233343536public interface IGroupSelect &#123; /** * 人群获取方式 * * @return 人群选择枚举 */ GroupType type(); /** * 查询满足条件的用户 * * @param groupQuery 查询条件 * @return 满足条件的用户 */ default List&lt;GroupUser&gt; queryUser(GroupQuery groupQuery) &#123; checkQueryCondition(groupQuery); return doQuery(groupQuery); &#125; /** * 事前校验查询条件 * * @param groupQuery 查询条件 * @throws IllegalArgumentException 参数异常 */ void checkQueryCondition(GroupQuery groupQuery) throws IllegalArgumentException; /** * 真正的查询方法 * * @param groupQuery 查询条件 * @return 满足条件的用户 */ List&lt;GroupUser&gt; doQuery(GroupQuery groupQuery);&#125; 这一步，小伙伴们有没有发现里面也包含了模板方法模式呢？ 然后就是不同策略的具体实现了。 ES 策略 12345678910111213141516171819202122232425262728293031323334353637383940414243@Slf4j@Servicepublic class EsGroupSelect implements IGroupSelect &#123; /** * 人群获取方式 * * @return 人群选择枚举 */ @Override public GroupType type() &#123; return GroupType.ES; &#125; /** * 事前校验查询条件 * * @param groupQuery 查询条件 * @throws IllegalArgumentException 参数异常 */ @Override public void checkQueryCondition(GroupQuery groupQuery) throws IllegalArgumentException &#123; log.info("groupQuery = &#123;&#125;", groupQuery); &#125; /** * 查询满足条件的用户 * * @param groupQuery 查询条件 * @return 满足条件的用户 */ @Override public List&lt;GroupUser&gt; doQuery(GroupQuery groupQuery) &#123; List&lt;GroupUser&gt; result = new ArrayList&lt;&gt;(); // TODO: // 1. 复杂的 ES 查询逻辑 // 2. 根据条件筛选满足条件的用户数据 for (int i = 1; i &lt;= 15; i++) &#123; result.add(GroupUser.of("ES用户" + i, i + "@es.com")); &#125; return result; &#125;&#125; 文件策略 123456789101112131415161718192021222324252627282930313233343536373839404142@Slf4j@Servicepublic class FileGroupSelect implements IGroupSelect &#123; /** * 人群获取方式 * * @return 人群选择枚举 */ @Override public GroupType type() &#123; return GroupType.FILE; &#125; /** * 事前校验查询条件 * * @param groupQuery 查询条件 * @throws IllegalArgumentException 参数异常 */ @Override public void checkQueryCondition(GroupQuery groupQuery) throws IllegalArgumentException &#123; log.info("groupQuery = &#123;&#125;", groupQuery); &#125; /** * 查询满足条件的用户 * * @param groupQuery 查询条件 * @return 满足条件的用户 */ @Override public List&lt;GroupUser&gt; doQuery(GroupQuery groupQuery) &#123; List&lt;GroupUser&gt; result = new ArrayList&lt;&gt;(); // TODO: // 1. 复杂的解析、读文件 // 2. 根据条件筛选满足条件的用户数据 for (int i = 1; i &lt;= 3; i++) &#123; result.add(GroupUser.of("文件读取用户" + i, i + "@file.com")); &#125; return result; &#125;&#125; MongoDB 策略 123456789101112131415161718192021222324252627282930313233343536373839404142@Slf4j@Servicepublic class MongoGroupSelect implements IGroupSelect &#123; /** * 人群获取方式 * * @return 人群选择枚举 */ @Override public GroupType type() &#123; return GroupType.MONGODB; &#125; /** * 事前校验查询条件 * * @param groupQuery 查询条件 * @throws IllegalArgumentException 参数异常 */ @Override public void checkQueryCondition(GroupQuery groupQuery) throws IllegalArgumentException &#123; log.info("groupQuery = &#123;&#125;", groupQuery); &#125; /** * 查询满足条件的用户 * * @param groupQuery 查询条件 * @return 满足条件的用户 */ @Override public List&lt;GroupUser&gt; doQuery(GroupQuery groupQuery) &#123; List&lt;GroupUser&gt; result = new ArrayList&lt;&gt;(); // TODO: // 1. 复杂的 MongoDB 查询逻辑 // 2. 根据条件筛选满足条件的用户数据 for (int i = 1; i &lt;= 7; i++) &#123; result.add(GroupUser.of("MongoDB用户" + i, i + "@mongo.com")); &#125; return result; &#125;&#125; 现在到了最后一步，就是如何通过 Spring 优雅的实现策略模式的选择呢？敲黑板，考试必考！ 我们通过定义一个工厂类，然后使用 Spring 的依赖注入特性，可以注入一个接口的多个实现，这里采用 List&lt;IGroupSelect&gt; 的形式注入，Spring 也支持通过 Map&lt;String,IGroupSelect&gt; 的形式注入，如果使用 Map 注入，那么 key 就是类名，小伙伴们自己也可以测试一下~ 12345678910111213141516@Servicepublic class GroupSelectFactory &#123; @Autowired private List&lt;IGroupSelect&gt; groupSelectList; /** * 根据人群类型选择具体的实现类 * * @param type 人群类型 * @return 人群选择具体实现类 */ public IGroupSelect getGroupSelect(GroupType type) &#123; Optional&lt;IGroupSelect&gt; groupSelectOptional = groupSelectList.stream().filter(t -&gt; t.type() == type).findAny(); return groupSelectOptional.orElseThrow(() -&gt; new IllegalArgumentException("暂不支持该人群方式")); &#125;&#125; 最后写个定时任务测试一下吧。 1234567891011121314151617181920212223242526272829@Autowiredprivate GroupSelectFactory groupSelectFactory;/** * 模拟定时发送营销邮件 */@Scheduled(cron = "0/10 * * * * ?")public void sendEmailTask() &#123; List&lt;SendEmailTask&gt; taskList = new ArrayList&lt;&gt;(); for (GroupType groupType : GroupType.values()) &#123; GroupQuery groupQuery = new GroupQuery("虚头巴脑的 " + groupType.name() + " 查询条件"); taskList.add(SendEmailTask.of(groupType, groupQuery)); &#125; taskList.forEach(task -&gt; &#123; List&lt;GroupUser&gt; groupUsers = groupSelectFactory.getGroupSelect(task.getType()).queryUser(task.getQuery()); log.info("groupUsers = &#123;&#125;", groupUsers); &#125;);&#125;@Data@NoArgsConstructor@AllArgsConstructor(staticName = "of")static class SendEmailTask implements Serializable &#123; private static final long serialVersionUID = -3461263089669779193L; private GroupType type; private GroupQuery query;&#125; 观察控制台，看看日志输出吧~ 总结 本文使用策略模式实现不同人群的查询，后续如果要增加短信、微信、钉钉的消息发送，是不是也可以用策略模式实现呢？ 使用 Spring 的依赖注入特性，可以注入一个接口的多个实现，很容易就实现了策略模式的选择，这样后续添加一种策略的时候，完全不需要改动主要逻辑，只需添加具体实现即可。 细心的小伙伴可以发现，本文虽然是讲策略模式，其实里面还包含了模板方法、工厂模式，多种设计模式的协同作战，食用味道更佳哟~ 配套代码：https://github.com/xkcoding/practice_demo/tree/master/strategy-design-pattern-in-spring]]></content>
      <categories>
        <category>技术相关</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020.Q2&Q3总结]]></title>
    <url>%2F2020%2F09%2F30%2FQ2-Q3-2020.html</url>
    <content type="text"><![CDATA[今天国庆节，那就祝大家不加班的不要堵车，加班的不要出生产事故。😏 转眼，今年仅剩下百天不到啦。高能预警，灵魂发问环节。各位今年的计划完成的咋样？是超期完成还是又一次偷偷摸摸改成了明年计划？行动起来，今年说不准还有机会的。 1. 总结 本打算是 Q2、Q3 分别做总结的，无奈 Q2 实在是糟心事都搅在一块了，Q2 也就顺理成章的拖延到 Q3 总结里。 我的 Q2、Q3 总结下来就是一句话：被糟心事包裹的 Q2、Q3，但仍有一丝美好。 大部分不顺心的事情集中在 Q2，外公病情加重导致面试流程延期、长时间的待业也带来了一些负面情绪。7 月初传来外公病情好转的消息，没想到 7 月底，外公还是走了。世事无常，调整情绪之后，也继续之前的一些面试流程。 面了一些公司，包括：有赞(有赞云)、涂鸦(云端开发)、酷家乐(房企业务)、天猫精灵(中台事业部)、天猫新零售(国际化中台)，其中大华体验极差(被放鸽子)。几个 offer 抉择下，最终选择了涂鸦，这里感谢老同学 @hank 的内推支持~ 从入职到现在，也已经待了 1 个月时间，也说下自己的感受。 氛围：技术氛围+团队氛围，真的很重要。 组员：team 里的小伙伴人都非常 nice，交流起来不费劲。 规范：各种流程规范化，极大提升开发体验。 从离职(2020.03.19)到入职(2020.08.17)，差 2 天满 5 个月，中途不乏很多朋友的鼓励、帮助，感谢@亚东、图迹小伙伴@东哥/@明哥、折腾群群主 @苏洋 在我迷茫时期的解惑，感谢如梦大佬们 @春哥/@冷冷 对我帮助，感谢前 TL @Rink、前 HR@从燕的帮助，感谢一票大学同学以及一些因代码结缘的朋友(@史学森/@Harry)的鼓励，真的十分感谢！ 2. 展望 Q4 迎来的第一个任务，就是国庆带我爸妈去见见我家妞的爸妈，希望一切顺利~ 希望在涂鸦的工作一切顺利，努力工作，还清上半年债务~ 丢失了一段时间的东西，需要重新拾起来。 3. 感想 自律的人不一定优秀,但优秀的人一定自律。 将近半年的待业真的很需要勇气，特别需要感谢父母的理解，感谢我家妞的包容，感谢朋友们的鼓励。 PS：大家如果有面经需要，欢迎私我~ 如果有涂鸦内推需要，欢迎私我~]]></content>
      <categories>
        <category>总结展望</category>
      </categories>
      <tags>
        <tag>总结展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末的不务正业~]]></title>
    <url>%2F2020%2F09%2F13%2Fwhat-i-like-to-do-0.html</url>
    <content type="text"><![CDATA[周末的不务正业~ 花了一个半小时折的燕子]]></content>
      <categories>
        <category>忙里偷闲</category>
      </categories>
      <tags>
        <tag>忙里偷闲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[justauth-spring-boot-starter 1.3.4.beta 发布]]></title>
    <url>%2F2020%2F08%2F31%2Fjustauth-spring-boot-starter-publish-1.3.4.beta.html</url>
    <content type="text"><![CDATA[前言 好久不见，鸽了那么久，我回来了。Q2&amp;Q3 发生了挺多事情，等后面总结的时候再详细说说。今天给大家带来的是 justauth-spring-boot-starter 的 1.3.4.beta 新版本的一些新特性。废话不多说，走起 ~ 1. 版本特性 本次版本发布，使用的 JustAuth 的版本是 1.15.7-beta.3 版本，该版本主要是完善了 2 个能力： 使用新版本的 simple-http ，支持自定义配置代理的功能，方便有特殊需求的小伙伴测试 Google/Facebook 等国外的一些第三方登录平台 支持自定义 scopes 参数，方便小伙伴们获取更多的用户权限 同时升级 hutool-core 版本：5.4.0，修复 JSONUtil.toJsonStr(obj) 报错的问题，参见 ISSUE#8 2. 如何使用 2.1. 引用依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding.justauth&lt;/groupId&gt; &lt;artifactId&gt;justauth-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.4.beta&lt;/version&gt;&lt;/dependency&gt; 2.2. 如何配置自定义 http proxy 修改配置文件，增加如下配置： 12345678justauth: http-config: timeout: 30000 proxy: GOOGLE: type: HTTP hostname: 127.0.0.1 port: 10080 注：当项目中使用了自定义的第三方登录，并且需要使用代理时，也要在 http-config 节点下添加相关配置，格式参考上面示例 2.3. 自定义 Scopes 修改配置文件，增加如下配置： 1234567891011justauth: enabled: true type: QQ: client-id: 10**********6 client-secret: 1f7d08**********5b7**********29e redirect-uri: http://oauth.xkcoding.com/demo/oauth/qq/callback union-id: false scopes: - get_user_info - xxxx 注：你可以前往 me.zhyd.oauth.enums.scope 包下查看各个渠道所支持的 scopes，当然你可以不配置该项，JustAuth 会默认添加上一些基础 scope 最后，关于更多的 JustAuth 其他的基础用法，欢迎前往 https://justauth.wiki/ 查阅]]></content>
      <categories>
        <category>开源</category>
        <category>JustAuth</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>JustAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悼念外公]]></title>
    <url>%2F2020%2F07%2F28%2Fmourning-grandpa.html</url>
    <content type="text"><![CDATA[终究是没能熬过这个庚子年。 今年以来，外公就已经躺在床上起不来了，上周开始进不了食，住院治疗。今天接到爸爸的电话，外公永远地离开我们了。 我算是从小被外公外婆和表姐疼大的孩子，他们一直陪伴着我的成长，直到我远赴湖北求学，才开始变得聚少离多。从有记忆开始，外公就是个不爱说话的人，能让外公说很多话的场景，大概也是在表弟和我打闹的时候的一些训斥。外公这辈子是个劳碌命，是一个闲不住的人，喜欢听戏，喜欢田地，但凡还动的了就要下地干活，啥都种一点，还啥都种的好。外公喜欢花草，家里的院子、二楼的阳台，养了很多盆栽，即使到现在回想起来，我依然还是绝大部分都不认识。 其实我是个挺怕外公的人，外公是个不苟言笑的人，虽然外公瘦瘦的还有些佝偻着背，但是还是极具威严。记得19年第一次带妞去见外公外婆的时候，那时候外公还下得了床，但是得靠支架支撑，我挺怕他们会因为外地女孩儿的身份对妞有偏见，没想到他们很开心，那是我少有的几次见到外公笑的场景。 接到消息的时候，脑海是一片空白的，虽然早已做好了准备，但是当不幸到来的时候，自己还是有些扛不住。外孙未能如愿尽孝，子欲养而亲不待的痛楚莫过如此。愿您在另一个世界里能够好好休息，愿那儿有您喜欢的花花草草，愿那儿有您爱听的戏，愿您不再有病痛的折磨。 谨以此文悼念去世的外公 杨春仙 您的外孙 扬凯]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot-demo 配套视频教程]]></title>
    <url>%2F2020%2F06%2F28%2Fvideo-tutorial-of-spring-boot-demo.html</url>
    <content type="text"><![CDATA[spring-boot-demo 项目地址：https://github.com/xkcoding/spring-boot-demo spring boot demo 是一个用来深度学习并实战 spring boot 的项目，目前总共包含 66 个集成demo，已经完成 54 个。 现在，配套视频正式来袭~ 配套视频介绍 讲师：冷冷 介绍：国内知名开源项目 pig 作者，Spring Boot 的 committer，Spring Security Oauth 的 committer，Spring Cloud Alibaba 的 committer，Spring Cloud Gateway 的 committer，Nacos、Sentinel 的 committer，Feign 的 commiter 视频地址：https://www.bilibili.com/video/BV1Nf4y117W6 视频简介：本系列视频课程全部开源免费，课程内容保持和 spring-boot-demo 完全一致，所有 Spring Boot 版本采用官网最新版本，所有中间件部署均采用 Docker 安装形式。 更新计划：预期一个月内完成 最后 哎哟，自己拖更了这么久，十分抱歉，这次冷神花大精力制作配套视频，xkcoding，冲冲冲，跟上进度，不拖冷神后腿！ 盆友们，答应我，这次一定好嘛~]]></content>
      <categories>
        <category>开源</category>
        <category>spring-boot-demo</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决 Quartz Job 中无法注入 Spring Bean]]></title>
    <url>%2F2020%2F06%2F05%2Ffix-quartz-job-cannot-autowired-spring-beans.html</url>
    <content type="text"><![CDATA[1. 问题 不知道小伙伴们在 Spring 集成 Quartz 的时候有没有遇到过这样一个问题，就是在 Quartz 的 Job 中 @Autowired 一个 Spring Bean 的时候会报空指针异常。如果在 Spring 中无法使用 @Autowired 进行注入一个 Bean 的话，这无疑是一个噩耗，那么遇到这个问题，该如何解决呢？ 2. 原因 出现这个问题是因为定时任务的 Job 对象实例化的过程是通过 Quartz 内部自己完成的，但是我们通过 Spring 进行注入的 Bean 却是由 Spring 容器管理的，Quartz 内部无法感知到 Spring 容器管理的 Bean，所以没有办法在创建 Job 的时候就给装配进去。 3. 源码分析 传统的 Spring 项目，我们可以看到 Schedule 的创建是通过 SchedulerFactoryBean 进行创建的，我们看一下 SchedulerFactoryBean 源码，该类实现了 InitializingBean 接口，会在 Bean 属性初始化之后调用 afterPropertiesSet() 方法。 12345678@Overridepublic void afterPropertiesSet() throws Exception &#123; // 省略部分代码... // Initialize the Scheduler instance... this.scheduler = prepareScheduler(prepareSchedulerFactory()); // 省略部分代码...&#125; 接着查看 prepareScheduler() 方法，可以发现如果 jobFactory 不存在的话，默认会使用 AdaptableJobFactory 实现对 Job 对象的创建。 123456789101112131415161718192021222324252627private Scheduler prepareScheduler(SchedulerFactory schedulerFactory) throws SchedulerException &#123; // 省略部分代码... // Get Scheduler instance from SchedulerFactory. try &#123; Scheduler scheduler = createScheduler(schedulerFactory, this.schedulerName); populateSchedulerContext(scheduler); if (!this.jobFactorySet &amp;&amp; !(scheduler instanceof RemoteScheduler)) &#123; // Use AdaptableJobFactory as default for a local Scheduler, unless when // explicitly given a null value through the "jobFactory" bean property. this.jobFactory = new AdaptableJobFactory(); &#125; if (this.jobFactory != null) &#123; if (this.applicationContext != null &amp;&amp; this.jobFactory instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) this.jobFactory).setApplicationContext(this.applicationContext); &#125; if (this.jobFactory instanceof SchedulerContextAware) &#123; ((SchedulerContextAware) this.jobFactory).setSchedulerContext(scheduler.getContext()); &#125; scheduler.setJobFactory(this.jobFactory); &#125; return scheduler; &#125; // 省略部分代码...&#125; 既然找到了源码，那么处理起来就方便了，我们如果可以自定义 JobFactory 的话，在创建完 Job 实例之后，再将 Job 注入到 Spring 容器中即可解决该问题。 4. 解决 首先自定义一个 JobFactory，通过 AutowireCapableBeanFactory 将创建好的 Job 对象交给 Spring 管理 123456789101112131415161718@Configurationpublic class CustomJobFactory extends AdaptableJobFactory &#123; @Autowired private AutowireCapableBeanFactory autowireCapableBeanFactory; /** * Create the job instance, populating it with property values taken * from the scheduler context, job data map and trigger data map. * * @param bundle */ @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; Object jobInstance = super.createJobInstance(bundle); autowireCapableBeanFactory.autowireBean(jobInstance); return jobInstance; &#125;&#125; 再创建一个配置类，将自定义的 JobFactory 设置到 Schedule 中 1234567891011121314151617@Configurationpublic class QuartzConfig &#123; @Autowired private CustomJobFactory customJobFactory; @SneakyThrows @Bean public Scheduler scheduler()&#123; SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); // 自定义 JobFactory 使得在 Quartz Job 中可以使用 @Autowired scheduler.setJobFactory(customJobFactory); scheduler.start(); return scheduler; &#125; &#125; 这样你就可以愉快的在定时任务中使用 @Autowired注入 Spring 管理的 Bean 了。 12345678910@Slf4jpublic class JobDemo2 implements Job &#123; @Autowired private DemoService demoService; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; demoService.echo("JobDemo2"); &#125;&#125; 5. 知识拓展 5.1. 通过 SpringUtil 实现相同效果 当然了，如果不想通过这种方法实现的话，还有另外一种方式。 创建一个 Spring 工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * &lt;p&gt; * Spring 工具类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2020-06-05 11:13 */@Slf4j@Componentpublic class SpringUtil implements ApplicationContextAware &#123; private static ApplicationContext context; @Override public void setApplicationContext(ApplicationContext context) throws BeansException &#123; SpringUtil.context = context; &#125; /** * 获取 Spring Bean * * @param clazz 类 * @param &lt;T&gt; 泛型 * @return 对象 */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; if (clazz == null) &#123; return null; &#125; return context.getBean(clazz); &#125; /** * 获取 Spring Bean * * @param bean 名称 * @param &lt;T&gt; 泛型 * @return 对象 */ @SuppressWarnings("unchecked") public static &lt;T&gt; T getBean(String bean) &#123; if (bean == null) &#123; return null; &#125; return (T) context.getBean(bean); &#125; /** * 获取 Spring Bean * * @param beanName 名称 * @param clazz 类 * @param &lt;T&gt; 泛型 * @return 对象 */ public static &lt;T&gt; T getBean(String beanName, Class&lt;T&gt; clazz) &#123; if (null == beanName || "".equals(beanName.trim())) &#123; return null; &#125; if (clazz == null) &#123; return null; &#125; return (T) context.getBean(beanName, clazz); &#125; /** * 获取上下文 * * @return 上下文 */ public static ApplicationContext getContext() &#123; if (context == null) &#123; throw new RuntimeException("There has no Spring ApplicationContext!"); &#125; return context; &#125; /** * 发布事件 * * @param event 事件 */ public static void publishEvent(ApplicationEvent event) &#123; if (context == null) &#123; return; &#125; try &#123; context.publishEvent(event); &#125; catch (Exception ex) &#123; log.error(ex.getMessage()); &#125; &#125;&#125; 然后在定时任务中通过该工具类获取 Spring Bean，也可以实现同样的效果。 123456789@Slf4jpublic class JobDemo1 implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; DemoService demoService = SpringUtil.getBean(DemoService.class); demoService.echo("JobDemo1"); &#125;&#125; 5.2. Spring Boot 2.x 中的实现 了解 Spring Boot 自动装配机制的小伙伴应该都知道，当我们引入了 spring-boot-starter-quartz 这样一个 starter 依赖之后，最终其实是通过 Spring Boot 的 SPI 机制，自动加载了一个 QuartzAutoConfiguration 配置类，该配置类是对 Quartz 中的一些对象及配置进行一系列的初始化操作。 在这个配置类中，定义了一个 SchedulerFactoryBean，这个类主要是实现在 Spring 中进行对任务的调度。 需要注意的是，在 Spring Boot 中，该类默认是通过 SpringBeanJobFactory 实现对 Job 对象的创建。源码如下： 123456789101112@Bean@ConditionalOnMissingBeanpublic SchedulerFactoryBean quartzScheduler(QuartzProperties properties, ObjectProvider&lt;SchedulerFactoryBeanCustomizer&gt; customizers, ObjectProvider&lt;JobDetail&gt; jobDetails, Map&lt;String, Calendar&gt; calendars, ObjectProvider&lt;Trigger&gt; triggers, ApplicationContext applicationContext) &#123; SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean(); SpringBeanJobFactory jobFactory = new SpringBeanJobFactory(); jobFactory.setApplicationContext(applicationContext); schedulerFactoryBean.setJobFactory(jobFactory); // 省略其余代码.... return schedulerFactoryBean;&#125; 那么这个 SpringBeanJobFactory 有什么特殊的呢？该类继承了 AdaptableJobFactory 同时也实现了 ApplicationContextAware 接口 1234567891011@Overrideprotected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123; // 关键代码 Object job = (this.applicationContext != null ? this.applicationContext.getAutowireCapableBeanFactory().createBean( bundle.getJobDetail().getJobClass(), AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR, false) : super.createJobInstance(bundle)); // 省略其余代码.... return job;&#125; 我们可以看到该类在重写 createJobInstance() 方法中，创建 Job 对象的时候，会先判断是否在 Spring 上下文中，如果是在 Spring 环境中，也是通过 AutowireCapableBeanFactory 将 Job 对象放在 Spring 容器中，如果没有，则会调用父类 AdaptableJobFactory 进行反射创建 Job 对象。 从这儿可以看出，Spring Boot 2.x 版本通过 spring-boot-starter-quartz 集成之后，默认就是可以在 Job 对象中使用 @Autowired 的，并且实现的思路和我们是一致的，通过 AutowireCapableBeanFactory 将 Job 对象放入 Spring 容器中才是正确做法。 6. 代码 Spring 集成 Quartz：https://github.com/xkcoding/practice_demo/tree/master/quartz-demo-spring Spring Boot 集成 Quartz：https://github.com/xkcoding/practice_demo/tree/master/quartz-demo-spring-boot]]></content>
      <categories>
        <category>技术相关</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客是如何集成CICD的？]]></title>
    <url>%2F2020%2F06%2F01%2Fhow-does-my-blog-integrate-cicd.html</url>
    <content type="text"><![CDATA[1. 前言 博客现在貌似成为了一个技术人的标配，从最初的炫技到单纯的记录自己的成长历程。我的博客也经历了很多次「蜕变」。 当下博客的选型十分多，这里我列举一些： 动态博客 WordPress：http://www.wordpress.com/ Ghost：https://ghost.org/ Halo：https://halo.run/ … 静态博客 jekyll：http://jekyllcn.com/ hexo：https://hexo.io/ hugo：https://gohugo.io/ 关于动态和静态的区别主要有以下几点: 资源占用：静态博客相比动态博客占用服务器资源更少； 发布更新：由于静态博客没有管理后台，所以发布更新内容要比动态博客繁琐； 访问速度：静态博客没有数据库的访问连接，所以静态博客访问速度更快； 本站使用的就是静态博客 hexo 加上 Next 主题搭建的，同时也自定义了一些样式和功能。上面说到静态博客发布更新文章比较繁琐，那么有没有什么方法可以简化发布流程，提升整个写作体验呢？答案就是 CICD。 2. 什么是 CICD？ CI：持续集成 CD：持续交付、持续部署 具体概念，大家可以自行百度查阅。 3. 「代码日记」的心路历程 这里就略过了从 QZone、WordPress 的那些经历，直接从 hexo 开始 3.1. 原始阶段 最开始接触 hexo，还是懵懂的学生阶段，因为是静态博客，同时又可以托管到 GitHub，使用 GitHub Pages 服务发布网站，避免了大额的服务器花销，这让我深深的喜欢上了 hexo。 那时候我每次写完文章，就本地 hexo g 一下，将打包生成的 public 目录，放置在 pages 分支，然后提交到 GitHub，就算一次博文的发布。 缺点 将博客托管在 GitHub，没有了服务器的开销，但是因为网络环境的问题，明明已经是静态资源的博客，居然经常性的访问不到。 后面通过在 coding.net 部署解决国内访问慢的问题，通过阿里云 DNS 解析配置，国外默认到 xkcoding.github.io，国内默认到 xkcoding.coding.me 3.2. 折腾 v1.0 16 年工作之后，在 618 入手了一台大米云服务器。那时，coding.net 强制要求 Pages 服务底部增加版权，否则会弹出广告信息，于是就想着将博客部署在自己服务器上。 因为博客都是静态资源，仅需要安装 nginx 即可解决。但是部署在自己服务器，如果每次写完文章都需要 ftp 传到指定目录，那也太麻烦了。v1.0 就是在这样的前提下诞生了。 我在自己的服务器搭建了 Jenkins，同时在 GitHub 开启 webhook，当有新的 push 操作的时候，就会触发 Jenkins 任务。Jenkins 流水线任务主要就是获取代码、下载依赖、打包压缩、最后将打包好的资源文件放在 nginx 目录。 同时集成了 Travis-ci，自动往 pages 分支提交内容，为了维护 pages 的站点，避免偶尔自己服务器宕机导致我自己无法查阅博客内容。 Jenkins 和 Travis 都会在部署完成之后触发邮件提醒，通知我博客是否部署成功，如果失败，会附带失败日志。 缺点 v1.0 的版本基本已经可以满足要求了，也陪伴了我将近 3 年的时光。但是不乏还是存在缺点： 随着我的不断折腾，服务器跑的服务越来越多，导致服务器资源不够，有时候会出现 Jenkins 挂掉的情况，导致部署失败 因为对博客做了写定制化改造，集成了一些第三方插件，博客配置文件携带了比较敏感的 key/secret 信息，开始变得不太适合放在 GitHub 分享 ① Jenkinsfile 源码地址：https://github.com/xkcoding/MyBlog/blob/master/.jenkins/Jenkinsfile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#!/usr/bin/env groovy Jenkinsfilepipeline &#123; agent any environment &#123; CONFIG_FILE = "_config.yml" BLOG_DIR = "/data/xkcoding.com" GIT_REPO = "https://github.com/xkcoding/MyBlog.git" USERMAIL = "237497819@qq.com" &#125; stages &#123; stage("获取/更新代码代码") &#123; steps &#123; echo "Git仓库代码: $&#123;GIT_REPO&#125;" echo "校验是否已存在代码" script &#123; if (fileExists(file:"$&#123;CONFIG_FILE&#125;")) &#123; echo "项目存在，准备更新代码" sh "git pull origin master" &#125;else&#123; echo "项目不存在，准备拉取代码" git 'https://github.com/xkcoding/MyBlog.git' &#125; &#125; &#125; &#125; stage("下载依赖") &#123; steps &#123; echo "开始下载NPM依赖" sh "npm install" &#125; &#125; stage("打包/压缩博客") &#123; steps &#123; echo "开始打包Hexo博客" sh "hexo clean &amp;&amp; hexo g" echo "开始压缩Hexo博客" sh "export PATH=/apps/node-v8.0.0-linux-x64/bin:$PATH &amp;&amp; gulp" &#125; &#125; stage("部署") &#123; steps &#123; echo "删除旧目录" sh "rm -rf $&#123;BLOG_DIR&#125;" echo "部署静态页面到nginx目录" sh "mv public $&#123;BLOG_DIR&#125;" echo "删除依赖目录" sh "rm -rf node_modules" &#125; &#125; stage("上线") &#123; steps &#123; echo "重启Nginx" sh "nginx -s reload" &#125; &#125; &#125; post &#123; always &#123; emailext ( subject: '''构建通知：$&#123;JOB_NAME&#125; [$&#123;BUILD_NUMBER&#125;] $&#123;BUILD_STATUS&#125;''', body: ''' &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;$&#123;JOB_NAME&#125;-第$&#123;BUILD_NUMBER&#125;次构建日志&lt;/title&gt; &lt;/head&gt; &lt;body leftmargin="8" marginwidth="0" topmargin="8" marginheight="4" offset="0"&gt; &lt;table width="95%" cellpadding="0" cellspacing="0" style="font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif"&gt; &lt;tr&gt; &lt;td&gt;(本邮件是程序自动下发的，请勿回复！)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;h2&gt; &lt;font color="#0000FF"&gt;构建结果 - $&#123;BUILD_STATUS&#125;&lt;/font&gt; &lt;/h2&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;br /&gt; &lt;b&gt;&lt;font color="#0B610B"&gt;构建信息&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;项目名称： $&#123;JOB_NAME&#125;&lt;/li&gt; &lt;li&gt;构建编号： 第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt; &lt;li&gt;构建状态： $&#123;BUILD_STATUS&#125;&lt;/li&gt; &lt;li&gt;构建日志： &lt;a href="$&#123;BUILD_URL&#125;console"&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt; &lt;li&gt;构建Url： &lt;a href="$&#123;BUILD_URL&#125;"&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;工作目录： &lt;a href="$&#123;BUILD_URL&#125;ws"&gt;$&#123;BUILD_URL&#125;ws&lt;/a&gt;&lt;/li&gt; &lt;li&gt;项目Url： &lt;a href="$&#123;PROJECT_URL&#125;"&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color="#0B610B"&gt;Changes Since Last Successful Build:&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;历史变更记录 : &lt;a href="$&#123;PROJECT_URL&#125;changes"&gt;$&#123;PROJECT_URL&#125;changes&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; $&#123;CHANGES_SINCE_LAST_SUCCESS,reverse=true, format="Changes for Build #%n:&lt;br /&gt;%c&lt;br /&gt;",showPaths=true,changesFormat="&lt;pre&gt;[%a]&lt;br /&gt;%m&lt;/pre&gt;",pathFormat=" %p"&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;Test Informations&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;pre style="font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif"&gt;Total:$&#123;TEST_COUNTS,var="total"&#125;,Pass:$&#123;TEST_COUNTS,var="pass"&#125;,Failed:$&#123;TEST_COUNTS,var="fail"&#125;,Skiped:$&#123;TEST_COUNTS,var="skip"&#125;&lt;/pre&gt; &lt;br /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color="#0B610B"&gt;构建日志 (最后 100行):&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;textarea cols="80" rows="30" readonly="readonly" style="font-family: Courier New"&gt;$&#123;BUILD_LOG, maxLines=100&#125;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; ''', to: "$&#123;USERMAIL&#125;", recipientProviders: [[$class: 'DevelopersRecipientProvider']] ) &#125; &#125;&#125; ② .travis.yml 源码地址：https://github.com/xkcoding/MyBlog/blob/master/.travis.yml 123456789101112131415161718192021222324252627282930313233343536language: node_jsnode_js: - "8.16.0"cache: directories: - node_modulesbefore_install: - npm install -g hexo-cli - npm install -g gulpinstall: - npm installscript: - hexo clean - hexo g &amp;&amp; gulpafter_success: - cd ./public - git init - git config user.name "Yangkai.Shen" - git config user.email "237497819@qq.com" - git add . - git commit -m "TravisCI 自动部署" # Github Pages - git push --force --quiet "https://$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGE&#125;" master:master # Coding Pages - git push --force --quiet "https://xkcoding:$&#123;CODING_TOKEN&#125;@$&#123;CODING_PAGE&#125;" master:masterenv: global: - GITHUB_PAGE: github.com/xkcoding/xkcoding.github.io.git - CODING_PAGE: git.dev.tencent.com/xkcoding/xkcoding.git# 通知notifications: email: recipients: - 237497819@qq.com on_success: always # default: change on_failure: always # default: always ③ 相关截图 3.3. 折腾 v2.0 大米云的服务器将于今年的 6 月份过期，于是掐着这个时间点，我开始了折腾 v2.0 版本。 服务器是去年双十一以新人的身份购入的京东云主机，同时还有返现京豆，羊毛这东西，该薅还得薅，于是一并购入 3 台，这次就趁着无业人员同时又迫于大米云的到期，把它们利用起来。 v2.0 版本主要是做了代码私有化、同时支持容器化的部署。在 3 台服务器上搭建了 Docker Swarm 作为容器集群，架构是 1 主 2 从，然后拿出一台服务器专门搭建了 GitLab，作为后续的个人代码托管平台，在每个节点安装 GitLab Runner 服务，另外在主节点搭建 Traefik 作为容器的反向代理。 Traefik 和 nginx 作用类似，主要用于反向代理，但是在 swarm 模式下，traefik 可以做到 0 配置实现负载均衡，同时可以做到不需要容器在宿主机暴露端口，直接代理到容器里的服务。 这里我选择了 swarm 而没有选择 k8s，主要是因为 k8s 对我来说实在用不上，而且 k8s 占用资源太大，因此选择了更轻量级的 swarm。 主要流程就是，本地写好文章，push 到 GitLab，然后 GitLab 会触发 Pipeline 任务。 pipeline 任务主要有以下几步： 下载依赖（可选，如果 package.json 文件未改动，则跳过） 编译构建，同时压缩静态资源 将静态资源目录打包成 docker 镜像，push 到阿里云镜像仓库 部署上线，调用 swarm 主节点上的 runner 来执行 docker stack deploy 来部署 下线（手动操作，如果我想向下，可以直接操作） 分享 ① .gitlab-ci.yml 源码地址：https://github.com/xkcoding/MyBlog/blob/master/.gitlab-ci.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495variables: DOCKER_REGION: "registry.cn-hangzhou.aliyuncs.com" DOCKER_NAMESPACE: "xkcoding" APP_NAME: "myblog" BUILD_IMAGE: "$DOCKER_REGION/$DOCKER_NAMESPACE/nodebuild:8.17.0-alpine3.11" IMAGE_NAME: "$DOCKER_REGION/$DOCKER_NAMESPACE/$APP_NAME:$CI_COMMIT_REF_NAME-$CI_COMMIT_SHORT_SHA" DOCKER_FILE_PATH: "./Dockerfile" APP_DOMAIN: "xkcoding.com" CONTAINER_PORT: 80stages: - 下载依赖 - 编译构建 - 打包镜像 - 部署服务 - 服务下线cache: key: $&#123;CI_COMMIT_REF_SLUG&#125; paths: - public/ - node_modules/下载依赖: stage: 下载依赖 image: $&#123;BUILD_IMAGE&#125; tags: - docker script: - ls -a - npm install - ls -a rules: - changes: - package.json编译构建: stage: 编译构建 image: $&#123;BUILD_IMAGE&#125; tags: - docker script: - ls -a - echo "开始打包Hexo博客" - hexo clean &amp;&amp; hexo g - echo "开始压缩Hexo博客" - gulp - ls -a public/打包镜像: stage: 打包镜像 image: docker:latest services: - name: docker:dind tags: - docker script: - ls -a - docker login -u $&#123;DOCKER_USERNAME&#125; -p $&#123;DOCKER_PASSWORD&#125; $&#123;DOCKER_REGION&#125; - docker build -t $&#123;IMAGE_NAME&#125; -f $&#123;DOCKER_FILE_PATH&#125; . - docker push $&#123;IMAGE_NAME&#125; - docker rmi $&#123;IMAGE_NAME&#125;部署服务: stage: 部署服务 tags: - deploy script: - ls -a - sed -i "s#__IMAGE_NAME__#$&#123;IMAGE_NAME&#125;#g" $&#123;APP_NAME&#125;.yml - sed -i "s#__APP_NAME__#$&#123;APP_NAME&#125;#g" $&#123;APP_NAME&#125;.yml - sed -i "s#__APP_DOMAIN__#$&#123;APP_DOMAIN&#125;#g" $&#123;APP_NAME&#125;.yml - sed -i "s#__CONTAINER_PORT__#$&#123;CONTAINER_PORT&#125;#g" $&#123;APP_NAME&#125;.yml - cat $&#123;APP_NAME&#125;.yml - docker login -u $&#123;DOCKER_USERNAME&#125; -p $&#123;DOCKER_PASSWORD&#125; $&#123;DOCKER_REGION&#125; - docker stack deploy -c $&#123;APP_NAME&#125;.yml $&#123;APP_NAME&#125; cache: policy: pull服务下线: stage: 服务下线 tags: - deploy script: - ls -a - sed -i "s#__IMAGE_NAME__#$&#123;IMAGE_NAME&#125;#g" $&#123;APP_NAME&#125;.yml - sed -i "s#__APP_NAME__#$&#123;APP_NAME&#125;#g" $&#123;APP_NAME&#125;.yml - sed -i "s#__APP_DOMAIN__#$&#123;APP_DOMAIN&#125;#g" $&#123;APP_NAME&#125;.yml - sed -i "s#__CONTAINER_PORT__#$&#123;CONTAINER_PORT&#125;#g" $&#123;APP_NAME&#125;.yml - cat $&#123;APP_NAME&#125;.yml - docker login -u $&#123;DOCKER_USERNAME&#125; -p $&#123;DOCKER_PASSWORD&#125; $&#123;DOCKER_REGION&#125; - docker stack rm $&#123;APP_NAME&#125; when: manual cache: policy: pull ② Dockerfile 12345FROM nginx:1.18.0LABEL maintainer="xkcoding &lt;237497819@qq.com&gt;"COPY public/ /usr/share/nginx/htmlCOPY default.conf /etc/nginx/conf.d/default.conf ③ myblog.yml 该文件是 Docker Stack 的部署文件 源码地址：https://github.com/xkcoding/MyBlog/blob/master/myblog.yml 12345678910111213141516171819202122232425262728293031323334353637version: "3.8"services: nginx: image: __IMAGE_NAME__ networks: - traefik deploy: mode: replicated # 2个副本 replicas: 2 # 更新策略 update_config: # 同时只能更新一个节点 parallelism: 1 delay: 10s order: stop-first placement: # 每个节点最多副本数量为 1 max_replicas_per_node: 1 constraints: - "node.labels.deploy==common" labels: - "traefik.enable=true" - "traefik.docker.network=traefik" - "traefik.http.routers.__APP_NAME__0.middlewares=https-redirect@file" - "traefik.http.routers.__APP_NAME__0.entrypoints=http" - "traefik.http.routers.__APP_NAME__0.rule=Host(`__APP_DOMAIN__`)" - "traefik.http.routers.__APP_NAME__1.middlewares=content-compress@file" - "traefik.http.routers.__APP_NAME__1.entrypoints=https" - "traefik.http.routers.__APP_NAME__1.tls=true" - "traefik.http.routers.__APP_NAME__1.rule=Host(`__APP_DOMAIN__`)" - "traefik.http.services.__APP_NAME__backend.loadbalancer.server.scheme=http" - "traefik.http.services.__APP_NAME__backend.loadbalancer.server.port=__CONTAINER_PORT__"networks: traefik: external: true ④ 相关截图 4. 后记 到这里，我博客算是走上了一个我觉得还行的 CICD 道路，至少目前我只需要关心文章内容即可，其他的交给机器去做吧。 折腾之旅到这儿就结束了，我想应该不会，未来也会去尝试性能更好的 hugo，如果我找到一个我喜欢的主题的话。 总的来说，折腾才是技术人永恒不变的乐趣。]]></content>
      <categories>
        <category>技术相关</category>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现一个你自己的 RPC 框架（3）]]></title>
    <url>%2F2020%2F05%2F26%2Fhow-to-design-your-own-rpc-framework-3.html</url>
    <content type="text"><![CDATA[前言 在前面的文章《如何实现一个你自己的 RPC 框架（1）》中，我们通过 BIO 去实现了一个简单的 RPC 通信案例，同时在《如何实现一个你自己的 RPC 框架（2）》中我们将 BIO 改造成了 NIO，今天我们将会基于第一次 BIO 的案例进行改造，将 BIO 改造为 AIO 通信。 1. 什么是 AIO 在《如何实现一个你自己的 RPC 框架（2）》中已经介绍了 BIO、NIO、AIO，不知道的小伙伴可以前往查看，在此不做赘述了。 2. 选型 本文将选用国产 AIO 框架 smart-socket 来实现 AIO 改造。 3. 实战 本次代码是基于《如何实现一个你自己的 RPC 框架（1）》进行重构的，因此模块划分保持一致，可以在上一次的基础上进行修改。本文为了凸显区别，模块名均进行修改，由 bio 变更为 aio。 模块划分： 123456rpc-demo-3 ├── rpc-client-aio // 客户端 ├── rpc-common-aio // 通用模块，封装 RPC 请求参数 └── rpc-server-aio // 服务端 ├── rpc-server-aio-api //接口定义 └── rpc-server-aio-provider // 接口实现 3.1. 修改 common 模块 首先引入 smart-socket 依赖 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.smartboot.socket&lt;/groupId&gt; &lt;artifactId&gt;aio-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 然后在 common 模块中创建客户端和服务端都需要遵守的编解码协议 1234567891011121314151617181920212223242526public class RpcProtocol implements Protocol&lt;byte[]&gt; &#123; private static final int INTEGER_BYTES = Integer.SIZE / Byte.SIZE; /** * 对于从Socket流中获取到的数据采用当前Protocol的实现类协议进行解析。 * * @param readBuffer 待处理的读buffer * @param session 本次需要解码的session * @return 本次解码成功后封装的业务消息对象, 返回null则表示解码未完成 */ @Override public byte[] decode(ByteBuffer readBuffer, AioSession&lt;byte[]&gt; session) &#123; int remaining = readBuffer.remaining(); if (remaining &lt; INTEGER_BYTES) &#123; return null; &#125; int messageSize = readBuffer.getInt(readBuffer.position()); if (messageSize &gt; remaining) &#123; return null; &#125; byte[] data = new byte[messageSize - INTEGER_BYTES]; readBuffer.getInt(); readBuffer.get(data); return data; &#125;&#125; 3.2. 修改 rpc-server-aio-provider 模块 将之前的 RpcServer 中的 ServerSocket 改造为 AioQuickServer 12345678910111213141516public class RpcServer &#123; public void start(Object service, int port) &#123; RpcServerMessageProcessor messageProcessor = new RpcServerMessageProcessor(service); AioQuickServer&lt;byte[]&gt; server = new AioQuickServer&lt;&gt;(port, new RpcProtocol(), messageProcessor); try &#123; server.start(); System.out.println(service + " 服务发布在 " + port + " 端口"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 将原先的 RpcRequestHandler 重命名为 RpcServerMessageProcessor，同时实现 MessageProcessor 接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@AllArgsConstructorpublic class RpcServerMessageProcessor implements MessageProcessor&lt;byte[]&gt; &#123; private Object service; /** * 处理接收到的消息 * * @param session 通信会话 * @param msg 待处理的业务消息 */ @Override public void process(AioSession&lt;byte[]&gt; session, byte[] msg) &#123; ObjectInput objectInput = null; ObjectOutput objectOutput = null; try &#123; objectInput = new ObjectInputStream(new ByteArrayInputStream(msg)); RpcRequest rpcRequest = (RpcRequest) objectInput.readObject(); // 反射调用 Object invoke = invoke(rpcRequest); // 写回客户端 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); objectOutput = new ObjectOutputStream(byteArrayOutputStream); objectOutput.writeObject(invoke); byte[] data = byteArrayOutputStream.toByteArray(); session.writeBuffer().writeInt(data.length + 4); session.writeBuffer().write(data); session.writeBuffer().flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (objectInput != null) &#123; try &#123; objectInput.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (objectOutput != null) &#123; try &#123; objectOutput.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 状态机事件,当枚举事件发生时由框架触发该方法 * * @param session 本次触发状态机的AioSession对象 * @param stateMachineEnum 状态枚举 * @param throwable 异常对象，如果存在的话 * @see StateMachineEnum */ @Override public void stateEvent(AioSession&lt;byte[]&gt; session, StateMachineEnum stateMachineEnum, Throwable throwable) &#123; &#125; private Object invoke(RpcRequest rpcRequest) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; // 请求参数 Object[] params = rpcRequest.getParams(); // 请求参数类型 Class&lt;?&gt;[] paramTypes = new Class[params.length]; for (int i = 0; i &lt; params.length; i++) &#123; paramTypes[i] = params[i].getClass(); &#125; // 获取请求的类名 Class&lt;?&gt; clazz = Class.forName(rpcRequest.getClassName()); // 获取请求的方法名 Method method = clazz.getMethod(rpcRequest.getMethodName(), paramTypes); // 调用 Object result = method.invoke(service, params); return result; &#125;&#125; 此时服务端重构就完成了~ 3.3. 修改 rpc-client-aio 模块 原先的 RpcTransport 是通过 Socket 去连接 ServerSocket，这里改造为 AioQuickClient 12345678910111213141516171819202122232425262728293031323334353637383940@AllArgsConstructorpublic class RpcTransport &#123; private String host; private int port; public Object call(RpcRequest rpcRequest) &#123; // 通过 CompletableFuture 阻塞获取返回结果 CompletableFuture&lt;Object&gt; waitForResult = new CompletableFuture&lt;&gt;(); RpcClientMessageProcessor messageProcessor = new RpcClientMessageProcessor(waitForResult); AioQuickClient&lt;byte[]&gt; consumer = new AioQuickClient&lt;&gt;(host, port, new RpcProtocol(), messageProcessor); try &#123; consumer.start(); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutput objectOutput = new ObjectOutputStream(byteArrayOutputStream); objectOutput.writeObject(rpcRequest); byte[] data = byteArrayOutputStream.toByteArray(); messageProcessor.getAioSession().writeBuffer().writeInt(data.length + 4); messageProcessor.getAioSession().writeBuffer().write(data); messageProcessor.getAioSession().writeBuffer().flush(); // 阻塞 3s 获取返回结果 return waitForResult.get(3, TimeUnit.SECONDS); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; finally &#123; consumer.shutdown(); &#125; return null; &#125;&#125; 创建 RpcClientMessageProcessor 实现 SimpleChannelInboundHandler 接口，获取服务端返回值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Getterpublic class RpcClientMessageProcessor implements MessageProcessor&lt;byte[]&gt; &#123; private AioSession&lt;byte[]&gt; aioSession; private CompletableFuture&lt;Object&gt; waitForResult; public RpcClientMessageProcessor(CompletableFuture&lt;Object&gt; waitForResult) &#123; this.waitForResult = waitForResult; &#125; /** * 处理接收到的消息 * * @param session 通信会话 * @param msg 待处理的业务消息 */ @Override public void process(AioSession&lt;byte[]&gt; session, byte[] msg) &#123; ObjectInput objectInput = null; try &#123; objectInput = new ObjectInputStream(new ByteArrayInputStream(msg)); // 获取到结果，并通知主线程获取结果 waitForResult.complete(objectInput.readObject()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (objectInput != null) &#123; try &#123; objectInput.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 状态机事件,当枚举事件发生时由框架触发该方法 * * @param session 本次触发状态机的AioSession对象 * @param stateMachineEnum 状态枚举 * @param throwable 异常对象，如果存在的话 * @see StateMachineEnum */ @Override public void stateEvent(AioSession&lt;byte[]&gt; session, StateMachineEnum stateMachineEnum, Throwable throwable) &#123; switch (stateMachineEnum) &#123; case NEW_SESSION: this.aioSession = session; break; &#125; &#125;&#125; 此时客户端也修改完毕~ 3.5. 测试 可以和之前保持一致，这里为了看出区别，我将请求参数由 rpc simple demo 改为 rpc aio demo 先运行 ServerMain 类，查看控制台日志。 123456// smart socket 的 banner，省略了。。。 :: smart-socket :: (v1.4.11)smart-socket server started on port 8080,threadNum:16smart-socket server config is IoServerConfig&#123;readBufferSize=512, writeQueueCapacity=16, host='null', monitor=null, port=8080, processor=com.xkcoding.rpc.nio.RpcServerMessageProcessor@f34cad02, protocol=com.xkcoding.rpc.nio.RpcProtocol@6c14ef0a, bannerEnabled=true, socketOptions=null, threadNum=16, writeBufferSize=128&#125;com.xkcoding.rpc.nio.HelloServiceImpl@ecadb3cc 服务发布在 8080 端口request is coming: rpc aio demo 再运行 ClientMain 类，查看控制台日志。 12需要动态代理生成请求对象content = hello rpc aio demo 4. 总结 本文主要是将原先的 BIO 实现改造为 AIO 实现，主要是基于 smart-socket 重构网络通信部分。 因为 AIO 目前应用仍然不是十分广泛，因此后续 RPC 的改造会在 NIO 的基础上次进行优化。敬请期待~ 参考 smart-socket 使用手册：https://smartboot.gitee.io/book/smart-socket/ 示例代码 https://github.com/xkcoding/practice_demo/tree/master/rpc-demo-3]]></content>
      <categories>
        <category>技术相关</category>
        <category>rpc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现一个你自己的 RPC 框架（2）]]></title>
    <url>%2F2020%2F05%2F11%2Fhow-to-design-your-own-rpc-framework-2.html</url>
    <content type="text"><![CDATA[前言 在上一篇《如何实现一个你自己的 RPC 框架（1）》中，我们通过 BIO 去实现了一个简单的 RPC 通信案例，今天我们将会基于上次的案例进行改造，将通信由 BIO 改造为 NIO。 1. 什么是 NIO 说到 NIO，就需要一起聊聊它的俩兄弟，BIO 以及 AIO。 BIO：Blocking IO，同步阻塞 IO。简单的说就是服务端创建一个 ServerSocket，客户端通过 Socket 去连接 ServerSocket，服务端会通过 accept 去阻塞等待客户端的请求。BIO 存在一个十分明显的问题，就是每当存在一个客户端连接服务端时，服务端都会启动一个线程，专门的去服务这个客户端，这将导致如果出现大量的客户端连接时，服务端将会产生大量的线程开销，导致崩溃。（因此，在上一篇文章中，我们在服务端使用一个线程异步的去处理这些请求，尽量增大服务端每个线程可以处理的请求数，来达到略微优化的目的。） NIO：NonBlocking IO，同步非阻塞 IO。在 Java 1.4 中引入，NIO 是基于 Reactor 模型。NIO 中引入了 Selector、Channel、Buffer 等概念。Buffer（缓冲区）主要用来存、取数据，Channel（通道）一个 Channel 对应一个客户端，Selector（调度器）不断轮询 Channel，处理 Channel 发生的事件。在 NIO 模型中，只有当客户端发生一次请求时，才会创建一个线程，请求结束，线程销毁，相比于 BIO 模型一个线程一直阻塞等待一个客户端所有请求而言，减少了线程的开销。NIO 的核心是同步非阻塞，无论多少客户端都可以接入服务端，客户端接入并不会耗费一个线程，只会创建一个连接然后注册到 Selector 上去，一个 Selector 线程不断的轮询所有的 Socket 连接，发现有新的事件就触发通知，然后启动一个线程专门处理一个请求即可，处理完毕释放线程，但是这个处理的过程中，要先读取数据、处理数据、再返回数据，这是个同步的过程。 AIO：Asynchronous NonBlocking IO，异步非阻塞 IO。AIO 是基于 Proactor 模型的。在 NIO 模型中，工作线程从 Channel 中读写数据是同步的。但是在 AIO 中，每个连接请求会绑定一个 Buffer，然后通过操作系统异步去完成，等操作系统完成之后，会触发一个回调通知你完成了。 2. 选型 在 Java 1.4 就引入了 NIO，但是基于原生的 API 操作比较繁琐，因此本文不会使用原生 API 来重构之前的 RPC 案例。 Netty 是一款基于 NIO 开发的高性能网络通信框架，同时支持自定义通信协议。下图是 Netty 官网的一张 Netty 组件图。 本文将使用 Netty 去重构之前的 RPC 案例。 3. 实战 本次代码是基于《如何实现一个你自己的 RPC 框架（1）》进行重构的，因此模块划分保持一致，可以在上一次的基础上进行修改。本文为了凸显区别，模块名均进行修改，由 bio 变更为 nio。 模块划分： 123456rpc-demo-2 ├── rpc-client-nio // 客户端 ├── rpc-common-nio // 通用模块，封装 RPC 请求参数 └── rpc-server-nio // 服务端 ├── rpc-server-nio-api //接口定义 └── rpc-server-nio-provider // 接口实现 3.1. 修改 RpcServer 将之前的 ServerSocket 改造为 Netty 的 ServerBootstrap 123456789101112131415161718192021222324252627282930public class RpcServer &#123; public void start(Object service, int port) &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline() .addLast(new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null))) .addLast(new ObjectEncoder()) // 自定义处理器 .addLast(new RpcRequestServerHandler(service)); &#125; &#125;); try &#123; serverBootstrap.bind(port).sync(); System.out.println(service + " 服务发布在 " + port + " 端口"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3.2. 修改 RpcRequestHandler 将原先的 RpcRequestHandler 重命名为 RpcRequestServerHandler，同时实现 SimpleChannelInboundHandler 接口 12345678910111213141516171819202122232425262728293031323334@AllArgsConstructorpublic class RpcRequestServerHandler extends SimpleChannelInboundHandler&lt;RpcRequest&gt; &#123; private Object service; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, RpcRequest rpcRequest) throws Exception &#123; // 反射调用 Object invoke = invoke(rpcRequest); channelHandlerContext.writeAndFlush(invoke).addListener(ChannelFutureListener.CLOSE); &#125; private Object invoke(RpcRequest rpcRequest) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; // 请求参数 Object[] params = rpcRequest.getParams(); // 请求参数类型 Class&lt;?&gt;[] paramTypes = new Class[params.length]; for (int i = 0; i &lt; params.length; i++) &#123; paramTypes[i] = params[i].getClass(); &#125; // 获取请求的类名 Class&lt;?&gt; clazz = Class.forName(rpcRequest.getClassName()); // 获取请求的方法名 Method method = clazz.getMethod(rpcRequest.getMethodName(), paramTypes); // 调用 Object result = method.invoke(service, params); return result; &#125;&#125; 此时服务端重构就完成了~ 3.3. 修改 RpcTransport 原先的 RpcTransport 是通过 Socket 去连接 ServerSocket，这里改造为 Netty 的 Bootstrap 形式 1234567891011121314151617181920212223242526272829303132333435363738394041@AllArgsConstructorpublic class RpcTransport &#123; private String host; private int port; public Object call(RpcRequest rpcRequest) &#123; Bootstrap bootstrap = new Bootstrap(); EventLoopGroup eventGroup = new NioEventLoopGroup(); RpcRequestClientHandler rpcRequestClientHandler = new RpcRequestClientHandler(); bootstrap.group(eventGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline() .addLast(new ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(null))) .addLast(new ObjectEncoder()) // 添加自定义处理器 .addLast(rpcRequestClientHandler); &#125; &#125;).option(ChannelOption.TCP_NODELAY, true); try &#123; ChannelFuture channelFuture = bootstrap.connect(host, port).sync(); // 发送 RPC 请求参数 channelFuture.channel().writeAndFlush(rpcRequest).sync(); // 等待连接关闭 channelFuture.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; eventGroup.shutdownGracefully(); &#125; return rpcRequestClientHandler.getResult(); &#125;&#125; 3.4. 创建 RpcRequestClientHandler 实现 SimpleChannelInboundHandler 接口，获取服务端返回值 1234567891011121314151617@Getterpublic class RpcRequestClientHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private Object result; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception &#123; this.result = msg; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println("调用出现异常：" + cause); ctx.close(); &#125;&#125; 此时客户端也修改完毕~ 3.5. 测试 可以和之前保持一致，这里为了看出区别，我将请求参数由 rpc simple demo 改为 rpc nio demo 先运行 ServerMain 类，查看控制台日志。 12com.xkcoding.rpc.nio.HelloServiceImpl@5ab35abe 服务发布在 8080 端口request is coming: rpc nio demo 再运行 ClientMain 类，查看控制台日志。 12需要动态代理生成请求对象content = hello rpc nio demo 4. 总结 本文主要是将原先的 BIO 实现改造为 NIO 实现，主要是基于 Netty 重构网络通信部分。 但是 Netty 的精髓远不止于此，本文只是粗浅的使用 Hello World 而已。 示例代码 https://github.com/xkcoding/practice_demo/tree/master/rpc-demo-2]]></content>
      <categories>
        <category>技术相关</category>
        <category>rpc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现一个你自己的 RPC 框架（1）]]></title>
    <url>%2F2020%2F04%2F20%2Fhow-to-design-your-own-rpc-framework-1.html</url>
    <content type="text"><![CDATA[前言 RPC，全称：Remote Procedure Call，翻译过来就是：远程过程调用。主要用来在分布式系统中，解决不同系统间的服务调用问题。RPC 不仅要让实现服务间的通信，还有一点就是要让用户在远程调用的过程中像是在本地调用一样方便。如何实现一个简易的 RPC 通信呢？这个系列的文章将会一一解答。 1. 设计 首先我们看看本地调用的流程，本地调用，我们相当于是直接通过 new 的方式去创建一个对象，然后调用对象的方法去获取数据。 如果是分布式系统，服务调用方和服务提供方，分布在不同的服务上，此时调用关系就变成了这样子，我们将调用方和提供方分别用 client 和 server 代替。 既然是远程调用，必然涉及到 IO 通信、传输内容序列化 / 反序列化 等技术。 IO 通信分为 BIO、NIO、AIO 序列化又分为 JDK 自带的序列化机制、XML、JSON、二进制等等 XML Json：jackson、fastjson、Gson 二进制方式：hessian、avro、kyro、protobuf 各序列化方式性能比较：https://github.com/eishay/jvm-serializers/wiki 本文是 RPC 系列文章的第一篇，将会使用最简单的 BIO、jdk 自带的序列化机制，实现一个简易的 RPC。后续的文章，将会在这一篇的基础上对 RPC 进行优化升级改造。 2. 实战 模块结构： 123456rpc-demo-1 ├── rpc-client-bio // 客户端 ├── rpc-common-bio // 通用模块，封装 RPC 请求参数 └── rpc-server-bio // 服务端 ├── rpc-server-bio-api //接口定义 └── rpc-server-bio-provider // 接口实现 2.1. 定义 API 首先我们在 rpc-server-bio-api 模块下定义远程调用的接口。 123public interface IHelloService &#123; String sayHello(String content);&#125; 2.2. 实现 API 然后我们在 rpc-server-bio-provider 中引入 rpc-server-bio-api 这个模块，然后实现 IHelloService。 123456789public class HelloServiceImpl implements IHelloService &#123; @Override public String sayHello(String content) &#123; System.out.println("request is coming: " + content); return "hello " + content; &#125;&#125; 2.3. RpcServer 实现 RPC 服务提供方暴露服务，既然是提供方，肯定也是在 rpc-server-bio-provider 模块实现。 1234567891011121314151617181920212223public class RpcServer &#123; // 阿里 P3C 不建议直接调用 Executors，此处为了偷懒 private final ExecutorService executorService = Executors.newCachedThreadPool(); public void start(Object service, int port) &#123; try (ServerSocket serverSocket = new ServerSocket(port)) &#123; System.out.println(service + " 服务发布在 " + port + " 端口"); while (true) &#123; // 不断阻塞，等待请求 Socket socket = serverSocket.accept(); // 通过线程池异步处理，提升性能 executorService.execute(new RpcRequestHandler(socket, service)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 真正的处理逻辑是通过线程异步处理的，这样的做法是可以提升服务端性能。 处理逻辑交给 RpcRequestHandler 去实现。主要实现思路就是获取 socket 传过来的参数，通过反射调用本地对象的方法，拿到返回结果之后，再通过 socket 写会客户端即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@AllArgsConstructorpublic class RpcRequestHandler implements Runnable &#123; private Socket socket; private Object service; @Override public void run() &#123; ObjectInputStream ois = null; ObjectOutputStream oos = null; try &#123; ois = new ObjectInputStream(socket.getInputStream()); // 根据输入流拿到 RpcRequest RpcRequest rpcRequest = (RpcRequest) ois.readObject(); // 反射调用本地服务 Object result = invoke(rpcRequest); oos = new ObjectOutputStream(socket.getOutputStream()); // 通过输出流输出结果 oos.writeObject(result); oos.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) &#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (oos != null) &#123; try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private Object invoke(RpcRequest rpcRequest) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; // 请求参数 Object[] params = rpcRequest.getParams(); // 请求参数类型 Class&lt;?&gt;[] paramTypes = new Class[params.length]; for (int i = 0; i &lt; params.length; i++) &#123; paramTypes[i] = params[i].getClass(); &#125; // 获取请求的类名 Class&lt;?&gt; clazz = Class.forName(rpcRequest.getClassName()); // 获取请求的方法名 Method method = clazz.getMethod(rpcRequest.getMethodName(), paramTypes); // 调用 Object result = method.invoke(service, params); return result; &#125;&#125; 2.4. RpcRequest 上述代码中可以看到，我们调用一个 RPC，需要知道类名、方法名、请求参数这些信息，因此我封装了 RpcRequest 类去保存这些信息。这个对象在客户端和服务端都需要用到，因此，放在 rpc-common-bio 模块中。同时在 rpc-server-bio-provider 中引入 rpc-common-bio 模块。 12345678910@Datapublic class RpcRequest implements Serializable &#123; private String className; private String methodName; private Object[] params;&#125; 2.5. RpcClient 既然 RPC 是解决服务间的远程调用，那么客户端肯定也必须知道自己需要调用哪个内容，只是具体内容的实现交给服务端而已。因此，在 rpc-client-bio 模块中需要引入 rpc-server-bio-api 获取接口定义，同时也需要引入 rpc-common-bio 用来封装 RPC 请求。 Java 中接口是不可以实例化的，但是我们想要让用户对 RPC 的过程无感知，那么调用的方式最好和本地调用一样，可以通过 Object.method 的形式获取结果。此时动态代理，就成了最佳的解决方案。 12345678910111213141516public class RpcClient &#123; /** * 动态代理 * @param interfaceClass 接口类 * @param host IP * @param port 端口 * @param &lt;T&gt; 代理对象类型 * @return 代理对象 */ public &lt;T&gt; T proxy(Class&lt;T&gt; interfaceClass, String host, int port) &#123; return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class[] &#123; interfaceClass &#125;, new RemoteInvocationHandler(host, port)); &#125;&#125; 2.6. RemoteInvocationHandler JDK 提供了 Proxy.newProxyInstance 的方法可以动态代理对象，具体的执行逻辑放在 RemoteInvocationHandler 中，RemoteInvocationHandler 是实现 InvocationHandler 接口，具体执行的时候，会走到该类的 invoke 方法，所以我们只需要在 invoke 方法里进行远程调用即可。 1234567891011121314151617181920212223@AllArgsConstructorpublic class RemoteInvocationHandler implements InvocationHandler &#123; private String host; private int port; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("需要动态代理生成请求对象"); // 构建 RpcRequest RpcRequest rpcRequest = new RpcRequest(); rpcRequest.setClassName(method.getDeclaringClass().getName()); rpcRequest.setMethodName(method.getName()); rpcRequest.setParams(args); // 远程调用 RpcTransport rpcTransport = new RpcTransport(host, port); Object result = rpcTransport.call(rpcRequest); return result; &#125;&#125; 2.7. RpcTransport 远程调用，这里我也做了一层封装，远程调用的过程通过 RpcTransport 去执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@AllArgsConstructorpublic class RpcTransport &#123; private String host; private int port; public Object call(RpcRequest rpcRequest) &#123; Object result = null; ObjectInputStream ois = null; ObjectOutputStream oos = null; try (Socket socket = new Socket(host, port);) &#123; oos = new ObjectOutputStream(socket.getOutputStream()); // 序列化 oos.writeObject(rpcRequest); oos.flush(); ois = new ObjectInputStream(socket.getInputStream()); // 获取服务端返回结果 result = ois.readObject(); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) &#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (oos != null) &#123; try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return result; &#125;&#125; 2.8. 测试类 服务端测试 12345678910public class ServerMain &#123; public static void main(String[] args) &#123; IHelloService helloService = new HelloServiceImpl(); RpcServer rpcServer = new RpcServer(); rpcServer.start(helloService, 8080); &#125;&#125; 客服端测试 12345678910public class ClientMain &#123; public static void main(String[] args) &#123; RpcClient rpcClient = new RpcClient(); IHelloService helloService = rpcClient.proxy(IHelloService.class, "0.0.0.0", 8080); String content = helloService.sayHello("rpc simple demo"); System.out.println("content = " + content); &#125;&#125; 2.9. 测试结果 先运行 ServerMain 类，查看控制台日志。 12com.xkcoding.rpc.HelloServiceImpl@7b019026 服务发布在 8080 端口request is coming: rpc simple demo 再运行 ClientMain 类，查看控制台日志。 12需要动态代理生成请求对象content = hello rpc simple demo 3. 总结 其实 RPC 的实现过程中，有三个技术点至关重要： 网络通信 序列化和反序列化 动态代理（PS：动态代理不熟悉的同学，可以 前往这里学习） 示例代码 https://github.com/xkcoding/practice_demo/tree/master/rpc-demo-1]]></content>
      <categories>
        <category>技术相关</category>
        <category>rpc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020.Q1总结 & 离职感想]]></title>
    <url>%2F2020%2F04%2F01%2Fsomewords-about-dissmission-2020.html</url>
    <content type="text"><![CDATA[这里先祝大家愚人节快乐。 看了眼上次博客更新的时间，也已经过去了一个季度，真是将“拖字诀”发挥的淋漓尽致。今天聊聊我对这个季度的总结以及自己的一些离职感想。 2020 注定是个不平凡的一年！ 1. Q1 总结 转眼间，2020 已经过去 1/4，说实话，这个季度我感觉自己是虚度的。 感情 原计划于今年带爸妈去襄阳与妞的爸妈聊聊婚礼的事情，因为疫情的原因，还不知道什么时候执行，与之直接存在影响的应该就是今年的结婚计划。 我和妞夫人已经携手走过了 6 年时光，等待是为了更好的前行。 工作 我已于 2020.03.19 正式离开美创，告别了2 年朝夕相处的领导及同事，感谢领导们的培养与信任，也感谢同事们的包容与照顾。 在美创的这段时间里，我学到了很多，尤其是团队管理方面的知识，第一次带团队，感谢 Team 小伙伴的信任。这 2 年时间，我向团队输出了一些内容，包括开发规范、微服务架构、容器化部署、基础依赖架构等，对我来说也是一种成长。 美创是一家不错的公司，当你展现出足够的实力的时候，美创的领导们愿意花时间培养你、给你匹配的资源。 至于我为什么要离职？ 马云爸爸曾经说过，离职无非 2 个原因，①钱给少了 ②心委屈了 我离职的原因挺多，总结下来就是都占了： 我喜欢做技术，我想在技术的层面更进一步，我尝试做了一些推广，但是“内部原因”让我有些有心无力。 这 2 年时间，我越来越多的时间耗在了会议上，让我开始恐慌。需求不明确的需求会议、尝尝甩锅分锅的实施问题反馈会议、主题跑偏的技术方案制定会议……这些会议，没 2-3 个小时根本结束不了，就算结束了也得不到有效答案与反馈。 领导们眼中好的产品，基于市面上开源的产品进行二次开发的产品就是好产品🤔，时间就是金钱，人多力量大，加一倍的人手，时间就必须得减半🤔 直系领导的“权利斗争”。 2 年时间，我是 4 个产品的后端研发负责人。一款好的产品，应当包含完整且实际的需求预研、稳定且高效的研发团队、优秀且直观的交互设计、简单的部署体验、省心的运维、牛批的销售。手里的 4 个产品，我认为没有一项达标，需求不明确、代码不优雅、懵逼的交互、复杂的部署。 我做过的努力： 需求不明确，我们组织会议询问需求 代码不优雅，前期我们 2 周一次的 Code Review，后期团队成员固定，减少到 1 月一次 懵逼的交互，我们站在用户的角度给产品经理理清使用流程，查找各种 UI 组件，帮忙寻找解决方案，对了，我们是后端程序猿🤓 复杂的部署，既然都服务化了，为什么我们提了 Docker 容器化部署方案，最后却被否定了？ …… 当你的努力得不到符合你付出的回报的时候，人就会很累，所以我选择离职休息一段时间，最后祝美创越来越好！ 2. Q2 计划 找到一份满意的工作（4 - 5 月） 完成并发布“简·记”初版 个人云平台迁移，大米云 → 京东云，尝试 k3s，输出相关博文（6 月前） 至于我什么时候开始下一份工作？ 查看我的完整简历，希望可以与您共事！]]></content>
      <categories>
        <category>总结展望</category>
      </categories>
      <tags>
        <tag>总结展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又是一年总结时]]></title>
    <url>%2F2019%2F12%2F31%2Fbye2019-hello2020.html</url>
    <content type="text"><![CDATA[We are all in the gutter,but some of us are looking at the stars. 2019 年转眼就过去了，迎来了新一轮的 decade。十年匆匆而过，我想借这次机会，好好的总结下这十年。 忆往昔 杂记 2010 年，我经历了中考，2013 年，我经历了高考，2 场决定命运起点的考试。 10 年的中考，吊车尾的挤上了「仙中」，一年不懈的努力，终于挤进了「五班」。 高中，最不愿意回忆的一个片段，一手好牌，被自己玩的稀烂。 13 年的高考，班里少数的几个二本，真是个难忘的夏天。五十多个人的实验班，10 个以下的二本，其余全是一本。「作死」这个词可以十分完美的形容高中的自己。在合适的时间做合适的事情，是我多年后的总结。学习如此，游戏如此，恋爱也是如此。 接下来就是我的大学，在「湖北文理学院」的日子了。可能是突然长大了，也可能是高考对自己的影响太大了，自尊心不断驱使着自己去学习。截止到我大三去北京工作之前，成绩始终在本专业前三，获得过「校二级奖学金」，也获得过「国家励志奖学金」。除了校级竞赛，也参加了「软件杯」本科组优秀奖、「蓝桥杯」湖北赛区三等奖、「全国物联网大赛」二等奖，还申请了「农产品供应链」的软著。 正是凭借自己的努力，在大三的时候，我获得了班主任及院辅导员的批准，允许我离校找工作。（这里需要说明一下，我大学学的是「物联网工程」专业，同时我们这一届是第一届这个专业的学生，所以当时专业课已经在大二全部结束，所以我大三可以申请离校找工作，学校的时光异常珍贵，希望学弟学妹们好好珍惜！）2016 年 7 月 28 号，我将自己的第一站选择了「北京」，也正是因为自己的自信和能力，以及「大卫哥」的信任，我在 2016 年 8 月 2 号正式入职（不是实习哦）我的第一家公司 ——「图迹科技」。我的工作生涯，也从此开始。在图迹的一年半时间，我遇到了好领导、好同事，感谢他们对我初入职场的照顾与包容，感恩🙏 我的 2019 接下来讲讲我的 2019 年吧： 工作 今年职能转变，Team 总共 4 个人啦。人数不多，一年里却也承担了 3 个产品的研发工作。 第一次带团队，工作安排会有些不合理，会出现延期的情况。总结：工作量评估不能以自己的标准评估，需要因人而异。 既然是带领团队，团队与团队之间的协作，就得好好沟通。总结：我已经被工作磨平了棱角。 团队建设，一个团队，需要有一个团队的标签。总结：认真负责、技术优秀、代码规范，这三个词是我对我们团队打的标签。 技术 今年一个产品由单体架构转向微服务架构，我几乎一人对其拆分、重构，初期还是 Spring Cloud Netflix 系列，后期全线切到 Spring Cloud Alibaba 系列。其中坑点无数，不过自己的进步也是极其明显。 简单列下遇到的一些坑，不知道小伙伴们有没有遇到这些问题呢： Spring Boot 1.x 升级 Spring Boot 2.x (需要参考文档，修改部分配置) Eureka 自我保护机制，开发环境导致服务调用失败 (开发过程中将其关闭) 多个 FeignClient 导致出现多个 Bean 无法启动项目(通过配置 contextId 解决) Eureka 升级到 Nacos，对 Nacos 的前端页面进行二开 二开 xxl-job-admin，使其支持 SimpleJob，同时注册到 Nacos 自定义 xxl-job-starter，自动连接 xxl-job-admin … 健康 今年身体不错，总的来说比较抗造了，不过肠胃确实是硬伤。 开源 今年算是做到了去年立的一个 Flag，就是尽量保证每天都可以在 GitHub 上写点东西。 贴一张打卡图： 这里要说明一下 4.13 - 4.17 这五天，作为公司的优秀员工，前往桂林旅游去了 5.11 - 5.12 这两天有点压抑，去千岛湖散心去了 6.6 - 6.11 这六天，我和发小，2 对家庭在泰国，萨瓦迪卡🇹🇭 10.1 - 10.7 这一周，大学的朋友来杭州相聚，必须好吃好喝招待！ 在介绍一下今年做的一些开源贡献吧： spring-boot-demo spring-boot-demo 是一个用来深度学习并实战 spring boot 的项目，目前总共包含 63 个集成 demo，已经完成 52 个。 这个项目说实话，今年是它最辉煌的岁月，获得 GitHub 热门 Java 榜单 8 月份第一名、9 月份第八名、12 月份第三名的成绩。唯一遗憾的是，今年仍然没有给它完结掉。但好在，今年不是我一个人在战斗了，有不少热心的小伙伴提了很多有用的意见、也共享了一些 demo 的代码，真心感谢你们！下面晒一波战绩！ JustAuth JustAuth是 💯 史上最全的整合第三方登录的开源库。 这个项目是我第一次以主要贡献者的身份参与进来的项目，主要做了以下的贡献： 集成微信登录(包括公众号和开放平台)、QQ登录、Google登录、微软登录、小米登录、企业微信登录 优化代码、架构，增加自定义 State 缓存功能 提供 jFinal 版 demo 提供 ActFramework 版 demo 提供 SpringBoot 快速集成的 justauth-spring-boot-starter 抽取 HTTP 模块，使其与 hutool-http 解耦，支持任意 Http Client 接入 通过参与这个项目，让我意识到，工具类型的开源项目设计一个易用的 API 的重要性以及代码封装通用性的好处。 magic-starter magic-starter 一套神奇的starter，只为爱“偷懒”的你~ 这个项目的目的是对项目开发中常见的功能的封装，做一套 starter，方便 Spring Boot 项目快速引用集成。主要包括： 自动装配组件模块：magic-core-auto 核心工具包模块：magic-core-tool 依赖版本控制模块：magic-starter-bom 极简的权限控制模块：magic-starter-secure 通用操作日志封装模块：magic-starter-log 通用消息通知封装模块：magic-starter-message 限流组件模块：magic-starter-ratelimiter 分布式锁模块：magic-starter-locker 通用对象存储封装模块：magic-starter-oss 分布式主键生成器模块：magic-starter-id 这套组件暂时还未正式 Release，都还是快照版本。每个模块都配有对应的文档及 demo，小伙伴们敬请期待吧 design-pattern 这个项目是设计模式学习配套代码，对应博文在这里👉 其他 今年也参与了一些其他开源项目的建设： nacos: 提交了 3 个 BUG ISSUE，1 个 PR mica: 提交了 2 个 PR hutool: 提交了 1 个 PR 总结：坦白说我对于社区的贡献不值一提，开源于我而言，更像是一种帮助他人提升自己的一个过程，我很开心，也很享受。看着 spring-boot-demo 可以为很多刚刚入门的朋友们提供帮助，看着自己参与的 JustAuth 能被好多的人夸好用，我觉得一切都很值得。社区让我遇到很多朋友，@春哥、@亚东、@翼神，他们对我的帮助都非常大，感谢你们！ 其他 6.22喜提阿特兹一枚~ 看今朝 跨入新的 10 年，迎接新的自己！ 我的 2020 学习 学习 Flink 学习非阻塞编程，了解 WebFlux 技术 学习一些团队管理的知识 开源 继续维护 JustAuth 一定要把 spring-boot-demo 完结了 发布 Magic-Starter Release 版本 写个微信小程序 完成我的赞(乞)赏(讨)系统 写一个后端管理脚手架同时配套前端代码 情感 是时候去完成人生大事了！ 工作 恩，世界那么大，我想去大厂看看！ 后记 本来这篇总结是想在元旦的时候写的，这一年经历的挺多，却愣是憋不出来。拖来拖去，拖到今晚(2020.01.17)，小年夜，终于是给写完了，也算是对自己的 2019 年有了一个交代，2020 年加油！ 附上帅照一张：]]></content>
      <categories>
        <category>总结展望</category>
      </categories>
      <tags>
        <tag>总结展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单 HTTP 工具]]></title>
    <url>%2F2019%2F12%2F26%2Fxkcoding-simple-http.html</url>
    <content type="text"><![CDATA[1. 前言 因为本人是 JustAuth 的主要贡献者之一，JustAuth 里需要和各大平台做 HTTP 交互来换取 Token、用户信息等数据，使用的是 hutool-http来实现 HTTP 请求的发送。前段时间，有朋友提出一个需求：能否使用 OkHttp3 等更优秀的 HTTP 请求工具来替换默认的 hutool-http ？于是写一个 simple-http 的想法就诞生了。 2. 设计思路 2.1. 解耦 simple-http 设计出来就是为了解决 JustAuth 中对 hutool-http 的强耦合，所以需要先找到 JustAuth 中到底使用到了需要哪些 HTTP 请求，找到它们的共性，才能解耦。具体参见下表： 请求类型 请求参数类型 响应数据类型 其他 GET query JSON、TEXT Header、URL Encode POST Form、JSON JSON、TEXT Header、URL Encode 响应的数据类型，有些是格式化的 JSON 数据，有些只是简单的文本信息，但总的来说都是字符串数据，具体的解析，交给使用方去处理。所以，此时通用HTTP的接口就已经可以设计出来了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * &lt;p&gt; * HTTP 接口 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/24 18:21 */public interface Http &#123; /** * GET 请求 * * @param url URL * @return 结果 */ String get(String url); /** * GET 请求 * * @param url URL * @param params 参数 * @param encode 是否需要 url encode * @return 结果 */ String get(String url, Map&lt;String, String&gt; params, boolean encode); /** * GET 请求 * * @param url URL * @param params 参数 * @param header 请求头 * @param encode 是否需要 url encode * @return 结果 */ String get(String url, Map&lt;String, String&gt; params, HttpHeader header, boolean encode); /** * POST 请求 * * @param url URL * @return 结果 */ String post(String url); /** * POST 请求 * * @param url URL * @param data JSON 参数 * @return 结果 */ String post(String url, String data); /** * POST 请求 * * @param url URL * @param data JSON 参数 * @param header 请求头 * @return 结果 */ String post(String url, String data, HttpHeader header); /** * POST 请求 * * @param url URL * @param params form 参数 * @param encode 是否需要 url encode * @return 结果 */ String post(String url, Map&lt;String, String&gt; params, boolean encode); /** * POST 请求 * * @param url URL * @param params form 参数 * @param header 请求头 * @param encode 是否需要 url encode * @return 结果 */ String post(String url, Map&lt;String, String&gt; params, HttpHeader header, boolean encode);&#125; 2.2. 雏形 既然通用接口已经设计出来了，下一步就是需要选择具体发送 HTTP 的工具包。这一步有 2 个要求，既需要根据常见的 HTTP 工具依赖来自动决定，也需要提供用户自定义的配置的便捷性。 根据引入的依赖判断使用哪一个 HTTP 工具，可以使用 Class.forName() 来判断 用户自定义，简单的说就是提供 set 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/** * &lt;p&gt; * 请求工具类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/24 18:15 */@UtilityClasspublic class HttpUtil &#123; private static Http proxy; static &#123; Http defaultProxy = null; ClassLoader classLoader = HttpUtil.class.getClassLoader(); // 基于 java 11 HttpClient if (ClassUtil.isPresent("java.net.http.HttpClient", classLoader)) &#123; defaultProxy = new com.xkcoding.http.support.java11.HttpClientImpl(); &#125; // 基于 okhttp3 else if (ClassUtil.isPresent("okhttp3.OkHttpClient", classLoader)) &#123; defaultProxy = new OkHttp3Impl(); &#125; // 基于 httpclient else if (ClassUtil.isPresent("org.apache.http.impl.client.HttpClients", classLoader)) &#123; defaultProxy = new HttpClientImpl(); &#125; // 基于 hutool else if (ClassUtil.isPresent("cn.hutool.http.HttpRequest", classLoader)) &#123; defaultProxy = new HutoolImpl(); &#125; proxy = defaultProxy; &#125; public void setHttp(Http http) &#123; proxy = http; &#125; private void checkHttpNotNull(Http proxy) &#123; if (null == proxy) &#123; throw new SimpleHttpException("HTTP 实现类未指定！"); &#125; &#125; /** * GET 请求 * * @param url URL * @return 结果 */ public String get(String url) &#123; checkHttpNotNull(proxy); return proxy.get(url); &#125; /** * GET 请求 * * @param url URL * @param params 参数 * @param encode 是否需要 url encode * @return 结果 */ public String get(String url, Map&lt;String, String&gt; params, boolean encode) &#123; checkHttpNotNull(proxy); return proxy.get(url, params, encode); &#125; /** * GET 请求 * * @param url URL * @param params 参数 * @param header 请求头 * @param encode 是否需要 url encode * @return 结果 */ public String get(String url, Map&lt;String, String&gt; params, HttpHeader header, boolean encode) &#123; checkHttpNotNull(proxy); return proxy.get(url, params, header, encode); &#125; /** * POST 请求 * * @param url URL * @return 结果 */ public String post(String url) &#123; checkHttpNotNull(proxy); return proxy.post(url); &#125; /** * POST 请求 * * @param url URL * @param data JSON 参数 * @return 结果 */ public String post(String url, String data) &#123; checkHttpNotNull(proxy); return proxy.post(url, data); &#125; /** * POST 请求 * * @param url URL * @param data JSON 参数 * @param header 请求头 * @return 结果 */ public String post(String url, String data, HttpHeader header) &#123; checkHttpNotNull(proxy); return proxy.post(url, data, header); &#125; /** * POST 请求 * * @param url URL * @param params form 参数 * @param encode 是否需要 url encode * @return 结果 */ public String post(String url, Map&lt;String, String&gt; params, boolean encode) &#123; checkHttpNotNull(proxy); return proxy.post(url, params, encode); &#125; /** * POST 请求 * * @param url URL * @param params form 参数 * @param header 请求头 * @param encode 是否需要 url encode * @return 结果 */ public String post(String url, Map&lt;String, String&gt; params, HttpHeader header, boolean encode) &#123; checkHttpNotNull(proxy); return proxy.post(url, params, header, encode); &#125;&#125; 2.3. 实现 如果看了前面的设计模式系列文章的话，应该知道上面其实可以用到 3 种设计模式：代理模式、委派模式、策略模式，没看出来的小伙伴，可以去学习学习哦~ 设计模式传送门👉 simple-http 提供了 4 种默认实现，分别是 JDK11 的 HttpClient、OkHttp3、Apache 的 HttpClient、hutool-http，如果项目中同时存在这几个 HTTP 工具的依赖，那么 simple-http 会根据优先级顺序从左往右，自行选择具体执行 HTTP 请求的工具。源码比较多，就不贴在博客里了，关于这 4 种默认实现的详细代码，请自行前往 GitHub 阅读源码实现，源码传送门👉。 3. 使用方式 引入 simple-http 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding.http&lt;/groupId&gt; &lt;artifactId&gt;simple-http&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 再引用具体实现 JDK11 的 HttpClient（使用 JDK11 即可） OkHttp3 12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;$&#123;okhttp3.version&#125;&lt;/version&gt;&lt;/dependency&gt; Apache HttpClient 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt;&lt;/dependency&gt; Hutool 的 HTTP 12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-http&lt;/artifactId&gt; &lt;version&gt;$&#123;hutool.version&#125;&lt;/version&gt;&lt;/dependency&gt; 如果不想使用默认的，可以自定实现 com.xkcoding.http.support.Http 接口，然后通过 com.xkcoding.http.HttpUtil#setHttp(Http http) 配置 然后就可以使用 HttpUtil.xxx 开心的耍起来了~ 4. 不足与改进 目前 simple-http 仅支持 GET、POST 方式，其余方式，未来有机会的话，会考虑扩展，目前对 JustAuth 来说，已经够用啦~ 目前返回值都是 String，后续要不要加一个自动解析返回类型的接口？如果响应是 JSON 内容的， 就默认返回 JSON，如果是 html 结构的，就默认返回 Document 等等。哎呀呀，再说吧，再说吧~ 5. 其他 simple-http 预计会在 JustAuth 的 1.4.x 版本正式上线，目前整合已完毕(2019.12.25)，已提交 PR，待小组成员仔细测试之后就会发布。届时欢迎小伙伴们尝试~ simple-http 的灵感来自 @春哥 的 jfinal-weixin 的 HttpUtils。 JDK 11 的 HttpClient 实现，本人菜的一逼，所以主要也是 @春哥 的贡献，膜拜就完事了~]]></content>
      <categories>
        <category>开源</category>
        <category>simple-http</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>JustAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之结构型设计模式-装饰者模式]]></title>
    <url>%2F2019%2F11%2F11%2Fdesign-pattern-decorator.html</url>
    <content type="text"><![CDATA[1. 模式简介 在不改变原有对象的基础之上，将新功能附加到原有对象上，提供了比继承更有弹性的解决方案（扩展原有对象的功能），属于结构型设计模式。 2. 示例代码 这回咱们就土豪一把，模拟购买 2019 款 MacBook Pro 16 寸，来演示装饰者模式的逻辑。 MacBook Pro 的基础信息 12345678910111213141516171819202122232425262728293031323334353637/** * &lt;p&gt; * 苹果笔记本 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/13 16:51 */public interface MacBookPro &#123; /** * 套餐名称 * * @return 套餐名称 */ String getComboName(); /** * 硬盘 * * @return 硬盘 */ String getHardDisk(); /** * 内存 * * @return 内存 */ String getMemory(); /** * 价格 * * @return 价格 */ Double getPrice();&#125; 定义我们的套餐装饰器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * &lt;p&gt; * 套餐 - 装饰器 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/13 17:08 */@AllArgsConstructorpublic abstract class ComboDecorator implements MacBookPro &#123; private MacBookPro macBookPro; /** * 套餐名称 * * @return 套餐名称 */ @Override public String getComboName() &#123; return this.macBookPro.getComboName(); &#125; /** * 硬盘 * * @return 硬盘 */ @Override public String getHardDisk() &#123; return this.macBookPro.getHardDisk(); &#125; /** * 内存 * * @return 内存 */ @Override public String getMemory() &#123; return this.macBookPro.getMemory(); &#125; /** * 价格 * * @return 价格 */ @Override public Double getPrice() &#123; return this.macBookPro.getPrice(); &#125;&#125; 基础套餐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * &lt;p&gt; * 苹果笔记本基础套餐 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/13 16:52 */public class BaseMacBookProCombo implements MacBookPro &#123; /** * 套餐名称 * * @return 套餐名称 */ @Override public String getComboName() &#123; return "基础套餐"; &#125; /** * 硬盘 * * @return 硬盘 */ @Override public String getHardDisk() &#123; return "1T 固态硬盘"; &#125; /** * 内存 * * @return 内存 */ @Override public String getMemory() &#123; return "16GB 2666MHz DDR4 内存"; &#125; /** * 价格 * * @return 价格 */ @Override public Double getPrice() &#123; return 22199d; &#125;&#125; 16G内存套餐 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * &lt;p&gt; * 内存套餐 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/13 17:17 */public class MemoryCombo extends ComboDecorator &#123; public MemoryCombo(MacBookPro macBookPro) &#123; super(macBookPro); &#125; /** * 套餐名称 * * @return 套餐名称 */ @Override public String getComboName() &#123; return super.getComboName() + " + 升级内存"; &#125; /** * 内存 * * @return 内存 */ @Override public String getMemory() &#123; return super.getMemory() + " + 16G 内存"; &#125; /** * 价格 * * @return 价格 */ @Override public Double getPrice() &#123; return super.getPrice() + 2936; &#125;&#125; 1T硬盘套餐 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * &lt;p&gt; * 硬盘套餐 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/13 17:15 */public class HardDiskCombo extends ComboDecorator &#123; public HardDiskCombo(MacBookPro macBookPro) &#123; super(macBookPro); &#125; /** * 套餐名称 * * @return 套餐名称 */ @Override public String getComboName() &#123; return super.getComboName() + " + 升级硬盘"; &#125; /** * 硬盘 * * @return 硬盘 */ @Override public String getHardDisk() &#123; return super.getHardDisk() + " + 1TB 固态硬盘"; &#125; /** * 价格 * * @return 价格 */ @Override public Double getPrice() &#123; return super.getPrice() + 2936; &#125;&#125; 测试类，我们需要购买一台 2T 固态硬盘 64G 内存的 MacBook Pro 123456789101112131415161718192021222324252627282930313233/** * &lt;p&gt; * 装饰者模式 - 测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/12/13 17:19 */public class PatternTest &#123; public static void main(String[] args) &#123; // MacBookPro 基础套餐 MacBookPro macBookPro = new BaseMacBookProCombo(); printInfo(macBookPro); // 升级内存 16G -&gt; 64G macBookPro = new MemoryCombo(macBookPro); macBookPro = new MemoryCombo(macBookPro); macBookPro = new MemoryCombo(macBookPro); printInfo(macBookPro); // 升级硬盘 1T -&gt; 2T macBookPro = new HardDiskCombo(macBookPro); printInfo(macBookPro); &#125; private static void printInfo(MacBookPro macBookPro) &#123; System.out.println("当前套餐: " + macBookPro.getComboName()); System.out.println("内存: " + macBookPro.getMemory()); System.out.println("硬盘: " + macBookPro.getHardDisk()); System.out.println("总价为: " + macBookPro.getPrice() + " 元"); System.out.println("\n======================================\n"); &#125;&#125; 测试结果 1234567891011121314151617181920当前套餐: 基础套餐内存: 16GB 2666MHz DDR4 内存硬盘: 1T 固态硬盘总价为: 22199.0 元======================================当前套餐: 基础套餐 + 升级内存 + 升级内存 + 升级内存内存: 16GB 2666MHz DDR4 内存 + 16G 内存 + 16G 内存 + 16G 内存硬盘: 1T 固态硬盘总价为: 31007.0 元======================================当前套餐: 基础套餐 + 升级内存 + 升级内存 + 升级内存 + 升级硬盘内存: 16GB 2666MHz DDR4 内存 + 16G 内存 + 16G 内存 + 16G 内存硬盘: 1T 固态硬盘 + 1TB 固态硬盘总价为: 33943.0 元====================================== 3. UML 图例 4. 应用 123456// JDK 中的 IO 类// BufferedReader、InputStream、OutputStream// Spring 中处理事务缓存 TransactionAwareCacheDecorator// Spring MVC 中对 Header 的处理 HttpHeadResponseDecorator 5. 场景 用于扩展一个类的功能。 给一个类添加附加职责。 动态的给一个对象添加功能，这些功能可以再动态的撤销。 6. 优缺点 优点： 1、装饰者是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象 扩展功能，即插即用。 2、通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。 3、装饰者完全遵守开闭原则。 缺点： 1、会出现更多的代码，更多的类，增加程序复杂性。 2、动态装饰时，多层装饰时会更复杂。 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/structural/decorator]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之行为型设计模式-观察者模式]]></title>
    <url>%2F2019%2F10%2F25%2Fdesign-pattern-observer.html</url>
    <content type="text"><![CDATA[1. 模式简介 定义了对象之间的一对多依赖，让多个观察者对象同时监听一个主体对象，当主体对象发生变化时，它的所有观察者对象都会收到通知并更新。属于行为型设计模式。观察者模式也被叫做发布订阅模式。 2. 示例代码 这里我们使用观察者模式来模拟一个消息推送通知的场景。 消息 12345678910111213141516/** * &lt;p&gt; * 消息 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/24 17:36 */@Data@NoArgsConstructor@AllArgsConstructorpublic class Message &#123; private String message; private String from; private String to;&#125; 消息发布(被观察者) 12345678910111213141516171819202122232425262728293031323334/** * &lt;p&gt; * 消息推送，被观察者 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/24 17:36 */public class Pusher extends Observable &#123; private static Pusher PUSHER = null; private Pusher() &#123; &#125; public static Pusher getInstance() &#123; if (null == PUSHER) &#123; PUSHER = new Pusher(); &#125; return PUSHER; &#125; /** * 推送消息 * * @param message 消息 */ public void pushMessage(Message message) &#123; System.out.println(message.getFrom() + " 向 " + message.getTo() + " 发送了一条私信~~"); // 触发状态变化 setChanged(); // 提醒观察者 notifyObservers(message); &#125;&#125; 消息订阅(观察者) 123456789101112131415161718192021222324252627282930/** * &lt;p&gt; * 用户，观察者 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/24 17:43 */@Data@AllArgsConstructorpublic class User implements Observer &#123; private String name; /** * 被观察对象改变的时候，会触发这个方法 * * @param o the observable object. * @param arg an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt; */ @Override public void update(Observable o, Object arg) &#123; Message message = (Message) arg; if (this.getName().equals(message.getTo())) &#123; System.err.println(name + "，你收到一条来自 " + message.getFrom() + " 的私信！"); System.err.println("私信内容: " + message.getMessage()); &#125; &#125;&#125; 测试类 1234567891011121314151617/** * &lt;p&gt; * 观察者模式，测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/24 17:52 */public class PatternTest &#123; public static void main(String[] args) &#123; User xkcoding = new User("xkcoding"); Pusher pusher = Pusher.getInstance(); Message message = new Message("你好", "user-1", "xkcoding"); pusher.addObserver(xkcoding); pusher.pushMessage(message); &#125;&#125; 测试结果 123user-1 向 xkcoding 发送了一条私信~~xkcoding，你收到一条来自 user-1 的私信！私信内容: 你好 3. UML 图例 4. 应用 12345678// 1. JDK java.util.Observer 、 java.util.Observable// 2. Guava EventBus// 3. Spring ApplicationEvent// 4. Android ClickListerner...// 生活中// 1. 微信朋友圈通知// 2. 网站私信通知 5. 场景 观察者模式主要用于在关联行为之间建立一套触发机制的场景。 6. 优缺点 优点： 1、观察者和被观察者之间建立了一个抽象的耦合。 2、观察者模式支持广播通信。 缺点： 1、观察者之间有过多的细节依赖、提高时间消耗及程序的复杂度。2、使用需要及其谨慎，要避免循环调用。 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/behavioral/observer]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之行为型设计模式-模板方法模式]]></title>
    <url>%2F2019%2F10%2F16%2Fdesign-pattern-template.html</url>
    <content type="text"><![CDATA[1. 模式简介 定义一个程序的整体流程，并允许子类为其中的一个或者多个步骤提供具体实现。模板方法使得子类可以在不改变整体流程的情况下，重新定义其中的某些步骤。属于行为型设计模式。 2. 示例代码 这里我们通过模板方法模式实现一个短信发送、邮件发送的 demo。 定义一个整体流程 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * &lt;p&gt; * 消息发送器 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/18 17:22 */public abstract class BaseMessageSender &#123; /** * 发送消息 * * @param content 内容 */ public void send(String content) &#123; validate(content); if (!execute(content)) &#123; error(content); &#125; &#125; /** * 校验消息 * * @param content 数据 */ protected abstract void validate(String content); /** * 发送消息 * * @param content 数据 * @return &#123;@code true&#125; - 发送成功，&#123;@code false&#125; - 发送失败 */ protected abstract boolean execute(String content); /** * 错误记录 * * @param content 数据 */ protected abstract void error(String content);&#125; 短信发送的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * &lt;p&gt; * 短信发送器 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/18 17:40 */public class SmsSender extends BaseMessageSender &#123; /** * 校验消息 * * @param content 数据 */ @Override protected void validate(String content) &#123; if (content == null || "".equals(content.trim()) || content.trim().length() != 11) &#123; throw new RuntimeException("手机号码不合法"); &#125; &#125; /** * 发送消息 * * @param content 数据 * @return &#123;@code true&#125; - 发送成功，&#123;@code false&#125; - 发送失败 */ @Override protected boolean execute(String content) &#123; Random random = new Random(); if (random.nextInt(10) % 2 == 0) &#123; System.out.println("短信发送成功！"); return true; &#125; else &#123; return false; &#125; &#125; /** * 错误记录 * * @param content 数据 */ @Override protected void error(String content) &#123; System.err.println("短信发送失败！手机号：" + content); &#125;&#125; 邮件发送的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * &lt;p&gt; * 邮件发送器 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/18 17:34 */public class EmailSender extends BaseMessageSender &#123; /** * 校验消息 * * @param content 数据 */ @Override protected void validate(String content) &#123; if (content == null || "".equals(content.trim())) &#123; throw new RuntimeException("数据不能为空"); &#125; &#125; /** * 发送消息 * * @param content 数据 * @return &#123;@code true&#125; - 发送成功，&#123;@code false&#125; - 发送失败 */ @Override protected boolean execute(String content) &#123; Random random = new Random(); if (random.nextInt(10) % 2 == 0) &#123; System.out.println("邮件发送成功！"); return true; &#125; else &#123; return false; &#125; &#125; /** * 错误记录 * * @param content 数据 */ @Override protected void error(String content) &#123; System.err.println("邮件发送失败！发送内容：" + content); &#125;&#125; 测试类 12345678910111213141516171819/** * &lt;p&gt; * 模板模式，测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/11/18 17:10 */public class PatternTest &#123; public static void main(String[] args) &#123; // 邮件发送 EmailSender emailSender = new EmailSender(); emailSender.send("测试内容"); // 短信发送 SmsSender smsSender = new SmsSender(); smsSender.send("17312341234"); &#125;&#125; 测试结果 12邮件发送失败！发送内容：测试内容短信发送成功！ 3. UML 图例 4. 应用 123// Spring Data 这个模块下存在特别多的应用// 比如：// JdbcTemplate、RedisTemplate、MongoTemplate、ElasticsearchTemplate 5. 场景 一次性实现一个算法的主体流程的部分，并将可变的行为留给子类来实现。 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。 6. 优缺点 优点： 1、提高代码的复用性。2、提高代码的扩展性。3、符合开闭原则。 缺点： 1、导致类的数目增加。2、间接地增加了系统实现的复杂度。3、继承关系存在自身缺点，如果父类添加了新的抽象方法，所有子类都需要重新改一遍。 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/behavioral/template]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Easy Mock 基本用法]]></title>
    <url>%2F2019%2F10%2F14%2Feasy-mock-syntax.html</url>
    <content type="text"><![CDATA[前言 在上一篇文章，我们了解了如何《使用 docker 运行 easy-mock》，这篇文章我们来学习下 Easy Mock 的基本用法，掌握 Easy Mock 的奇淫技巧，前端小姐姐写页面再也不需要去求后端的小哥哥了。 1. 基础语法 Easy Mock 集成了 Mock.js ，因此可以使用 Mock.js 的语法来 mock 数据。 1.支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等； 2.支持扩展更多数据类型，支持自定义函数和正则。 定义返回格式如下： 1234567891011121314151617&#123; "string|1-10": "★", "string2|3": "★★", "number|+1": 202, "number2|1-100.1-10": 1, "boolean|1": true, "regexp": /[a-z][A-Z][0-9]/, "absolutePath": "@/string @/user/name", "user": &#123; "name": "demo" &#125;, "object|2": &#123; "310000": "上海市", "320000": "江苏省" &#125;, "array|1": ["AMD"]&#125; 你将得到如下结果： 1234567891011121314151617&#123; "string": "★★★★★★★★", "string2": "★★★★★★", "number": 202, "number2": 36.516242, "boolean": false, "regexp": "pT8", "absolutePath": "★★★★★★★★ demo", "user": &#123; "name": "demo" &#125;, "object": &#123; "310000": "上海市", "320000": "江苏省" &#125;, "array": "AMD"&#125; 2. 数据占位符 使用数据占位符，可以让你的数据更加真实。 定义返回格式如下： 1234567891011121314151617181920212223&#123; "string|1-2": "@string", "integer": "@integer(10, 30)", "float": "@float(60, 100, 2, 2)", "boolean": "@boolean", "date": "@date(yyyy-MM-dd)", "datetime": "@datetime", "now": "@now", "url": "@url", "email": "@email", "region": "@region", "city": "@city", "province": "@province", "county": "@county", "upper": "@upper(@title)", "guid": "@guid", "id": "@id", "image": "@image(200x200)", "title": "@title", "cparagraph": "@cparagraph", "csentence": "@csentence", "range": "@range(2, 10)"&#125; 你将得到如下结果： 1234567891011121314151617181920212223242526272829303132&#123; "string": "fQsTs@Tzdh", "integer": 18, "float": 75.86, "boolean": true, "date": "2000-05-26", "datetime": "2012-04-11 08:59:12", "now": "2019-11-15 06:11:39", "url": "ftp://qrxpkel.br/ftjjrko", "email": "i.dsfzdangko@phu.ee", "region": "华南", "city": "温州市", "province": "福建省", "county": "弋阳县", "upper": "XSNRPAYY BXWRBBKTBC GCGCJCE XQFMJTW", "guid": "19F0e2e1-E9ad-BD92-A0D5-A5f4AC92BED4", "id": "63000019830408333X", "image": "http://dummyimage.com/200x200", "title": "Unrhbf Xrlpkb Yxzd", "cparagraph": "老书称明选京基属处观取容形观角清行。给克群阶外活经导治书华与十下者志以导。派传当才已劳支南学示期构该。", "csentence": "传使引都值四六始常同进放传转指每。", "range": [ 2, 3, 4, 5, 6, 7, 8, 9 ]&#125; 3. 响应式数据 借助 Easy Mock 提供的内置对象，我们可以根据接收到的请求参数，自定义数据返回，让数据再 真实一点。 3.1. 路径参数 如果你想要获取类似 http://www.domain.com/test/:id 中的 id 参数，可以通过 _req.params.参数名 的方式获取，参考如下： 123456789&#123; data: &#123; id: function(&#123; _req &#125;) &#123; return _req.params.id &#125; &#125;&#125; 在 PostMan 测试： https://mock.xkcoding.com/mock/5dce0fdaaac115001c03b239/test/test3/1 得到如下结果： 12345&#123; "data": &#123; "id": "1" &#125;&#125; 3.2. 查询参数 如果你想要获取类似 http://www.domain.com/test?name=xkcoding 中的 name 参数，可以通过 _req.query.参数名 的方式获取，参考如下： 123456789101112131415&#123; success: function(&#123; _req &#125;) &#123; return _req.query.name ? true : false &#125;, data: &#123; id: function(&#123; _req &#125;) &#123; const name = "name 为空" return _req.query.name || name &#125; &#125;&#125; 在 PostMan 测试： https://mock.xkcoding.com/mock/5dce0fdaaac115001c03b239/test/test4 得到如下结果： 123456&#123; "data": &#123; "id": "name 为空" &#125;, "success": false&#125; 在 PostMan 测试： https://mock.xkcoding.com/mock/5dce0fdaaac115001c03b239/test/test4?name=xkcoding 得到如下结果： 123456&#123; "data": &#123; "id": "xkcoding" &#125;, "success": true&#125; 3.3. body 参数 如果你根据传过来的 body 参数返回，你可以使用 _req.body 拿到 body 数据，参考方式如下： 1234567&#123; data: function(&#123; _req &#125;) &#123; return _req.body &#125;&#125; 在 PostMan 测试，使用 POST 方式 https://mock.xkcoding.com/mock/5dce0fdaaac115001c03b239/test/test5 传入参数 1234567&#123; "text": "测试文本", "likes": [ "LOL", "CODE" ]&#125; 得到如下结果： 123456789&#123; "data": &#123; "text": "测试文本", "likes": [ "LOL", "CODE" ] &#125;&#125; 4. 高阶技巧 4.1. 快捷键 Easy Mock 项目操作界面支持快捷键 全局导航 p 个人项目 g 团队项目 w 工作台 d 文档 全局操作 n 创建项目 s 搜索 4.2. 语法提示 编辑器页面支持语法提示功能，输入 em. 即可。 em.base em.date em.image em.color em.text em.name em.web em.address em.helper em.miscellaneous em.demo.all 4.3. 如何使用 Easy Mock 实现分页数据 分页数据就需要根据参数返回当前页的数据，这就用到了上面提到的 响应式数据。 直接给出 Mock 模板吧，逻辑不复杂，看不懂的朋友评论留言提问呀~ 123456789101112131415161718192021222324252627282930313233343536373839&#123; "code": 200, "success": true, "msg": "操作成功", "data": function(&#123; _req, Mock &#125;) &#123; const total = 94; let i = 0, list = [], currentPage = _req.query.currentPage ? _req.query.currentPage : 1, //当前页数 pageSize = _req.query.pageSize ? _req.query.pageSize : 10, //每次返回的条数 len = (total - pageSize * (currentPage - 1)) &lt; pageSize ? (total - pageSize * (currentPage - 1)) : pageSize; for (i; i &lt; len; i++) &#123; // 当前序号 -&gt; i + pageSize * (currentPage - 1) + 1 const width = Mock.mock('@integer(200, 400)'); list.push( Mock.mock(&#123; "id": "@id", "title": "《@ctitle(5,10)》", "summary": "@cword(3)", "image": Mock.Random.image(width + 'x16:9', Mock.Random.color(), '#FFF', 'jpg', 'xkcoding'), "publishTime": "@now", "author": "xkcoding", "watch": "@integer(0, 1000)", "star": "@integer(0, 100)", "fork": "@integer(0, 100)" &#125;) ); &#125; return &#123; total, list &#125; &#125;&#125; 我们在 PostMan 测试： https://mock.xkcoding.com/mock/5dce0fdaaac115001c03b239/test/test6?currentPage=1&amp;pageSize=2 得到如下结果： 1234567891011121314151617181920212223242526272829303132&#123; "code": 200, "success": true, "msg": "操作成功", "data": &#123; "total": 94, "list": [ &#123; "id": "420000198912064299", "title": "《东路运院少派成开团》", "summary": "处前类", "image": "http://dummyimage.com/240x16:9/79f2ee/FFF.jpg&amp;text=xkcoding", "publishTime": "2019-11-15 07:31:44", "author": "xkcoding", "watch": 990, "star": 35, "fork": 63 &#125;, &#123; "id": "22000019910311824X", "title": "《气影几把理时界海》", "summary": "志定业", "image": "http://dummyimage.com/256x16:9/f2cb79/FFF.jpg&amp;text=xkcoding", "publishTime": "2019-11-15 07:31:44", "author": "xkcoding", "watch": 413, "star": 29, "fork": 51 &#125; ] &#125;&#125; 5. 附录 Easy Mock 响应式数据中，可以为某个属性指定 Function，为 Function 提供了 _req 对象，下面是 Function 的参数说明： 对象 描述 Mock Mock 对象 _req.url 获得请求 url 地址 _req.method 获取请求方法 _req.params 获取 url 参数对象 _req.querystring 获取查询参数字符串(url中?后面的部分)，不包含 ? _req.query 将查询参数字符串进行解析并以对象的形式返回，如果没有查询参数字符串则返回一个空对象 _req.body 当 post 请求以 x-www-form-urlencoded 方式提交时，我们可以拿到请求的参数对象 _req.path 获取请求路径名 _req.header 获取请求头对象 _req.originalUrl 获取请求原始地址 _req.search 获取查询参数字符串，包含 ? _req.host 获取 host (hostname:port) _req.hostname 获取 hostname _req.type 获取请求 Content-Type，不包含像 “charset” 这样的参数 _req.protocol 返回请求协议 _req.ip 请求远程地址 _req.get(field) 获取请求 header 中对应 field 的值 _req.cookies(field) 获取请求 cookies 中对应 field 的值 同时也提供了自定义响应的配置，封装在 _res 对象中 字段 描述 status 可以定制返回的 http status code，默认是 200 cookies 可以定制需要设置的 cookie（暂时不支持设置过期时间等） headers 可以定制返回的 response 的 header data 如果有这个字段，会以此数据直接覆盖整个返回的数据，并且此处不支持 mock 的语法（如果 _res.status 的值为 200，则不会覆盖默认定义的 mock 数据） 6. 参考 Easy Mock 官方文档 Mock.js 官方文档]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>easy mock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 docker 运行 easy-mock]]></title>
    <url>%2F2019%2F10%2F08%2Fdocker-easy-mock.html</url>
    <content type="text"><![CDATA[前言 有时候，我们写前端页面或者小程序的时候，如果有数据，我们就可以更好的进行开发，但是实际场景中，前后端是并行开发的，并没有现成的后端接口给我们用，这时候 mock 假数据的作用有显得十分有必要了。 1. 常见的 Mock 方式 日常开发过程中，有以下几种常见的 Mock 假数据的方式： 将模拟数据直接写在代码里 利用 JavaScript 拦截请求 利用 Charles、 Fiddler 等代理工具拦截请求 虽然这几种方式都很 实用 但是却存在以下几点问题： 配置、编写繁琐 mock 的数据不够真实 加上容易去除难 2. 什么是 Easy Mock Easy Mock 是一个可视化，并且能快速生成 模拟数据 的持久化服务。 官方网站：https://www.easy-mock.com/ 特性： 支持接口代理 支持快捷键操作 支持协同编辑 支持团队项目 支持 RESTful 支持 Swagger | OpenAPI Specification (1.2 &amp; 2.0 &amp; 3.0) 基于 Swagger 快速创建项目 支持显示接口的入参与返回值 支持显示实体类 支持灵活性与扩展性更高的响应式数据开发 支持自定义响应配置（例：status/headers/cookies） 支持 Mock.js 语法 支持 restc 方式的接口预览 3. 搭建 Easy Mock 因为 Easy Mock 依赖 Redis 和 MongoDB，因此本地环境使用 docker-compose 来搭建 Easy Mock 应该算是最佳实践了。 3.1. 安装 docker-compose 官方文档：https://docs.docker.com/compose/install/ 首先你得确定拥有 docker 环境，如果你是 Windows / Mac 用户，那么安装客户端，就会自带 docker-compose 了。 因为本次我们是在服务器搭建，当前服务器系统是 CentOS 7，所以我们需要自行安装 docker-compose。 运行如下命令，下载当前稳定版本的 docker-compose 1sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 修改文件权限为可执行文件 1sudo chmod +x /usr/local/bin/docker-compose 验证是否安装成功 12345$ docker-compose version docker-compose version 1.24.1, build 4667896bdocker-py version: 3.7.3CPython version: 3.6.8OpenSSL version: OpenSSL 1.1.0j 20 Nov 2018 3.2. 编写 docker-compose.yml 文件 注意看文件中的注释信息，有一处 npm start 修改为 npm run dev，是因为我看了下 easy-mock 的源码 package.json 中 npm start 命令跑的是 production 模式，需要额外配置，为了简单起见，我们使用 npm run dev 直接运行 dev 模式 12345678910111213141516171819202122232425262728293031323334353637version: '3'services: mongodb: image: mongo:3.4.1 volumes: # /apps/easy-mock/data/db 是数据库文件存放地址，根据需要修改为本地地址 - '/apps/easy-mock/data/db:/data/db' networks: - easy-mock restart: always redis: image: redis:4.0.6 command: redis-server --appendonly yes volumes: # /apps/easy-mock/data/redis 是 redis 数据文件存放地址，根据需要修改为本地地址 - '/apps/easy-mock/data/redis:/data' networks: - easy-mock restart: always web: image: easymock/easymock:1.6.0 # easy-mock 官方给出的文件，这里是 npm start，这里修改为 npm run dev command: /bin/bash -c "npm run dev" ports: - 7300:7300 volumes: # 日志地址，根据需要修改为本地地址 - '/apps/easy-mock/logs:/home/easy-mock/easy-mock/logs' networks: - easy-mock restart: alwaysnetworks: easy-mock: 3.3. 启动 Easy Mock 在 docker-compose 文件目录下，运行如下命令： 1$ docker-compose up -d 4. 配置 nginx 4.1. 编写 nginx 配置文件 123456789101112131415161718192021222324252627server &#123; listen 443; server_name mock.xkcoding.com; # 监听的域名 client_max_body_size 5G; # 突破上传大文件限制 ssl on; ssl_certificate xxxxxx.pem; # https 的 pem 文件 ssl_certificate_key xxxxxx.key; # https 的 key 文件 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://localhost:7300; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_buffering off; &#125;&#125;server&#123; listen 80; server_name mock.xkcoding.com; # 监听的域名 rewrite ^(.*)$ https://$host$1 permanent; # 强制 非https 跳转到 https&#125; 4.2. 测试配置文件 123$ nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 4.3. 重启 nginx 1$ nginx -s reload 5. DNS 解析 前往云服务器对配置的域名做 DNS 解析到服务器，就大功告成了~ 6. 参考 easy mock docker 官方仓库 easy mock 官方仓库]]></content>
      <categories>
        <category>技术相关</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>easy mock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之结构型设计模式-适配器模式]]></title>
    <url>%2F2019%2F09%2F13%2Fdesign-pattern-adapter.html</url>
    <content type="text"><![CDATA[1. 模式简介 将一个原有的类的接口转换成期望的另一个接口，使原本的接口不兼容的类可以一起工作。属于结构型设计模式。 2. 示例代码 这里我们模拟一个现实生活中的例子，之前电脑的接口都是 USB 接口，现在很多设备新增了 Type-C 接口，为了兼容，出了一种转接头设备，将 USB 接口输出变成 Type-C 接口输出。 USB 接口类 1234567891011121314151617181920/** * &lt;p&gt; * 定义标准的电脑USB接口类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/9/16 17:07 */public class Usb &#123; /** * 接口类型 * * @return USB */ public String slot() &#123; String type = "USB"; System.out.println("接口类型：" + type); return type; &#125;&#125; Type-C 接口 12345678910111213141516/** * &lt;p&gt; * 新的Type-C接口 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/9/16 17:10 */public interface TypeC &#123; /** * 接口类型 * * @return USB */ String slot();&#125; USB 转 Type-C 转接头 12345678910111213141516171819202122232425262728293031323334/** * &lt;p&gt; * USB接口 转 Type-C接口 转接头 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/9/16 17:11 */public class TypeCAdapter implements TypeC &#123; private Usb usb; public TypeCAdapter(Usb usb) &#123; this.usb = usb; &#125; /** * 接口类型 * * @return USB */ @Override public String slot() &#123; String originalType = usb.slot(); String type = transformSlot(originalType); System.out.println("接口类型：" + type); return type; &#125; private String transformSlot(String originalType) &#123; String type = "Type-C"; System.out.println("使用 " + originalType + " 转 " + type + " 转接头"); return type; &#125;&#125; 测试类 1234567891011121314/** * &lt;p&gt; * 适配器模式 - 测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/9/16 17:15 */public class PatternTest &#123; public static void main(String[] args) &#123; TypeC typeC = new TypeCAdapter(new Usb()); typeC.slot(); &#125;&#125; 测试结果 123接口类型：USB使用 USB 转 Type-C 转接头接口类型：Type-C 3. UML 图例 4. 应用 123// Spring MVC 中的 HandlerAdapter// Spring AOP 中的 AdvisorAdapter 5. 场景 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决 方案。 6. 优缺点 优点： 1、能提高类的透明性和复用，现有的类复用但不需要改变。 2、目标类和适配器类解耦，提高程序的扩展性。 3、在很多业务场景中符合开闭原则。 缺点： 1、适配器编写过程需要全面考虑，可能会增加系统的复杂性。2、增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/structural/adapter]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之行为型设计模式-策略模式]]></title>
    <url>%2F2019%2F09%2F03%2Fdesign-pattern-strategy.html</url>
    <content type="text"><![CDATA[1. 模式简介 定义了一系列算法、分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。可以避免多重分支的 if...else... 和 switch 语句。属于行为型设计模式。 2. 示例代码 支付方式策略 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * &lt;p&gt; * 支付策略 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 14:43 */public enum PaymentStrategy &#123; /** * 支付宝 */ ALI_PAY, /** * 微信支付 */ WECHAT_PAY, /** * 京东支付 */ JD_PAY, /** * 银联支付 */ UNION_PAY; /** * 支付方式容器池 */ private static Map&lt;PaymentStrategy, Payment&gt; PAYMENT_POOL = new HashMap&lt;&gt;(); static &#123; PAYMENT_POOL.put(ALI_PAY, new AliPayment()); PAYMENT_POOL.put(WECHAT_PAY, new WeChatPayment()); PAYMENT_POOL.put(JD_PAY, new JdPayment()); PAYMENT_POOL.put(UNION_PAY, new UnionPayment()); &#125; /** * 选择支付方式 * * @param strategy 支付策略 * @return 支付方式 */ public static Payment choose(PaymentStrategy strategy) &#123; Payment payment = PAYMENT_POOL.get(ALI_PAY); if (PAYMENT_POOL.containsKey(strategy)) &#123; payment = PAYMENT_POOL.get(strategy); &#125; System.out.println("欢迎使用: " + payment.channelName()); return payment; &#125;&#125; 支付方式的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206/** * &lt;p&gt; * 支付接口 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 14:31 */public interface Payment &#123; /** * 支付渠道 * * @return 支付渠道 */ String channelName(); /** * 余额 * * @return 账户余额 */ double balance(); /** * 支付金额 * * @param money 金额 */ void pay(double money);&#125;/** * &lt;p&gt; * 支付宝支付 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 14:38 */public class AliPayment implements Payment &#123; /** * 支付渠道 * * @return 支付渠道 */ @Override public String channelName() &#123; return "支付宝支付"; &#125; /** * 余额 * * @return 账户余额 */ @Override public double balance() &#123; return 800; &#125; /** * 支付金额 * * @param money 金额 */ @Override public void pay(double money) &#123; if (balance() &lt; money) &#123; System.err.println("余额不足，当前余额：" + balance()); &#125; else &#123; System.out.println("支付成功，交易金额：" + money); &#125; &#125;&#125;/** * &lt;p&gt; * 京东支付 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 14:38 */public class JdPayment implements Payment &#123; /** * 支付渠道 * * @return 支付渠道 */ @Override public String channelName() &#123; return "京东支付"; &#125; /** * 余额 * * @return 账户余额 */ @Override public double balance() &#123; return 500; &#125; /** * 支付金额 * * @param money 金额 */ @Override public void pay(double money) &#123; if (balance() &lt; money) &#123; System.err.println("余额不足，当前余额：" + balance()); &#125; else &#123; System.out.println("支付成功，交易金额：" + money); &#125; &#125;&#125;/** * &lt;p&gt; * 微信支付 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 14:38 */public class WeChatPayment implements Payment &#123; /** * 支付渠道 * * @return 支付渠道 */ @Override public String channelName() &#123; return "微信支付"; &#125; /** * 余额 * * @return 账户余额 */ @Override public double balance() &#123; return 1234; &#125; /** * 支付金额 * * @param money 金额 */ @Override public void pay(double money) &#123; if (balance() &lt; money) &#123; System.err.println("余额不足，当前余额：" + balance()); &#125; else &#123; System.out.println("支付成功，交易金额：" + money); &#125; &#125;&#125;/** * &lt;p&gt; * 银联支付 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 14:38 */public class UnionPayment implements Payment &#123; /** * 支付渠道 * * @return 支付渠道 */ @Override public String channelName() &#123; return "银联支付"; &#125; /** * 余额 * * @return 账户余额 */ @Override public double balance() &#123; return 10; &#125; /** * 支付金额 * * @param money 金额 */ @Override public void pay(double money) &#123; if (balance() &lt; money) &#123; System.err.println("余额不足，当前余额：" + balance()); &#125; else &#123; System.out.println("支付成功，交易金额：" + money); &#125; &#125;&#125; 测试类 12345678910111213141516171819/** * &lt;p&gt; * 策略模式，测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 14:54 */public class PatternTest &#123; public static void main(String[] args) &#123; Payment payment = PaymentStrategy.choose(PaymentStrategy.ALI_PAY); payment.pay(200); System.out.println("--------------------"); payment = PaymentStrategy.choose(PaymentStrategy.UNION_PAY); payment.pay(200); &#125;&#125; 测试结果 12345欢迎使用: 支付宝支付支付成功，交易金额：200.0--------------------欢迎使用: 银联支付余额不足，当前余额：10.0 3. UML 图例 4. 应用 123456789101112// JDK 的 Comparator 接口，比如：// java.util.Arrays#parallelSort(int[], int, int)// java.util.TreeMap#TreeMap(java.util.Comparator&lt;? super K&gt;)// Spring 的 Resource 接口，比如： // ClassPathResource// UrlResource// FileUrlResource// FileSystemResource// ClassPathResource// ByteArrayResource// InputStreamResource 5. 场景 假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。 一个系统需要动态地在几种算法中选择一种。 6. 优缺点 优点： 1、策略模式符合开闭原则。2、避免使用多重条件转移语句，如if…else…语句、switch语句。3、使用策略模式可以提高算法的保密性和安全性。 缺点： 1、客户端必须知道所有的策略，并且自行决定使用哪一个策略类。 2、代码中会产生非常多策略类，增加维护难度。 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/behavioral/strategy]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Actions 初体验]]></title>
    <url>%2F2019%2F08%2F29%2Fearly-experience-about-github-actions.html</url>
    <content type="text"><![CDATA[前言 前段时间同性交友网站 GitHub 推出了自家的 Registry 服务，支持多种语言的镜像服务，具体参见：https://help.github.com/en/articles/about-github-package-registry 随后，又推出了自家的自动化构建服务：Github Actions，具体参见：https://help.github.com/en/articles/about-github-actions 这俩服务我都在第一时间申请使用了，也都已经审核通过了，但是由于 Registry 测试有些不稳定，还存在一些问题，所以，并未发布体验文章，不过 关于GitHub Actions 我已经成功体验了一把。 1. GitHub Actions GitHub Actions enables you to create custom software development lifecycle workflows directly in your GitHub repository. —— https://help.github.com/en/articles/about-github-actions 土味英语翻译一下： GitHub Actions 允许你直接在 GitHub 仓库中去创建自定义软件开发生命周期工作流。 官网下面还有更为详细的介绍，我就不好意思秀我的土味英语了。简而言之，GitHub Actions 允许用户自定义一个完整流程的 CI/CD 工作流，同时不需要借助类似Jenkins、Travis-CI 和 Circle-CI 等第三方自动化服务，在 GitHub 上的开源项目都可以免费使用的，唔，好嗨哟~ 对于，工具类这种的开源项目，后期可以通过 GitHub Actions 和 Registry 实现自动打包发布版本。 2. 初体验 2.1. 申请 点击链接 https://github.com/features/actions/signup 去申请 2.2. 准备好一个仓库地址 当你申请通过之后，打开你的任意一个 GitHub 仓库，上方会出现 Actions 的选项卡，点击即可进入。 2.3. 选择一个默认的模板 因为这里我的是 Spring Boot 项目，基于 Maven 来构建，所以我选择 Maven 的模板。选择之后，进入下面的页面。 2.4. 触发 当我们的代码 push 的时候就会自动触发，当然也有别的触发策略，这个后面再讲。 点击可以查看具体的构建情况，黑框里的每一项都可以点击查看详情。 3. 配置语法 具体的配置语法，还是参考官方文档：https://help.github.com/en/articles/workflow-syntax-for-github-actions 4. 附录 .github/workflows/maven.yml 1234567891011121314151617name: GitHub CIon: push: branches: - master pull_request:jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v1 - name: Set up JDK 1.8 uses: actions/setup-java@v1 with: java-version: 1.8 - name: Build with Maven run: mvn clean package -DskipTests=true -Dmaven.javadoc.skip=true -B -V 5. 参考 官方文档：https://help.github.com/en/articles/workflow-syntax-for-github-actions]]></content>
      <categories>
        <category>技术相关</category>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>ci</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之行为型设计模式-委派模式]]></title>
    <url>%2F2019%2F08%2F27%2Fdesign-pattern-delegate.html</url>
    <content type="text"><![CDATA[1. 模式简介 负责任务的调度和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理的全权代理，但是代理模式注重过程，而委派模式注重结果；属于行为型设计模式；不属于23种设计模式。 2. 示例代码 业务执行者(Worker)的具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * &lt;p&gt; * 工人接口 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 11:17 */public interface Worker &#123; /** * 做事情 * * @param thing 任务 */ void doing(String thing);&#125;/** * &lt;p&gt; * 厨师工 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 11:19 */public class ChefWorker implements Worker &#123; /** * 做事情 * * @param thing 任务 */ @Override public void doing(String thing) &#123; System.out.println("我是厨师，我接到任务，需要做美食。"); &#125;&#125;/** * &lt;p&gt; * 缝纫工 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 11:19 */public class TailorWorker implements Worker &#123; /** * 做事情 * * @param thing 任务 */ @Override public void doing(String thing) &#123; System.out.println("我是缝纫工，我接到任务，需要做衣服。"); &#125;&#125; 任务派发者(Leader)的具体实现 12345678910111213141516171819202122232425262728293031/** * &lt;p&gt; * 组长 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 11:21 */public class Leader implements Worker &#123; private static Map&lt;String, Worker&gt; OFFICE = new HashMap&lt;&gt;(); public Leader() &#123; OFFICE.put("cooking", new ChefWorker()); OFFICE.put("sewing", new TailorWorker()); &#125; /** * 做事情 * * @param thing 任务 */ @Override public void doing(String thing) &#123; System.out.println("我是组长，领导需要: " + thing + "，我来安排任务: " + thing); if (OFFICE.containsKey(thing)) &#123; OFFICE.get(thing).doing(thing); &#125; else &#123; System.err.println("目前办公室没有对应职位的工人"); &#125; &#125;&#125; 大领导(Boss)的具体实现 1234567891011121314151617181920/** * &lt;p&gt; * 领导 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 11:26 */public class Boss &#123; /** * 下命令 * * @param thing 需要处理的事情 * @param leader 安排给一个组长 */ public void command(String thing, Leader leader) &#123; System.out.println("我是领导，我现在需要处理: " + thing); leader.doing(thing); &#125;&#125; 测试类 123456789101112131415161718/** * &lt;p&gt; * 委派模式，测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019/8/28 11:28 */public class PatternTest &#123; public static void main(String[] args) &#123; Boss boss = new Boss(); boss.command("cooking", new Leader()); System.out.println("------------------- "); boss.command("sewing", new Leader()); System.out.println("------------------- "); boss.command("selling", new Leader()); &#125;&#125; 测试结果 1234567891011我是领导，我现在需要处理: cooking我是组长，领导需要: cooking，我来安排任务: cooking我是厨师，我接到任务，需要做美食。------------------- 我是领导，我现在需要处理: sewing我是组长，领导需要: sewing，我来安排任务: sewing我是缝纫工，我接到任务，需要做衣服。------------------- 我是领导，我现在需要处理: selling我是组长，领导需要: selling，我来安排任务: selling目前办公室没有对应职位的工人 3. UML 图例 4. 应用 1234// 在 Spring 中以 Delegate 结尾的一般都是实现了委派模式的// 例如：BeanDefinitionParserDelegate// Spring MVC 中的 DispatcherServlet 根据 handlerMapping 转发具体执行逻辑到 Controller 5. 优缺点 优点： 对内隐藏实现, 简化调用。 缺点： 当实际处理业务的类需要扩展时，派发命令的类也需要对应做调整，不符合开闭原则。 6. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/behavioral/delegate]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之结构型设计模式-代理模式]]></title>
    <url>%2F2019%2F08%2F20%2Fdesign-pattern-proxy.html</url>
    <content type="text"><![CDATA[1. 模式简介 为其他对象提供一种代理，以控制对这个对象的访问；代理对象就类似生活中的中介；属于结构型设计模式。 2. 示例代码 2.1. 静态代理 显式声明被代理对象，仅可以代理某些对象 2.1.1. 代码实现 具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * &lt;p&gt; * 售票接口 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:12 */public interface Ticket &#123; /** * 卖票 */ void sell();&#125;/** * &lt;p&gt; * 演唱会门票 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:16 */public class MusicTicket implements Ticket &#123; /** * 卖票 */ @Override public void sell() &#123; System.out.println("卖演唱会门票"); &#125;&#125;/** * &lt;p&gt; * 静态代理类，演唱会售票员(只卖演唱会门票) * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:24 */public class MusicConductor implements Ticket &#123; private MusicTicket ticket; /** * 只代理 演唱会门票 * @param ticket 演唱会门票 */ public MusicConductor(MusicTicket ticket) &#123; this.ticket = ticket; &#125; /** * 卖票 */ @Override public void sell() &#123; before(); this.ticket.sell(); after(); &#125; private void before() &#123; System.out.println("静态代理 - 方法前增强"); &#125; private void after() &#123; System.out.println("静态代理 - 方法后增强"); &#125;&#125; 测试类 1234567891011121314/** * &lt;p&gt; * 代理模式 - 静态代理，测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:29 */public class PatternTest &#123; public static void main(String[] args) &#123; MusicConductor conductor = new MusicConductor(new MusicTicket()); conductor.sell(); &#125;&#125; 测试结果 123静态代理 - 方法前增强卖演唱会门票静态代理 - 方法后增强 2.1.2. UML 图例 2.2. 动态代理 动态配置和替换被代理对象，通俗的说就是可以代理任意一类对象，甚至是任意对象 2.2.1. JDK 动态代理 注意：JDK代理时被代理类必须实现接口 2.2.1.1. 代码实现 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * &lt;p&gt; * 售票接口 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:12 */public interface Ticket &#123; /** * 卖票 */ void sell();&#125;/** * &lt;p&gt; * 演唱会门票 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:16 */public class MusicTicket implements Ticket &#123; /** * 卖票 */ @Override public void sell() &#123; System.out.println("卖演唱会门票"); &#125;&#125;/** * &lt;p&gt; * 体育比赛门票 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 23:07 */public class SportTicket implements Ticket &#123; /** * 卖票 */ @Override public void sell() &#123; System.out.println("体育比赛门票"); &#125;&#125;/** * &lt;p&gt; * JDK动态代理类，售票员(不论什么票都卖) * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:35 */public class Conductor implements InvocationHandler &#123; /** * 被代理对象 */ private Object target; /** * 可以代理任意门票，所以为 &#123;@link Object&#125; * * @param target 被代理对象，但是必须有统一的接口 * @return 被代理对象 */ public Object getInstance(Object target) &#123; this.target = target; Class&lt;?&gt; clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; /** * 反射调用的方法 * * @param proxy 代理对象 * @param method 被代理对象需要执行的方法 * @param args 被代理对象需要执行的方法 的参数 * @return 被代理对象需要执行的方法 的返回值 * @throws Throwable 抛出异常 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); Object result = method.invoke(target, args); after(); return result; &#125; private void before() &#123; System.out.println("动态代理 - JDK动态代理 - 方法前增强"); &#125; private void after() &#123; System.out.println("动态代理 - JDK动态代理 - 方法后增强"); &#125;&#125; 测试类 12345678910111213141516171819/** * &lt;p&gt; * 代理模式 - 动态代理 - JDK动态代理，测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 23:04 */public class PatternTest &#123; public static void main(String[] args) &#123; // 代理演唱会门票 Ticket musicTicket = (Ticket) new Conductor().getInstance(new MusicTicket()); musicTicket.sell(); // 代理运动会门票 Ticket sportTicket = (Ticket) new Conductor().getInstance(new SportTicket()); sportTicket.sell(); &#125;&#125; 测试结果 123456动态代理 - JDK动态代理 - 方法前增强卖演唱会门票动态代理 - JDK动态代理 - 方法后增强动态代理 - JDK动态代理 - 方法前增强体育比赛门票动态代理 - JDK动态代理 - 方法后增强 2.2.1.2. UML 图例 2.2.2. CGLIB 动态代理 注意：CGLIB不能代理 final 修饰的类/方法 2.2.2.1. 代码实现 具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * &lt;p&gt; * 火车票 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 23:18 */public class TrainTicket &#123; public void sell() &#123; System.out.println("火车票"); &#125;&#125;/** * &lt;p&gt; * CGLIB动态代理类，售票员(不论什么票都卖) * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 22:35 */public class Conductor implements MethodInterceptor &#123; public Object getInstance(Class&lt;?&gt; clazz) &#123; // Enhancer 相当于 JDK 动态代理的 Proxy 类 Enhancer enhancer = new Enhancer(); // 设置动态生成的对象的父类为传进来的 被代理类 enhancer.setSuperclass(clazz); // MethodInterceptor 继承 Callback 接口 enhancer.setCallback(this); return enhancer.create(); &#125; /** * 代理对象执行的所有方法都会走这个方法 * * @param o 被代理的对象 * @param method 被代理对象需要执行的方法 * @param objects 被代理对象需要执行的方法 参数 * @param methodProxy 触发父类的方法对象 * @return 被代理对象需要执行的方法 返回值 * @throws Throwable 抛出的异常信息 */ @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; before(); // 调用生成代理对象的父类方法 Object result = methodProxy.invokeSuper(o, objects); after(); return result; &#125; private void before() &#123; System.out.println("动态代理 - CGLIB动态代理 - 方法前增强"); &#125; private void after() &#123; System.out.println("动态代理 - CGLIB动态代理 - 方法后增强"); &#125;&#125; 测试类 12345678910111213141516171819/** * &lt;p&gt; * 代理模式 - 动态代理 - CGLIB动态代理，测试类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-20 23:16 */public class PatternTest &#123; public static void main(String[] args) &#123; // 代理火车票 TrainTicket trainTicket = (TrainTicket) new Conductor().getInstance(TrainTicket.class); trainTicket.sell(); // 代理演唱会门票 MusicTicket musicTicket = (MusicTicket) new Conductor().getInstance(MusicTicket.class); musicTicket.sell(); &#125;&#125; 测试结果 123456动态代理 - CGLIB动态代理 - 方法前增强火车票动态代理 - CGLIB动态代理 - 方法后增强动态代理 - CGLIB动态代理 - 方法前增强卖演唱会门票动态代理 - CGLIB动态代理 - 方法后增强 2.2.2.2. UML 图例 3. 应用 1// Spring AOP 4. 场景 保护目标对象 增强目标对象 5. 优缺点 优点： 代理模式能将代理对象与真实被调用的目标对象分离；一定程度上降低了系统的耦合程度，易于扩展；代理可以起到保护目标对象的作用； 增强目标对象的职责 缺点： 代理模式会造成系统设计中类的数目增加；在客户端和目标对象之间增加了一个代理对象，会造成请求处 理速度变慢；增加了系统的复杂度 6. 拓展 6.1. JDK 动态代理的原理分析 原理简介 123456789// 1. 拿到被代理的对象的引用，反射获取所有接口// 2. JDK 的 Proxy 类重新生成一个新的类，实现了被代理对象的所有接口// 3. Proxy 根据字节码动态生成 Java 代码，把增强的逻辑加入到新生成的代码中// 4. 编译生成的 Java 代码对应的 class 文件// 5. 通过 ClassLoader 加载并重新运行新的 class 文件（注意这个 class 文件就是一个全新的类） 源码剖析 首先我们将断点打在 这个位置 如下图所示，可以发现，此时这个 musicTicket 对象的引用有点奇怪，居然是 $Proxy0@554，证明该对象是通过代理生成的新的代理类创建的，而不是由原生的 MusicTicket 类创建的。 为什么嘞？我们来瞄一波源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518// 1. musicTicket 是通过我们定义的 getInstance 方法返回的，在 getInstance 方法里，我们通过调用 Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this)// 2. 我们看看 java.lang.reflect.Proxy#newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) // java.lang.reflect.Proxy#newProxyInstance 主要工作就是①生成代理类②根据代理类获取构造方法③通过构造方法生成代理对象// ①生成代理类 -&gt; Class&lt;?&gt; cl = getProxyClass0(loader, intfs);// ②根据代理类获取构造方法 -&gt; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);// ③通过构造方法生成代理对象 -&gt; return cons.newInstance(new Object[]&#123;h&#125;);// 3. 这里的重点在于生成代理类，所以我们看看 getProxyClass0 这个方法 -&gt; java.lang.reflect.Proxy#getProxyClass0(ClassLoader loader,Class&lt;?&gt;... interfaces)/** * Generate a proxy class. Must call the checkProxyAccess method * to perform permission checks before calling this. * 生成代理类，调用该方法前，必须先执行checkProxyAccess方法校验是否可以生成代理类。 */private static Class&lt;?&gt; getProxyClass0(ClassLoader loader,Class&lt;?&gt;... interfaces) &#123; // 这里需要注意：接口的数量有最大限制，不可以超过 65535 if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory // 如果缓存中存在代理类，则直接返回，如果不存在，则会调用ProxyClassFactory类生成代理类 return proxyClassCache.get(loader, interfaces);&#125;// 4. 我们首次调用的时候，缓存里肯定是不存在的，所以我们先看看这个 proxyClassCache 到底是何方神圣？private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());// 4.1. 这里的 WeakCache 是JDK自己通过 ConcurrentMap 实现的一个缓存// 4.2. 键：KeyFactory 就是 ClassLoader 类加载器// 4.3. 值：ProxyClassFactory 就是代理类的工厂类对象//5. 我们查看下 java.lang.reflect.WeakCache#get(K key, P parameter) 这个方法里到底是怎么处理的/** * @param key 类加载器 * @param parameter 接口数组 */public V get(K key, P parameter) &#123; // 校验接口数组，必须存在接口，否则直接抛出 NPE Objects.requireNonNull(parameter); // 清除已经被GC回收的对象引用 expungeStaleEntries(); // 将 ClassLoader 转化为 CacheKey，此时cacheKey为一级缓存的key Object cacheKey = WeakCache.CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey // 根据一级缓存的key获取二级缓存 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); // 二级缓存不存在，创建一个空的二级缓存 if (valuesMap == null) &#123; ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap // 根据 ClassLoader 和 接口数组，创建二级缓存的key Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); // 通过二级缓存的key获取值 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); WeakCache.Factory factory = null; // 死循环重试，直到返回对象为止 while (true) &#123; // 程序的出口分支 if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance // 根据下方的方法可以看出 supplier 可能是 WeakCache.Factory 也可能是 CacheValue // 具体验证的细节，在 supplier 的实现类里去判断是什么类型，然后将值返回 V value = supplier.get(); // 如果拿到对象，则退出循环，拿不到对象，继续走循环重试 if (value != null) &#123; return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn't successful in installing the CacheValue) // lazily construct a Factory // 如果二级缓存的key取不到值，并且Factory不存在，则去创建Factory对象，这一条件分支，若执行，仅会执行一次 // 在下方代码可见，创建的Factory对象会去充当二级缓存的值 if (factory == null) &#123; factory = new WeakCache.Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; // 如果二级缓存的key取不到值, 就将factory作为二级缓存对应的值放入 // 防止被其他线程修改，所以使用 putIfAbsent 方法是如果存在 subKey，就取出来直接用，如果不存在，则将 factory 放入 supplier = valuesMap.putIfAbsent(subKey, factory); // 存放失败的情况，强制将 supplier = factory，此时factory成功加入二级缓存 if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; // 如果被其他线程修改，就尝试将factory替换旧值 if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory // 替换成功 supplier = factory; &#125; else &#123; // retry with current supplier // 替换失败，则继续使用旧值 supplier = valuesMap.get(subKey); &#125; &#125; &#125;&#125;// 6. 根据如上代码，这里关键就2点：①二级缓存key的创建②二级缓存只的获取// ①二级缓存key的创建 -&gt; Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));// ②二级缓存值的获取 -&gt; V value = supplier.get();// 7. 首先我们来看看二级缓存key的创建，这里通过 subKeyFactory.apply() 获取，那么这个 subKeyFactory 是什么呢？我们可以跟踪源码发现，这是通过 WeakCache 的构造方法传入的参数，也就是说，是在 Proxy 类里创建 proxyClassCache 的是传入的，所以这个 subKeyFactory 就是 java.lang.reflect.Proxy.KeyFactory 类的对象/** * A function that maps an array of interfaces to an optimal key where * Class objects representing interfaces are weakly referenced. * 将接口数组映射为一个最优的键去代表接口的实现类的弱引用的方法 */private static final class KeyFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt;&#123; @Override public Object apply(ClassLoader classLoader, Class&lt;?&gt;[] interfaces) &#123; switch (interfaces.length) &#123; // 这里的 Proxy.key1....这些就是根据哈希值计算key case 1: return new Proxy.Key1(interfaces[0]); // the most frequent case 2: return new Proxy.Key2(interfaces[0], interfaces[1]); case 0: return key0; default: return new Proxy.KeyX(interfaces); &#125; &#125;&#125;// 8. 然后我们到了关键的地方，敲黑板，划重点了！！！我们来看下二级缓存值的获取，在WeakCache中是通过 supplier.get() 获取的，那么关键就是这个 supplier 了。// 还记得上面说过的，V value = supplier.get() 取到的可能是 WeakCache.Factory 也可能是 CacheValue// 那我们看看 WeakCache.Factory /** * A factory &#123;@link Supplier&#125; that implements the lazy synchronized * construction of the value and installment of it into the cache. * 将值设置进缓存的工厂类，线程安全 */private final class Factory implements Supplier&lt;V&gt; &#123; private final K key; private final P parameter; private final Object subKey; private final ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap; Factory(K key, P parameter, Object subKey, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123; this.key = key; this.parameter = parameter; this.subKey = subKey; this.valuesMap = valuesMap; &#125; @Override public synchronized V get() &#123; // serialize access // re-check // 双重检查，缓存中是否已存在二级缓存key Supplier&lt;V&gt; supplier = valuesMap.get(subKey); // 之所以之前不去校验，是因为这里会去判断，是否是 WeakCache.Factory 对象还是 CacheValue // 有可能被替换成了 CacheValue 或者被移除了 // 总之如果是不是 Factory 对象本身，就返回 null，继续之前的死循环 if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop return null; &#125; // else still us (supplier == this) // create new value V value = null; try &#123; // 这里调用 valueFactory.apply(key, parameter) 获取值 value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) // 将返回的对象，包装成 CacheValue(弱引用) WeakCache.CacheValue&lt;V&gt; cacheValue = new WeakCache.CacheValue&lt;&gt;(value); // put into reverseMap reverseMap.put(cacheValue, Boolean.TRUE); // try replacing us with CacheValue (this should always succeed) if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError("Should not reach here"); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it return value; &#125;&#125;// 观察 java.lang.reflect.WeakCache.Factory 这个类的 get 方法可以发现，这里解决前面没有去判断返回值类型的坑// 如果不是 Factory 对象本身，就返回 null,继续之前的死循环// 如果是 Factory 对象，就通过 value = Objects.requireNonNull(valueFactory.apply(key, parameter)) 获取值// 所以这个 valueFactory 就是关键的地方，有了上面 subKeyFactory 的经验，我们可以很快知道这个 valueFactory 也是在构造 WeakCache 传进来的，也就是说，是在 Proxy 类里创建 proxyClassCache 的是传入的，所以这个 valueFactory 就是 java.lang.reflect.Proxy.ProxyClassFactory 类的对象// 9. 接下来就需要来拜读下这个 java.lang.reflect.Proxy.ProxyClassFactory 这个类的源码了/** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. * 根据 ClassLoader 和 接口数组生成、定义和返回给定的代理类的工厂函数 */private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123; // prefix for all proxy class names // 定义了所有代理类的名称前缀为「$Proxy」 private static final String proxyClassNamePrefix = "$Proxy"; // next number to use for generation of unique proxy class names // 为代理类对象生成编号，从0递增，如 $Proxy0、$Proxy1 等 // 使用 AtomicLong 原子类保证线程安全 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. * 检查指定的ClassLoader加载接口得到的Class对象是否和接口数组遍历得到的Class对象相同 */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; // 不相同则抛出异常 if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; /* * Verify that the Class object actually represents an * interface. * 检查当前 Class 对象不是一个接口 */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; /* * Verify that this interface is not a duplicate. * 检查当前接口是否重复 */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; // 声明代理类所在的包 String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. * 记录所有非public的代理接口的包路径，验证是否代理接口再同一个包下。 * 公共接口无需处理，只验证非public接口 */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); // 字符串截取包名 String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; // 如果都是 public 修饰的接口，那么就将代理类的包名设置为 ReflectUtil.PROXY_PACKAGE -&gt; com.sun.proxy // 注意：万一出现 java.io.FileNotFoundException: com\sun\proxy\$Proxy0.class 这个异常，可以通过在项目路径手动创建 com.sun.proxy 包解决 if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; /* * Choose a name for the proxy class to generate. * 生成代理类序号 */ long num = nextUniqueNumber.getAndIncrement(); // 代理类名称，类似：com.sun.proxy.$Proxy0.class String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. * 生成具体的类字节码，重点！！！ */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125;// 好了，重头戏开始了，生成代理类文件的具体代码就要出现了byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);// 10. 我们来看看 sun.misc.ProxyGenerator#generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2)这个方法到底做了什么神奇的事情public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123; ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2); // 这里才真正调用了生成类字节码的方法 final byte[] var4 = var3.generateClassFile(); // 如果需要将生成的字节码保存下来的话，就需要在这里设置 saveGeneratedFiles -&gt; true if (saveGeneratedFiles) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int var1 = var0.lastIndexOf(46); Path var2; if (var1 &gt; 0) &#123; Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar)); Files.createDirectories(var3); var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class"); &#125; else &#123; var2 = Paths.get(var0 + ".class"); &#125; Files.write(var2, var4, new OpenOption[0]); return null; &#125; catch (IOException var4x) &#123; throw new InternalError("I/O exception saving generated file: " + var4x); &#125; &#125; &#125;); &#125; return var4;&#125;// 11. 得，生成字节码的代码还藏了一层！不过也算是终于见到庐山真面目了，同时我们还发现了，我们也可以通过设置参数saveGeneratedFiles将生成的代理类保存下来。// 12. 最后看看生成字节码的方法吧，sun.misc.ProxyGenerator#generateClassFileprivate byte[] generateClassFile() &#123; // 添加 hashCode 代理方法 this.addProxyMethod(hashCodeMethod, Object.class); // 添加 equals 代理方法 this.addProxyMethod(equalsMethod, Object.class); // 添加 toString 代理方法 this.addProxyMethod(toStringMethod, Object.class); Class[] var1 = this.interfaces; int var2 = var1.length; int var3; Class var4; // 遍历所有接口中的所有方法，并将所有方法添加代理方法 for(var3 = 0; var3 &lt; var2; ++var3) &#123; var4 = var1[var3]; Method[] var5 = var4.getMethods(); int var6 = var5.length; for(int var7 = 0; var7 &lt; var6; ++var7) &#123; Method var8 = var5[var7]; this.addProxyMethod(var8, var4); &#125; &#125; Iterator var11 = this.proxyMethods.values().iterator(); List var12; // 校验方法返回值 while(var11.hasNext()) &#123; var12 = (List)var11.next(); checkReturnTypes(var12); &#125; Iterator var15; try &#123; // 添加代理类的构造方法 this.methods.add(this.generateConstructor()); var11 = this.proxyMethods.values().iterator(); while(var11.hasNext()) &#123; var12 = (List)var11.next(); var15 = var12.iterator(); while(var15.hasNext()) &#123; ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next(); this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, "Ljava/lang/reflect/Method;", 10)); // 生成代理类的代理方法 this.methods.add(var16.generateMethod()); &#125; &#125; // 生成静态代码块等初始化信息 this.methods.add(this.generateStaticInitializer()); &#125; catch (IOException var10) &#123; throw new InternalError("unexpected I/O Exception", var10); &#125; // 代理类的方法个数不可以超过 65535 个 if (this.methods.size() &gt; 65535) &#123; throw new IllegalArgumentException("method limit exceeded"); &#125; // 代理类的字段个数不可以超过 65535 个 else if (this.fields.size() &gt; 65535) &#123; throw new IllegalArgumentException("field limit exceeded"); &#125; // 都满足要求，开始写出字节码文件 else &#123; // 将类名、java/lang/reflect/Proxy、以及接口数组等信息保存进 cp 中，cp是一个常量池 this.cp.getClass(dotToSlash(this.className)); this.cp.getClass("java/lang/reflect/Proxy"); var1 = this.interfaces; var2 = var1.length; for(var3 = 0; var3 &lt; var2; ++var3) &#123; var4 = var1[var3]; this.cp.getClass(dotToSlash(var4.getName())); &#125; // 设置常量池为只读，生成字节码文件之前，不可以进行修改 this.cp.setReadOnly(); ByteArrayOutputStream var13 = new ByteArrayOutputStream(); DataOutputStream var14 = new DataOutputStream(var13); // 完犊子，终于开始写出字节码文件了 try &#123; var14.writeInt(-889275714); var14.writeShort(0); var14.writeShort(49); this.cp.write(var14); var14.writeShort(this.accessFlags); var14.writeShort(this.cp.getClass(dotToSlash(this.className))); var14.writeShort(this.cp.getClass("java/lang/reflect/Proxy")); var14.writeShort(this.interfaces.length); Class[] var17 = this.interfaces; int var18 = var17.length; for(int var19 = 0; var19 &lt; var18; ++var19) &#123; Class var22 = var17[var19]; var14.writeShort(this.cp.getClass(dotToSlash(var22.getName()))); &#125; var14.writeShort(this.fields.size()); var15 = this.fields.iterator(); while(var15.hasNext()) &#123; ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next(); var20.write(var14); &#125; var14.writeShort(this.methods.size()); var15 = this.methods.iterator(); while(var15.hasNext()) &#123; ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next(); var21.write(var14); &#125; var14.writeShort(0); return var13.toByteArray(); &#125; catch (IOException var9) &#123; throw new InternalError("unexpected I/O Exception", var9); &#125; &#125;&#125;// 13. 关于其中的addProxyMethod这个方法，这里我就不导读源码了，有需要的话大家自己去看看，基本就是通过反射去取关键信息// 14. generateConstructor这个方法中，我们可以看出来，在生成代理类的构造方法的时候，参数是 InvocationHandler// 15. 所以说，在JDK动态代理中，InvocationHandler 是核心，调用时真正走的是 InvocationHandler 的 invoke() 方法 -&gt; java.lang.reflect.InvocationHandler#invoke(Object proxy, Method method, Object[] args) 根据传入的代理对象、方法、和参数决定具体调用的代理方法。// 16. 大家可以通过上方设置参数saveGeneratedFiles将生成的代理类保存下来，然后反编译看看JDK动态代理生成的代码到底是什么样的// 17. 好了，到这儿，JDK动态代理的源码分析就结束啦 6.2. CGLIB 动态代理的原理分析 原理简介 1234567// 1. 拿到被代理的类// 2. 为 CGLIB 的 Enhancer 设置父类，及其需要回调的类// 3. Enhancer 调用 create() 方法生成被代理对象，被代理对象会继承原先的类// 4. 重写被代理的方法，同时加上 final 修饰符，不可再被重写，同时将增强的逻辑加入到代理方法前后 源码剖析 有了 JDK 动态代理的经验，我们也先来看看 CGLIB 代理的对象有什么区别，同样在 这个位置 打个断点，如下图所示。果不其然，此时的 trainTicket 的引用地址依然奇怪，调试发现，是这个东西 TrainTicket$$EnhancerByCGLIB$$9d0422e9@681。 老规矩，我们来看下源码吧~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// trainTicket 是通过 getInstance() 获取的// 1. 我们先看看 getInstance 主要做了什么操作public Object getInstance(Class&lt;?&gt; clazz) &#123; // Enhancer 相当于 JDK 动态代理的 Proxy 类 Enhancer enhancer = new Enhancer(); // 设置动态生成的对象的父类为传进来的 被代理类 enhancer.setSuperclass(clazz); // MethodInterceptor 继承 Callback 接口 enhancer.setCallback(this); return enhancer.create();&#125;// 2. 调用的是 net.sf.cglib.proxy.Enhancer#create() 创建类/** * Generate a new class if necessary and uses the specified * callbacks (if any) to create a new object instance. * Uses the no-arg constructor of the superclass. * 如果有必要的话，就创建一个新的类，并根据指定的回调创建一个对象。 * 使用父类的无参构造方法创建对象 * @return a new instance */public Object create() &#123; classOnly = false; argumentTypes = null; return createHelper();&#125;// 3. 发现 create() 方法，调用的是 createHelper() 方法 -&gt; net.sf.cglib.proxy.Enhancer#createHelper()private Object createHelper() &#123; // 判断 callbackTypes、filter 是否为空，同时对为空的条件做预处理 preValidate(); // 创建一个 Key Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null, ReflectUtils.getNames(interfaces), filter == ALL_ZERO ? null : new WeakCacheKey&lt;CallbackFilter&gt;(filter), callbackTypes, useFactory, interceptDuringConstruction, serialVersionUID); this.currentKey = key; // 调用父类 -&gt; AbstractClassGenerator 的 create 方法 Object result = super.create(key); return result;&#125;// 4. 具体生成的逻辑走的是 net.sf.cglib.core.AbstractClassGenerator#create(Object key) 方法protected Object create(Object key) &#123; try &#123; // 获取 ClassLoader ClassLoader loader = getClassLoader(); Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; cache = CACHE; AbstractClassGenerator.ClassLoaderData data = cache.get(loader); if (data == null) &#123; // 保证线程安全 synchronized (AbstractClassGenerator.class) &#123; cache = CACHE; data = cache.get(loader); // 双重检查，确保线程安全 if (data == null) &#123; Map&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt; newCache = new WeakHashMap&lt;ClassLoader, AbstractClassGenerator.ClassLoaderData&gt;(cache); data = new AbstractClassGenerator.ClassLoaderData(loader); newCache.put(loader, data); CACHE = newCache; &#125; &#125; &#125; this.key = key; Object obj = data.get(this, getUseCache()); if (obj instanceof Class) &#123; return firstInstance((Class) obj); &#125; // 具体创建对象的方法 return nextInstance(obj); &#125; catch (RuntimeException e) &#123; throw e; &#125; catch (Error e) &#123; throw e; &#125; catch (Exception e) &#123; throw new CodeGenerationException(e); &#125;&#125;// 5. 具体创建对象的方法是 nextInstance(),这个方法是个抽象方法，具体实现由子类 Enhancer 实现abstract protected Object nextInstance(Object instance) throws Exception;// 6. 我们现在看看 net.sf.cglib.proxy.Enhancer#nextInstance(Object instance) 方法protected Object nextInstance(Object instance) &#123; Enhancer.EnhancerFactoryData data = (Enhancer.EnhancerFactoryData) instance; if (classOnly) &#123; return data.generatedClass; &#125; Class[] argumentTypes = this.argumentTypes; Object[] arguments = this.arguments; if (argumentTypes == null) &#123; argumentTypes = Constants.EMPTY_CLASS_ARRAY; arguments = null; &#125; return data.newInstance(argumentTypes, arguments, callbacks);&#125;// 通过 data.newInstance(argumentTypes, arguments, callbacks) 返回具体对象，第一个参数为代理对象的构成器类型，第二个为代理对象构造方法参数，第三个为对应回调对象/** * Creates proxy instance for given argument types, and assigns the callbacks. * Ideally, for each proxy class, just one set of argument types should be used, * otherwise it would have to spend time on constructor lookup. * 通过给定的参数类型，创建代理对象，同时分配回调。 * 理想情况下，每一个代理类，应该仅使用一组构造参数，否则，我们会花费很多的时间去找到对应的构造方法 * Technically, it is a re-implementation of &#123;@link Enhancer#createUsingReflection(Class)&#125;, * with "cache &#123;@link #setThreadCallbacks&#125; and &#123;@link #primaryConstructor&#125;" * * @see #createUsingReflection(Class) * @param argumentTypes constructor argument types * @param arguments constructor arguments * @param callbacks callbacks to set for the new instance * @return newly created proxy */public Object newInstance(Class[] argumentTypes, Object[] arguments, Callback[] callbacks) &#123; setThreadCallbacks(callbacks); try &#123; // Explicit reference equality is added here just in case Arrays.equals does not have one if (primaryConstructorArgTypes == argumentTypes || Arrays.equals(primaryConstructorArgTypes, argumentTypes)) &#123; // If we have relevant Constructor instance at hand, just call it // This skips "get constructors" machinery return ReflectUtils.newInstance(primaryConstructor, arguments); &#125; // Take a slow path if observing unexpected argument types return ReflectUtils.newInstance(generatedClass, argumentTypes, arguments); &#125; finally &#123; // clear thread callbacks to allow them to be gc'd setThreadCallbacks(null); &#125;&#125;// 到这里就生成了具体的对象// 如果需要看到具体生成的字节码对象是啥，可以在调用 enhancer.create() 方法前，调用如下方法，可以在对应位置生成class文件，然后通过 jd-gui 这种反编译工具，就可以查看到具体代码啦~System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/Users/yangkai.shen/Desktop/design-pattern/proxy/cglib/classes"); 6.3. JDK 动态代理与 CGLIB 动态代理的区别 JDK 动态代理生成的代理对象是实现了被代理对象的接口，CGLIB 动态代理生成的代理对象是继承了被代理对象。 JDK 和CGLIB 都是在运行期生成字节码，JDK 是直接写 class 字节码，CGLIB 使用 ASM 框架写 class 字节码，CGLIB 代理实现更复杂，CGLIB 生成代理类的效率比 JDK 生成代理类效率低。 JDK调用代理方法，是通过反射机制调用，CGLIB是通过 FastClass机制直接调用方法，CGLIB 的被代理类执行效率比 JDK 的被代理类更高。 6.3. Spring 中代理的选择原则 当Bean有实现接口时，Spring就会用JDK的动态代理。 当Bean没有实现接口时，Spring选择CGLib。 Spring可以通过配置强制使用CGLib，只需在Spring的配置文件中加入如下代码： 1&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/structural/proxy]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之创建型设计模式-原型模式]]></title>
    <url>%2F2019%2F08%2F14%2Fdesign-pattern-prototype.html</url>
    <content type="text"><![CDATA[1. 模式简介 原型实例指定创建对象的种类，通过克隆这些原型创建新的对象。调用者不需要指定对象的创建细节，不通过调用构造函数创建对象。属于创建型设计模式。 2. 示例代码 2.1. 浅克隆 2.1.1. 代码实现 原型接口 12345678910111213141516/** * &lt;p&gt; * 钱 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 15:53 */public interface Money &#123; /** * 打印 * * @return &#123;@link Money&#125; */ Money print();&#125; 具体实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * &lt;p&gt; * 形状 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 15:59 */@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class Shape implements Serializable &#123; /** * 描述 */ private String desc;&#125;/** * &lt;p&gt; * 一百元 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 15:56 */@Getter@Setterpublic class HundredMoney implements Money &#123; private Shape shape; /** * 打印 * * @return &#123;@link Money&#125; */ @Override public Money print() &#123; HundredMoney hundredMoney = new HundredMoney(); hundredMoney.setShape(this.shape); return hundredMoney; &#125;&#125; 测试类 123456789101112131415161718192021/** * &lt;p&gt; * 原型模式，浅克隆测试 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 16:35 */public class PatternTest &#123; public static void main(String[] args) &#123; HundredMoney money1 = new HundredMoney(); money1.setShape(new Shape("纸币")); // 原型模式 浅克隆 HundredMoney money2 = (HundredMoney) money1.print(); System.out.println("money1 -&gt; 引用对象地址：" + money1.getShape()); System.out.println("money2 -&gt; 引用对象地址：" + money2.getShape()); System.out.println("引用对象地址比较：" + (money1.getShape() == money2.getShape())); &#125;&#125; 测试结果 123money1 -&gt; 引用对象地址：com.xkcoding.design.pattern.creational.prototype.Shape@1d44bcfamoney2 -&gt; 引用对象地址：com.xkcoding.design.pattern.creational.prototype.Shape@1d44bcfa引用对象地址比较：true 2.1.2. UML图例 2.2. 深克隆 深克隆一定需要实现 Serializable 接口 2.2.1. 代码实现 原型接口 12345678910111213141516/** * &lt;p&gt; * 钱 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 15:53 */public interface Money &#123; /** * 打印 * * @return &#123;@link Money&#125; */ Money print();&#125; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * &lt;p&gt; * 形状 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 15:59 */@Getter@Setter@NoArgsConstructor@AllArgsConstructorpublic class Shape implements Serializable &#123; /** * 描述 */ private String desc;&#125;/** * &lt;p&gt; * 一百元 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 15:56 */@Getter@Setterpublic class HundredMoney implements Money, Cloneable, Serializable &#123; private Shape shape; /** * 打印 * * @return &#123;@link Money&#125; */ @Override public Money print() &#123; return (Money) this.clone(); &#125; @Override protected Object clone() &#123; return this.deepClone(); &#125; @SneakyThrows private Object deepClone() &#123; @Cleanup ByteArrayOutputStream bos = new ByteArrayOutputStream(); @Cleanup ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); @Cleanup ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); @Cleanup ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125;&#125; 测试类 123456789101112131415161718192021/** * &lt;p&gt; * 原型模式，深克隆测试，注意所有引用对象均需要实现 &#123;@link java.io.Serializable&#125; 接口 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-14 17:29 */public class PatternTest &#123; public static void main(String[] args) &#123; HundredMoney money1 = new HundredMoney(); money1.setShape(new Shape("纸币")); // 原型模式 深克隆 HundredMoney money2 = (HundredMoney) money1.print(); System.out.println("money1 -&gt; 引用对象地址：" + money1.getShape()); System.out.println("money2 -&gt; 引用对象地址：" + money2.getShape()); System.out.println("引用对象地址比较：" + (money1.getShape() == money2.getShape())); &#125;&#125; 测试结果 123money1 -&gt; 引用对象地址：com.xkcoding.design.pattern.creational.prototype.Shape@355da254money2 -&gt; 引用对象地址：com.xkcoding.design.pattern.creational.prototype.Shape@12edcd21引用对象地址比较：false 2.2.2. UML图例 3. 应用 123456789// BeanUtils.copyProperties()// JSON.parseObject()// Guava copy 的工具类// spring 中的 scope = "prototype" 就是通过加载 Spring 容器中的对象模板，复制出多实例的// JDK 中 Arrays.copyOf() 4. 场景 类初始化消耗资源较多 创建对象的时候步骤繁琐（数据准备、访问权限等初始化） 构造函数复杂 循环体重创建大量对象 6. 优缺点 优点： 原型模式性能比直接new一个对象性能高；简化了创建过程 缺点： 必须配备克隆（或者可拷贝）方法；对克隆复杂对象或者对克隆出的对象进行复杂改造时，容易带来风险；浅克隆 和 深克隆 要运用得当 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/creational/prototype]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之创建型设计模式-单例模式]]></title>
    <url>%2F2019%2F08%2F12%2Fdesign-pattern-singleton.html</url>
    <content type="text"><![CDATA[1. 模式简介 确保一个类在任何情况下都绝对只有一个实例，并提供一个全局的访问入口点；隐藏所有的构造方法；属于创建型设计模式。 2. 实现方式 2.1. 饿汉式单例 先将实例创建出来，用的时候直接拿 2.1.1. 属性初始化 12345678910111213141516171819202122232425262728293031/** * &lt;p&gt; * 饿汉式单例，在属性初始化 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 11:32 */public class EagerSingleton1 &#123; private final static EagerSingleton1 INSTANCE = new EagerSingleton1(); /** * 私有化构造方法 */ private EagerSingleton1() &#123; &#125; /** * 提供全局访问入口 */ public static EagerSingleton1 getInstance() &#123; return INSTANCE; &#125; public static void main(String[] args) throws InterruptedException &#123; ConcurrentExecutor.execute(() -&gt; &#123; System.out.println("线程号: " + Thread.currentThread().getName() + "，" + EagerSingleton1.getInstance()); &#125;, 10, 5); &#125;&#125; 2.1.2. 静态代码块初始化 12345678910111213141516171819202122232425262728293031323334353637/** * &lt;p&gt; * 饿汉式单例，在静态代码块初始化 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 11:46 */public class EagerSingleton2 &#123; /** * 此处需要设置为 &#123;@code final&#125; 的，防止被后续赋值！ */ private final static EagerSingleton2 INSTANCE; static &#123; INSTANCE = new EagerSingleton2(); &#125; /** * 私有化构造方法 */ private EagerSingleton2() &#123; &#125; /** * 提供全局访问入口 */ public static EagerSingleton2 getInstance() &#123; return INSTANCE; &#125; public static void main(String[] args) throws InterruptedException &#123; ConcurrentExecutor.execute(() -&gt; &#123; System.out.println("线程号: " + Thread.currentThread().getName() + "，" + EagerSingleton2.getInstance()); &#125;, 10, 5); &#125;&#125; 2.2. 懒汉式单例 用的时候再去创建 2.2.1. 简单实现 123456789101112131415161718192021222324252627282930/** * &lt;p&gt; * 懒汉式单例，简单实现 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 19:15 */public class LazySingletonSimple &#123; private static LazySingletonSimple INSTANCE = null; private LazySingletonSimple() &#123; &#125; /** * 此处需要加 &#123;@code synchronized&#125;，保证线程安全 */ public synchronized static LazySingletonSimple getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new LazySingletonSimple(); &#125; return INSTANCE; &#125; public static void main(String[] args) throws InterruptedException &#123; ConcurrentExecutor.execute(() -&gt; &#123; System.out.println("线程号: " + Thread.currentThread().getName() + "，" + LazySingletonSimple.getInstance()); &#125;, 10, 5); &#125;&#125; 2.2.2. 双重检查锁实现 12345678910111213141516171819202122232425262728293031323334/** * &lt;p&gt; * 懒汉式单例，双重检查锁 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 19:19 */public class LazySingletonDoubleCheck &#123; /** * 添加 &#123;@code volatile&#125; 解决底层 CPU 指令重排的问题 */ private volatile static LazySingletonDoubleCheck INSTANCE = null; private LazySingletonDoubleCheck() &#123; &#125; public static LazySingletonDoubleCheck getInstance() &#123; if (INSTANCE == null) &#123; synchronized (LazySingletonDoubleCheck.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new LazySingletonDoubleCheck(); &#125; &#125; &#125; return INSTANCE; &#125; public static void main(String[] args) throws InterruptedException &#123; ConcurrentExecutor.execute(() -&gt; &#123; System.out.println("线程号: " + Thread.currentThread().getName() + "，" + LazySingletonDoubleCheck.getInstance()); &#125;, 10, 5); &#125;&#125; 2.2.3. 静态内部类实现（推荐写法） 12345678910111213141516171819202122232425262728293031323334353637383940/** * &lt;p&gt; * 懒汉式单例，内部类写法，&#123;@code 推荐写法之一&#125; * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 19:24 */public class LazySingletonInnerClass &#123; private LazySingletonInnerClass() &#123; // 反射获取类的构造方法，通过newInstance() 获取对象会存在单例被破坏的问题 // 添加以下代码解决，强制不允许构建 if (SingletonHolder.INSTANCE != null) &#123; throw new RuntimeException("不允许创建多个实例"); &#125; &#125; public static LazySingletonInnerClass getInstance() &#123; return SingletonHolder.INSTANCE; &#125; private static class SingletonHolder &#123; private final static LazySingletonInnerClass INSTANCE = new LazySingletonInnerClass(); &#125; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; // 普通方式获取 LazySingletonInnerClass instance1 = LazySingletonInnerClass.getInstance(); // 反射方式获取 Class&lt;LazySingletonInnerClass&gt; clazz = LazySingletonInnerClass.class; Constructor&lt;LazySingletonInnerClass&gt; constructor = clazz.getDeclaredConstructor(null); // 设置访问级别，因为是private的 constructor.setAccessible(true); LazySingletonInnerClass instance2 = constructor.newInstance(); System.out.println("instance1 = " + instance1); System.out.println("instance2 = " + instance2); &#125;&#125; 2.3. 注册式单例 将每一个实例都缓存到统一的容器中，使用唯一标识获取实例 2.3.1. 枚举式单例（推荐写法） 123456789101112131415161718192021222324/** * &lt;p&gt; * 注册式单例，枚举实现，&#123;@code 推荐写法之一&#125; * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 19:35 */public enum RegisterSingletonEnum &#123; /** * 单例 */ INSTANCE; public static RegisterSingletonEnum getInstance() &#123; return INSTANCE; &#125; public static void main(String[] args) throws InterruptedException &#123; ConcurrentExecutor.execute(() -&gt; &#123; System.out.println("线程号: " + Thread.currentThread().getName() + "，" + RegisterSingletonEnum.getInstance()); &#125;, 10, 5); &#125;&#125; 2.3.2. 容器式单例 2.3.2.1. Spring式实现 12345678910111213141516171819202122232425262728293031323334353637383940/** * &lt;p&gt; * 注册式单例，容器实现，Spring 容器的实现 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 19:38 */public class RegisterSingletonContainer &#123; private static final Map&lt;String, Object&gt; BEAN_CACHE = new ConcurrentHashMap&lt;&gt;(); private RegisterSingletonContainer() &#123; &#125; public static Object getInstance(String className) &#123; synchronized (BEAN_CACHE) &#123; // 判断缓存是否存在 if (!BEAN_CACHE.containsKey(className)) &#123; // 构建对象，放在缓存 Class&lt;?&gt; aClass = null; try &#123; aClass = Class.forName(className); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; BEAN_CACHE.put(className, aClass); return aClass; &#125; else &#123; return BEAN_CACHE.get(className); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; ConcurrentExecutor.execute(() -&gt; &#123; Object instance = RegisterSingletonContainer.getInstance("com.xkcoding.design.pattern.creational.singleton.register.RegisterSingletonContainer"); System.out.println(System.currentTimeMillis() + " :: " + instance); &#125;, 10, 5); &#125;&#125; 2.3.2.2. ThreadLocal式单例 ThreadLocal式单例其实也属于 容器式单例，伪线程安全，保证线程内部全部唯一，同一线程内线程安全 1234567891011121314151617181920212223242526272829303132/** * &lt;p&gt; * 注册式单例，ThreadLocal实现，伪线程安全，保证线程内部全部唯一，同一线程内线程安全 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 19:55 */public class RegisterSingletonThreadLocal &#123; private static final ThreadLocal&lt;RegisterSingletonThreadLocal&gt; INSTANCE = ThreadLocal.withInitial(RegisterSingletonThreadLocal::new); private RegisterSingletonThreadLocal() &#123; &#125; public static RegisterSingletonThreadLocal getInstance() &#123; return INSTANCE.get(); &#125; /** * 测试可见，同一线程内单例，不同线程间非单例 */ public static void main(String[] args) throws InterruptedException &#123; System.out.println("线程号: " + Thread.currentThread().getName() + "，" + RegisterSingletonThreadLocal.getInstance()); System.out.println("线程号: " + Thread.currentThread().getName() + "，" + RegisterSingletonThreadLocal.getInstance()); System.out.println("线程号: " + Thread.currentThread().getName() + "，" + RegisterSingletonThreadLocal.getInstance()); System.out.println("线程号: " + Thread.currentThread().getName() + "，" + RegisterSingletonThreadLocal.getInstance()); ConcurrentExecutor.execute(() -&gt; &#123; System.out.println("线程号: " + Thread.currentThread().getName() + "，" + RegisterSingletonThreadLocal.getInstance()); &#125;, 10, 5); &#125;&#125; 3. 问题点 3.1. 反序列化破坏单例的情况 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * &lt;p&gt; * 饿汉式单例，测试反序列化被破坏的情况 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 20:11 */public class EagerSingleton3 implements Serializable &#123; private final static EagerSingleton3 INSTANCE = new EagerSingleton3(); private EagerSingleton3() &#123; &#125; public static EagerSingleton3 getInstance() &#123; return INSTANCE; &#125; /** * 重写 &#123;@code readResolve&#125; 方法，可解决反序列化单例破坏的场景 */ private Object readResolve() &#123; return INSTANCE; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; // 正常获取实例 EagerSingleton3 instance1 = EagerSingleton3.getInstance(); // 通过序列化获取 EagerSingleton3 instance2 = null; // 将 instance1 写出到文件 FileOutputStream fos = new FileOutputStream("EagerSingleton3.obj"); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(instance1); oos.flush(); oos.close(); // 读取文件到 instance2 FileInputStream fis = new FileInputStream("EagerSingleton3.obj"); ObjectInputStream ois = new ObjectInputStream(fis); instance2 = (EagerSingleton3) ois.readObject(); ois.close(); System.out.println(instance1); System.out.println(instance2); System.out.println(instance1 == instance2); &#125;&#125; 其实上面的代码已经给出答案了，重写 readResolve() 方法，将 INSTANCE 返回即可解决。 为什么重写 readResolve() 方法，将 INSTANCE 返回就可以解决这个单例被破坏的问题呢？跟一波源码看看 ~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// 1. 首先得明确 原因应该是反序列化为对象的时候 导致单例失败的// 所以跟踪一波 ois.readObject() 源码 -&gt; java.io.ObjectInputStream#readObject// 2. debug 可以发现，执行了 readObject0(false) 返回对象Object obj = readObject0(false);// 3. 继续跟踪 readObject0() 的源码 -&gt; java.io.ObjectInputStream#readObject0// 省略部分代码，只看下面的 switch 部分代码switch (tc) &#123; case TC_NULL: return readNull(); case TC_REFERENCE: return readHandle(unshared); case TC_CLASS: return readClass(unshared); case TC_CLASSDESC: case TC_PROXYCLASSDESC: return readClassDesc(unshared); case TC_STRING: case TC_LONGSTRING: return checkResolve(readString(unshared)); case TC_ARRAY: return checkResolve(readArray(unshared)); case TC_ENUM: return checkResolve(readEnum(unshared)); case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); case TC_EXCEPTION: IOException ex = readFatalException(); throw new WriteAbortedException("writing aborted", ex); case TC_BLOCKDATA: case TC_BLOCKDATALONG: if (oldMode) &#123; bin.setBlockDataMode(true); bin.peek(); // force header read throw new OptionalDataException( bin.currentBlockRemaining()); &#125; else &#123; throw new StreamCorruptedException( "unexpected block data"); &#125; case TC_ENDBLOCKDATA: if (oldMode) &#123; throw new OptionalDataException(true); &#125; else &#123; throw new StreamCorruptedException( "unexpected end of block data"); &#125; default: throw new StreamCorruptedException( String.format("invalid type code: %02X", tc));&#125;// debug可以发现反序列化的时候走的是case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared));// 4. 因此，继续跟踪源码 readOrdinaryObject(unshared) -&gt; java.io.ObjectInputStream#readOrdinaryObject// 省略部分代码obj = desc.isInstantiable() ? desc.newInstance() : null;// 这段代码里 desc.isInstantiable() 主要是判断类是否可以被序列化和反序列化，同时是否提供一个无参的构造方法// 这里显然为 true, 所以 obj = desc.newInstance()，这就意味着已经被新创建了一个对象// 5. 上面只是解释了为什么反序列化会破坏单例的情况，下面我们看看怎么解决// 接着看 java.io.ObjectInputStream#readOrdinaryObject 这个方法// 省略部分代码if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; // Filter the replacement object if (rep != null) &#123; if (rep.getClass().isArray()) &#123; filterCheck(rep.getClass(), Array.getLength(rep)); &#125; else &#123; filterCheck(rep.getClass(), -1); &#125; &#125; handles.setObject(passHandle, obj = rep); &#125;&#125;// 这里存在一个 if 的条件判断，desc.hasReadResolveMethod()// 满足条件的时候，Object rep = desc.invokeReadResolve(obj); // 如果 rep != obj 的时候呢，就把 rep 赋值给 obj， handles.setObject(passHandle, obj = rep);// 6. 看到这里，我们就得出一个结论：// 如果要是仍然保证单例，我们只要让 rep 返回的时候等于原先的对象覆盖给 obj 就可以实现单例了// 7. 所以这里的关键就是 desc.hasReadResolveMethod() 和 desc.invokeReadResolve(obj) 这两个方法了// 7.1. 那我们首先来看看 desc.hasReadResolveMethod() 这个方法boolean hasReadResolveMethod() &#123; requireInitialized(); return (readResolveMethod != null);&#125;// 这里就只是判断 readResolveMethod 这个是否为 null，那我们就来看看 readResolveMethod 这到底是个啥吧/** class-defined readResolve method, or null if none */private Method readResolveMethod;// 属性的声明说的很清楚，是一个名为 readResolve 的方法，但是返回值是啥呢，我们再找找，这个值不会凭空生成，要么是构造方法生成的时候放进去的，要么就是手动set的// 那我们就用快捷键 Command + B 看看这个属性在哪里被用到了吧// 不难发现，这是在 java.io.ObjectStreamClass#ObjectStreamClass(java.lang.Class&lt;?&gt;) 构造方法的时候，通过反射设置的// 省略部分代码readResolveMethod = getInheritableMethod(cl, "readResolve", null, Object.class);// 再看 java.io.ObjectStreamClass#getInheritableMethod(Class&lt;?&gt; cl, String name, Class&lt;?&gt;[] argTypes, Class&lt;?&gt; returnType) // readResolveMethod 就是 函数名为 readResolve，无参，返回值是 Object 的方法// 7.2. 再看看 desc.invokeReadResolve(obj) 这个方法 -&gt; java.io.ObjectStreamClass#invokeReadResolve// 这个方法就是反射调用 readResolveMethod 这个 Method 对象返回结果// 8. 到这儿，聪明的你应该知道怎么玩儿了吧，重写 readResolve 方法，返回 INSTANCE 完事~private Object readResolve() &#123; return INSTANCE;&#125; 注意哦，当我们使用枚举式单例的写法就不会出现这种情况，具体原因如下： 1234567// 还是走到 上面的 switch 分支，但是枚举式单例就会走case TC_ENUM: return checkResolve(readEnum(unshared));// 跟踪 java.io.ObjectInputStream#readEnum 源码可以发现// 省略部分代码Enum&lt;?&gt; en = Enum.valueOf((Class)cl, name);// 所以不会导致单例被破坏的情况~ 3.2. 反射破坏单例的情况 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * &lt;p&gt; * 懒汉式单例，内部类写法，&#123;@code 推荐写法之一&#125; * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-08-11 19:24 */public class LazySingletonInnerClass &#123; private LazySingletonInnerClass() &#123; // 反射获取类的构造方法，通过newInstance() 获取对象会存在单例被破坏的问题 // 添加以下代码解决，强制不允许构建 if (SingletonHolder.INSTANCE != null) &#123; throw new RuntimeException("不允许创建多个实例"); &#125; &#125; public static LazySingletonInnerClass getInstance() &#123; return SingletonHolder.INSTANCE; &#125; private static class SingletonHolder &#123; private final static LazySingletonInnerClass INSTANCE = new LazySingletonInnerClass(); &#125; public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; // 普通方式获取 LazySingletonInnerClass instance1 = LazySingletonInnerClass.getInstance(); // 反射方式获取 Class&lt;LazySingletonInnerClass&gt; clazz = LazySingletonInnerClass.class; Constructor&lt;LazySingletonInnerClass&gt; constructor = clazz.getDeclaredConstructor(null); // 设置访问级别，因为是private的 constructor.setAccessible(true); LazySingletonInnerClass instance2 = constructor.newInstance(); System.out.println("instance1 = " + instance1); System.out.println("instance2 = " + instance2); &#125;&#125; 其实上面的代码已经给出答案了，只需要在构造方法里判断当前实例是否已创建，已创建抛出运行时异常，即可解决。 4. 应用 1234567// 1. ServletContext// 2. ServletConfig// 3. ApplicationContext// 4. DBPool 5. 优缺点 优点： 在内存中只有一个实例，减少内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问 缺点： 没有接口，扩展困难；扩展单例对象，只能修改代码，不符合开闭原则 6. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/creational/singleton 测试代码里 ConcurrentExecutor 具体实现请看这里：https://github.com/xkcoding/design-pattern/blob/master/src/main/java/com/xkcoding/design/pattern/utils/ConcurrentExecutor.java]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之创建型设计模式-抽象工厂模式]]></title>
    <url>%2F2019%2F08%2F10%2Fdesign-pattern-abstract-factory.html</url>
    <content type="text"><![CDATA[1. 模式简介 提供一个创建一系列相关或者相互依赖对象的接口，无须指定具体的类，属于创建型设计模式。 2. 示例代码 产品抽象 1234567891011121314151617181920212223// 手机产品抽象类public abstract class Phone &#123; /** * 描述 */ public abstract void describe();&#125;// 笔记本产品抽象类public abstract class Laptop &#123; /** * 描述 */ public abstract void describe();&#125;// 耳机产品抽象类public abstract class EarPhone &#123; /** * 描述 */ public abstract void describe();&#125; 科技公司工厂抽象 1234567891011121314151617181920212223// 科技公司抽象工厂类public abstract class TechFactory &#123; /** * 卖手机 * * @return 手机 */ public abstract Phone sellPhone(); /** * 卖笔记本 * * @return 笔记本 */ public abstract Laptop sellLaptop(); /** * 卖耳机 * * @return 耳机 */ public abstract EarPhone sellEarPhone();&#125; 统一品牌产品的具体实现 / 科技公司的具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198// 小米品牌小米手机具体实现public class MiPhone extends Phone &#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("小米手机"); &#125;&#125;// 小米品牌小米笔记本具体实现public class MiLaptop extends Laptop&#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("小米笔记本"); &#125;&#125;// 小米品牌小米耳机具体实现public class MiEarPhone extends EarPhone &#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("小米耳机"); &#125;&#125;// 小米公司工厂具体实现public class MiTechCompany extends TechFactory &#123; /** * 卖手机 * * @return 手机 */ @Override public Phone sellPhone() &#123; return new MiPhone(); &#125; /** * 卖笔记本 * * @return 笔记本 */ @Override public Laptop sellLaptop() &#123; return new MiLaptop(); &#125; /** * 卖耳机 * * @return 耳机 */ @Override public EarPhone sellEarPhone() &#123; return new MiEarPhone(); &#125;&#125;// 华为品牌华为手机具体实现public class HuaweiPhone extends Phone &#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("华为手机"); &#125;&#125;// 华为品牌华为笔记本具体实现public class HuaweiLaptop extends Laptop&#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("华为笔记本"); &#125;&#125;// 华为品牌华为耳机具体实现public class HuaweiEarPhone extends EarPhone &#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("华为耳机"); &#125;&#125;// 华为公司工厂具体实现public class HuaweiTechCompany extends TechFactory &#123; /** * 卖手机 * * @return 手机 */ @Override public Phone sellPhone() &#123; return new HuaweiPhone(); &#125; /** * 卖笔记本 * * @return 笔记本 */ @Override public Laptop sellLaptop() &#123; return new HuaweiLaptop(); &#125; /** * 卖耳机 * * @return 耳机 */ @Override public EarPhone sellEarPhone() &#123; return new HuaweiEarPhone(); &#125;&#125;// 苹果品牌苹果手机具体实现public class IPhone extends Phone &#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("IPhone"); &#125;&#125;// 苹果品牌苹果笔记本具体实现public class MacBookPro extends Laptop&#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("MacBookPro"); &#125;&#125;// 苹果品牌苹果耳机具体实现public class AirPod extends EarPhone &#123; /** * 描述 */ @Override public void describe() &#123; System.out.println("AirPod"); &#125;&#125;// 苹果公司工厂具体实现public class AppleTechCompany extends TechFactory &#123; /** * 卖手机 * * @return 手机 */ @Override public Phone sellPhone() &#123; return new IPhone(); &#125; /** * 卖笔记本 * * @return 笔记本 */ @Override public Laptop sellLaptop() &#123; return new MacBookPro(); &#125; /** * 卖耳机 * * @return 耳机 */ @Override public EarPhone sellEarPhone() &#123; return new AirPod(); &#125;&#125; 3. UML图例 4. 应用 12// Spring 源码// AbstractBeanFactory -&gt; AbstractAutowireCapableBeanFactory / DefaultListableBeanFactory / XmlBeanFactory 5. 场景 客户端不依赖产品类，不关注创建、实现的细节 强调一系列产品对象（产品族），一起创建时需要大量创建代码 提供一类产品的库，所有的产品以同样的接口出现，从而使客户端不依赖具体实现 6. 优缺点 优点： 具体产品在应用层代码隔离，不关心创建细节；将一系列的产品族对象统一在一起创建 缺点： 添加一种新的产品的时候，需要在工厂接口及其工厂子类都添加实现，不符合开闭原则；增加了系统的抽象性和理解难度 7. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/creational/abstractfactory]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JustAuth集成企业微信]]></title>
    <url>%2F2019%2F08%2F06%2Fuse-justauth-integration-wechat-enterprise.html</url>
    <content type="text"><![CDATA[JustAuth 又㕛叒叕添加新平台啦~ 此次更新带来的是 企业微信，本文将带领大家使用 JustAuth 快速集成 企业微信 的第三方登录。 1. 注册并登录企业微信 地址：https://work.weixin.qq.com/wework_admin/loginpage_wx?from=myhome_openApi 如果没有企业可以点击 企业注册 2. 创建企业微信应用 导航栏 – 应用管理 – 自建 – 创建应用 选择合适的应用logo，为应用取个名，同时设置应用的可见范围，创建应用 3. 应用设置及基本关键参数 3.1. 应用设置 创建完应用之后，拖到应用最下方，配置应用信息 使用 JustAuth 基本都是网页应用，所以这一步我们直接选择 Web网页 – 设置授权回调域 注意：这里 授权回调域 不需要指定 前缀，后缀 等信息，示例如下图 关于授权回调域存在疑问的童鞋请看这里：https://open.work.weixin.qq.com/api/doc#90000/90135/90988 3.2. 基本关键参数获取 使用 JustAuth 进行企业微信登录需要 4 个参数信息：client-id、client-secret、redirect-uri、agent-id 3.2.1. agent-id 及 client-secret 信息 agent-id 和 client-secret这两个信息均在 应用管理 里可以查看 3.2.2. client-id 信息 client-id 信息在 我的企业 中可以找到，该信息即 企业ID 3.2.3. redirect-uri 信息 回调地址是根据我们前面配置的 授权回调域 来的，我设置的是 oauth.xkcoding.com ，项目里我的回调地址指定为 http://oauth.xkcoding.com/demo/oauth/wechat_enterprise/callback 4. 开发 4.1. 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;justauth-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.0.3-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 4.2. 修改配置文件 12345678justauth: enabled: true type: WECHAT_ENTERPRISE: client-id: ww58**********6fbc client-secret: 8G6PCr0****************************yzaPc78 redirect-uri: http://oauth.xkcoding.com/demo/oauth/wechat_enterprise/callback agent-id: 10*******02 4.3. 编写 Controller 代码 123456789101112131415161718192021222324252627282930313233343536373839404142/** * &lt;p&gt; * 测试 Controller * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-07-22 11:17 */@Slf4j@RestController@RequestMapping("/oauth")@RequiredArgsConstructor(onConstructor_ = @Autowired)public class TestController &#123; private final AuthRequestFactory factory; @GetMapping public List&lt;String&gt; list() &#123; return factory.oauthList(); &#125; @GetMapping("/login/&#123;type&#125;") public void login(@PathVariable String type, HttpServletResponse response) throws IOException &#123; AuthRequest authRequest = factory.get(getAuthSource(type)); response.sendRedirect(authRequest.authorize(AuthStateUtils.createState())); &#125; @RequestMapping("/&#123;type&#125;/callback") public AuthResponse login(@PathVariable String type, AuthCallback callback) &#123; AuthRequest authRequest = factory.get(getAuthSource(type)); AuthResponse response = authRequest.login(callback); log.info("【response】= &#123;&#125;", JSONUtil.toJsonStr(response)); return response; &#125; private AuthSource getAuthSource(String type) &#123; if (StrUtil.isNotBlank(type)) &#123; return AuthSource.valueOf(type.toUpperCase()); &#125; else &#123; return null; &#125; &#125;&#125; 代码地址：https://github.com/xkcoding/justauth-spring-boot-starter-demo 5. 效果演示 果然！ 不得不说：whnb.wang 参考 企业微信文档地址：https://open.work.weixin.qq.com/api/doc#90000/90135/90664 获取AccessToken：https://open.work.weixin.qq.com/api/doc#90000/90135/91039 构建登录二维码：https://open.work.weixin.qq.com/api/doc#90000/90135/91019 获取用户身份：https://open.work.weixin.qq.com/api/doc#90000/90135/91437 用户身份详细信息：https://open.work.weixin.qq.com/api/doc#90000/90135/90196]]></content>
      <categories>
        <category>开源</category>
        <category>JustAuth</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>开源</tag>
        <tag>JustAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JFinal 快速集成第三方登录功能]]></title>
    <url>%2F2019%2F07%2F17%2Fjfinal-login-with-oauth.html</url>
    <content type="text"><![CDATA[前言 > 此 demo 主要为了演示 Jfinal 如何通过 JustAuth 快速集成第三方平台的登录，如果有小伙伴是基于 Spring Boot 的可以参考这个 [**` demo`**](https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-social) > > https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-social 1. 环境准备 参考 Spring Boot 快速集成第三方登录功能 - 环境准备 这一章 2. 主要代码 2.1. pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;jfinal-justauth-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;jfinal-justauth-demo&lt;/name&gt; &lt;description&gt; JFinal 使用 JustAuth 快速集成第三方登录 &lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;justauth.version&gt;1.9.5&lt;/justauth.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.jfinal&lt;/groupId&gt; &lt;artifactId&gt;jfinal-undertow&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jfinal&lt;/groupId&gt; &lt;artifactId&gt;jfinal&lt;/artifactId&gt; &lt;version&gt;4.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;4.5.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;me.zhyd.oauth&lt;/groupId&gt; &lt;artifactId&gt;JustAuth&lt;/artifactId&gt; &lt;version&gt;$&#123;justauth.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;jfinal-justauth-demo&lt;/finalName&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 2.2. DemoConfig.java 此类为 JFinal 的配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * &lt;p&gt; * 配置类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-07-16 14:19 */public class DemoConfig extends JFinalConfig &#123; /** * 配置环境基础信息 */ @Override public void configConstant(Constants constants) &#123; // 设置开发模式，打印请求日志 constants.setDevMode(true); &#125; /** * 配置路由信息 */ @Override public void configRoute(Routes routes) &#123; routes.add("/demo/test", TestController.class); routes.add("/demo/oauth", OauthController.class); &#125; /** * 配置模板引擎相关 */ @Override public void configEngine(Engine engine) &#123; &#125; /** * 配置插件相关 */ @Override public void configPlugin(Plugins plugins) &#123; &#125; /** * 配置拦截器相关 */ @Override public void configInterceptor(Interceptors interceptors) &#123; &#125; @Override public void configHandler(Handlers handlers) &#123; &#125;&#125; 2.3. OauthController.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * &lt;p&gt; * Oauth Controller * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-07-16 14:39 */public class OauthController extends Controller &#123; // 加载配置文件 static &#123; PropKit.use("oauth.properties"); &#125; public void index() &#123; // @formatter:off Dict dictType = Dict.create() .set("QQ登录", "http://oauth.xkcoding.com/demo/oauth/login/qq") .set("GitHub登录", "http://oauth.xkcoding.com/demo/oauth/login/github") .set("小米登录", "http://oauth.xkcoding.com/demo/oauth/login/mi"); // @formatter:on renderJson(dictType); &#125; /** * 参数获取参考：https://www.jfinal.com/doc/3-4 * Jfinal 中路径参数只能取最后一个，分隔符默认为 - 比如 /demo/para0-para1-para2 * 此时可通过 getPara(0) -&gt; para0 ; getPara(1) -&gt; para1 ; getPara(2) -&gt; para2 */ public void login() &#123; String oauthType = getPara(0); AuthRequest authRequest = getAuthRequest(oauthType); redirect(authRequest.authorize(AuthStateUtils.createState())); &#125; /** * 登录成功后的回调 * 坑点: 因为Jfinal不支持 /&#123;oauthType&#125;/callback 这种格式的URL，因此回调地址修改如下 /callback/&#123;oauthType&#125; * * @param callback 携带返回的信息 */ public void callback(@Para("") AuthCallback callback) &#123; String oauthType = getPara(0); AuthRequest authRequest = getAuthRequest(oauthType); AuthResponse response = authRequest.login(callback); renderJson(response); &#125; private AuthRequest getAuthRequest(String oauthType) &#123; AuthSource authSource = AuthSource.valueOf(oauthType.toUpperCase()); switch (authSource) &#123; case QQ: return getQqAuthRequest(); case GITHUB: return getGithubAuthRequest(); case MI: return getMiAuthRequest(); default: throw new RuntimeException("暂不支持的第三方登录"); &#125; &#125; private AuthRequest getQqAuthRequest() &#123; AuthConfig authConfig = AuthConfig.builder().clientId(PropKit.get("qq.clientId")).clientSecret(PropKit.get("qq.clientSecret")).redirectUri(PropKit.get("qq.redirectUri")).build(); return new AuthQqRequest(authConfig); &#125; private AuthRequest getGithubAuthRequest() &#123; AuthConfig authConfig = AuthConfig.builder().clientId(PropKit.get("github.clientId")).clientSecret(PropKit.get("github.clientSecret")).redirectUri(PropKit.get("github.redirectUri")).build(); return new AuthGithubRequest(authConfig); &#125; private AuthRequest getMiAuthRequest() &#123; AuthConfig authConfig = AuthConfig.builder().clientId(PropKit.get("mi.clientId")).clientSecret(PropKit.get("mi.clientSecret")).redirectUri(PropKit.get("mi.redirectUri")).build(); return new AuthMiRequest(authConfig); &#125;&#125; 2.4. oauth.properties 1234567891011qq.clientId=10********85qq.clientSecret=1f7********************629eqq.redirectUri=http://oauth.xkcoding.com/demo/oauth/callback/qqgithub.clientId=2***************916github.clientSecret=e4e8cb602c87cf**********************a6f095bgithub.redirectUri=http://oauth.xkcoding.com/demo/oauth/callback/githubmi.clientId=288****************994mi.clientSecret=nFe****************=mi.redirectUri=http://oauth.xkcoding.com/demo/oauth/callback/mi 2.5. DemoApplication.java 12345678910111213/** * &lt;p&gt; * 启动类 * &lt;/p&gt; * * @author yangkai.shen * @date Created in 2019-07-16 14:18 */public class DemoApplication &#123; public static void main(String[] args) &#123; UndertowServer.start(DemoConfig.class, 8080, true); &#125;&#125; 3. 运行方式 打开浏览器，输入 http://oauth.xkcoding.com/demo/oauth ，点击各个登录方式自行测试。 参考 Spring Boot快速集成第三方登录功能：https://xkcoding.com/2019/05/22/spring-boot-login-with-oauth.html JFinal官方文档：https://www.jfinal.com/doc JustAuth 项目地址：https://github.com/zhangyd-c/JustAuth QQ互联文档：http://wiki.connect.qq.com/准备工作_oauth2-0 GitHub第三方登录文档：https://developer.github.com/apps/building-oauth-apps/ 小米开放平台账号服务文档：https://dev.mi.com/console/doc/detail?pId=707]]></content>
      <categories>
        <category>开源</category>
        <category>JustAuth</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>JustAuth</tag>
        <tag>JFinal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot快速集成第三方登录功能]]></title>
    <url>%2F2019%2F05%2F22%2Fspring-boot-login-with-oauth.html</url>
    <content type="text"><![CDATA[前言 > 此 demo 主要演示 Spring Boot 项目如何使用 **[史上最全的第三方登录工具 - JustAuth](https://github.com/zhangyd-c/JustAuth)** 实现第三方登录，包括QQ登录、GitHub登录、微信登录、谷歌登录、微软登录、小米登录、企业微信登录。 > > 通过 [justauth-spring-boot-starter](https://search.maven.org/artifact/com.xkcoding/justauth-spring-boot-starter) 快速集成，好嗨哟~ > > JustAuth，如你所见，它仅仅是一个**第三方授权登录**的**工具类库**，它可以让我们脱离繁琐的第三方登录SDK，让登录变得**So easy!** > > 1. **全**：已集成十多家第三方平台（国内外常用的基本都已包含），后续依然还有扩展计划！ >2. **简**：API就是奔着最简单去设计的（见后面[`快速开始`](https://github.com/zhangyd-c/JustAuth#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B)），尽量让您用起来没有障碍感！ > > PS: 本人十分幸运的参与到了这个SDK的开发，主要开发了**QQ登录、微信登录、小米登录、微软登录、谷歌登录**这 **`5`** 个第三方登录，以及一些BUG的修复工作。再次感谢 [@母狼](https://github.com/zhangyd-c) 开源这个又好用又全面的第三方登录SDK。 如果技术选型是 JFinal 的，请查看此 demo https://github.com/xkcoding/jfinal-justauth-demo 如果技术选型是 ActFramework 的，请查看此 demo https://github.com/xkcoding/act-justauth-demo 1. 环境准备 1.1. 公网服务器准备 首先准备一台有公网IP的服务器，可以选用阿里云或者腾讯云，如果选用的是阿里云的，可以使用我的优惠链接购买。 1.2. 内网穿透frp搭建 frp 安装程序：https://github.com/fatedier/frp/releases 1.2.1. frp服务端搭建 服务端搭建在上一步准备的公网服务器上，因为服务器是centos7 x64的系统，因此，这里下载安装包版本为linux_amd64的 frp_0.27.0_linux_amd64.tar.gz 。 下载安装包 1$ wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_linux_amd64.tar.gz 解压安装包 1$ tar -zxvf frp_0.27.0_linux_amd64.tar.gz 修改配置文件 123456$ cd frp_0.27.0_linux_amd64$ vim frps.ini[common] bind_port = 7100 vhost_http_port = 7200 启动frp服务端 1234$ ./frps -c frps.ini2019/06/15 16:42:02 [I] [service.go:139] frps tcp listen on 0.0.0.0:71002019/06/15 16:42:02 [I] [service.go:181] http service listen on 0.0.0.0:72002019/06/15 16:42:02 [I] [root.go:204] Start frps success 1.2.2. frp客户端搭建 客户端搭建在本地的Mac上，因此下载安装包版本为darwin_amd64的 frp_0.27.0_darwin_amd64.tar.gz 。 下载安装包 1$ wget https://github.com/fatedier/frp/releases/download/v0.27.0/frp_0.27.0_darwin_amd64.tar.gz 解压安装包 1$ tar -zxvf frp_0.27.0_darwin_amd64.tar.gz 修改配置文件，配置服务端ip端口及监听的域名信息 1234567891011$ cd frp_0.27.0_darwin_amd64$ vim frpc.ini[common]server_addr = 120.92.169.103server_port = 7100[web]type = httplocal_port = 8080custom_domains = oauth.xkcoding.com 启动frp客户端 1234$ ./frpc -c frpc.ini2019/06/15 16:48:52 [I] [service.go:221] login to server success, get run id [8bb83bae5c58afe6], server udp port [0]2019/06/15 16:48:52 [I] [proxy_manager.go:137] [8bb83bae5c58afe6] proxy added: [web]2019/06/15 16:48:52 [I] [control.go:144] [web] start proxy success 1.3. 配置域名解析 前往阿里云DNS解析，将域名解析到我们的公网服务器上，比如我的就是将 oauth.xkcoding.com -&gt; 120.92.169.103 1.4. nginx代理 nginx 的搭建就不在此赘述了，只说配置 1234567891011121314151617181920212223server &#123; listen 80; server_name oauth.xkcoding.com; location / &#123; proxy_pass http://127.0.0.1:7200; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_buffering off; sendfile off; proxy_max_temp_file_size 0; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_temp_file_write_size 64k; proxy_http_version 1.1; proxy_request_buffering off; &#125;&#125; 测试配置文件是否有问题 123$ nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 重新加载配置文件，使其生效 1$ nginx -s reload 现在当我们在浏览器输入 oauth.xkcoding.com 的时候，网络流量其实会经历以下几个步骤： 通过之前配的DNS域名解析会访问到我们的公网服务器 120.92.169.103 的 80 端口 再经过 nginx，代理到本地的 7200 端口 再经过 frp 穿透到我们的 Mac 电脑的 8080 端口 此时 8080 就是我们的应用程序端口 1.5. 第三方平台申请 1.5.1. QQ互联平台申请 前往 https://connect.qq.com/ 申请开发者 应用管理 -&gt; 添加网站应用，等待审核通过即可 1.5.2. GitHub平台申请 前往 https://github.com/settings/developers 点击 New OAuth App 按钮创建应用 1.5.3 微信开放平台申请 这里微信开放平台需要用企业的，个人没有资质，所以我在某宝租了一个月的资质，需要的可以 戳我租赁 声明：本人与该店铺无利益相关，纯属个人觉得好用做分享 该店铺有两种方式： 店铺支持帮你过企业资质，这里就用你自己的开放平台号就好了 临时使用可以问店家租一个月进行开发，这里租了之后，店家会把 AppID 和 AppSecret 的信息发给你，你提供回调域就好了 因此这里我就贴出一张授权回调的地址作参考。 1.5.4. 谷歌开放平台申请 前往 https://console.developers.google.com/projectcreate 创建项目 前往 https://console.developers.google.com/apis/credentials ，在第一步创建的项目下，添加应用 1.5.5. 微软开放平台申请 前往 https://portal.azure.com/#blade/Microsoft_AAD_RegisteredApps/ApplicationsListBlade 注册应用 在注册应用的时候就需要填写回调地址，当然后期也可以重新修改 client id 在这里 client secret 需要自己在这里生成 1.5.6. 小米开放平台申请 申请小米开发者，审核通过 前往 https://dev.mi.com/passport/oauth2/applist 添加oauth应用，选择 创建网页应用 填写基本信息之后，进入应用信息页面填写 回调地址 应用审核通过之后，可以在应用信息页面的 应用详情 查看到 AppKey 和 AppSecret，吐槽下，小米应用的审核速度特别慢，需要耐心等待。。。。 1.5.7. 企业微信平台申请 参考：https://xkcoding.com/2019/08/06/use-justauth-integration-wechat-enterprise.html 2. 主要代码 代码地址：https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-social 本 demo 采用 Redis 缓存 state，所以请准备 Redis 环境，如果没有 Redis 环境，可以将配置文件的缓存配置为 1234&gt; justauth:&gt; cache:&gt; type: default&gt; 2.1. pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;spring-boot-demo-social&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-demo-social&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-demo&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;justauth-spring-boot.version&gt;1.1.0&lt;/justauth-spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 对象池，使用redis时必须引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- oauth工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;justauth-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;justauth-spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-boot-demo-social&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.2. application.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162server: port: 8080 servlet: context-path: /demospring: redis: host: localhost # 连接超时时间（记得添加单位，Duration） timeout: 10000ms # Redis默认情况下有16个分片，这里配置具体使用的分片 # database: 0 lettuce: pool: # 连接池最大连接数（使用负值表示没有限制） 默认 8 max-active: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1 max-wait: -1ms # 连接池中的最大空闲连接 默认 8 max-idle: 8 # 连接池中的最小空闲连接 默认 0 min-idle: 0 cache: # 一般来说是不用配置的，Spring Cache 会根据依赖的包自行装配 type: redisjustauth: enabled: true type: qq: client-id: 10******85 client-secret: 1f7d************************d629e redirect-uri: http://oauth.xkcoding.com/demo/oauth/qq/callback github: client-id: 2d25******d5f01086 client-secret: 5a2919b************************d7871306d1 redirect-uri: http://oauth.xkcoding.com/demo/oauth/github/callback wechat: client-id: wxdcb******4ff4 client-secret: b4e9dc************************a08ed6d redirect-uri: http://oauth.xkcoding.com/demo/oauth/wechat/callback google: client-id: 716******17-6db******vh******ttj320i******userco******t.com client-secret: 9IBorn************7-E redirect-uri: http://oauth.xkcoding.com/demo/oauth/google/callback microsoft: client-id: 7bdce8******************e194ad76c1b client-secret: Iu0zZ4************************tl9PWan_. redirect-uri: https://oauth.xkcoding.com/demo/oauth/microsoft/callback mi: client-id: 288************2994 client-secret: nFeTt89************************== redirect-uri: http://oauth.xkcoding.com/demo/oauth/mi/callback wechat_enterprise: client-id: ww58******f3************fbc client-secret: 8G6PCr00j************************rgk************AyzaPc78 redirect-uri: http://oauth.xkcoding.com/demo/oauth/wechat_enterprise/callback agent-id: 1*******2 cache: type: redis prefix: 'SOCIAL::STATE::' timeout: 1h 2.3. OauthController.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * &lt;p&gt; * 第三方登录 Controller * &lt;/p&gt; * * @package: com.xkcoding.oauth.controller * @description: 第三方登录 Controller * @author: yangkai.shen * @date: Created in 2019-05-17 10:07 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Slf4j@RestController@RequestMapping("/oauth")@RequiredArgsConstructor(onConstructor_ = @Autowired)public class OauthController &#123; private final AuthRequestFactory factory; /** * 登录类型 */ @GetMapping public Map&lt;String, String&gt; loginType() &#123; List&lt;String&gt; oauthList = factory.oauthList(); return oauthList.stream().collect(Collectors.toMap(oauth -&gt; oauth.toLowerCase() + "登录", oauth -&gt; "http://oauth.xkcoding.com/demo/oauth/login/" + oauth.toLowerCase())); &#125; /** * 登录 * * @param oauthType 第三方登录类型 * @param response response * @throws IOException */ @RequestMapping("/login/&#123;oauthType&#125;") public void renderAuth(@PathVariable String oauthType, HttpServletResponse response) throws IOException &#123; AuthRequest authRequest = factory.get(getAuthSource(oauthType)); response.sendRedirect(authRequest.authorize(oauthType + "::" + AuthStateUtils.createState())); &#125; /** * 登录成功后的回调 * * @param oauthType 第三方登录类型 * @param callback 携带返回的信息 * @return 登录成功后的信息 */ @RequestMapping("/&#123;oauthType&#125;/callback") public AuthResponse login(@PathVariable String oauthType, AuthCallback callback) &#123; AuthRequest authRequest = factory.get(getAuthSource(oauthType)); AuthResponse response = authRequest.login(callback); log.info("【response】= &#123;&#125;", JSONUtil.toJsonStr(response)); return response; &#125; private AuthSource getAuthSource(String type) &#123; if (StrUtil.isNotBlank(type)) &#123; return AuthSource.valueOf(type.toUpperCase()); &#125; else &#123; throw new RuntimeException("不支持的类型"); &#125; &#125;&#125; 2.4. 如果想要自定义 state 缓存 请看👉这里 3. 运行方式 打开浏览器，输入 http://oauth.xkcoding.com/demo/oauth ，点击各个登录方式自行测试。 Google 登录，有可能因为祖国的强大导致测试失败，自行解决~ 😙 参考 JustAuth 项目地址：https://github.com/justauth/JustAuth justauth-spring-boot-starter 地址：https://github.com/justauth/justauth-spring-boot-starter frp内网穿透项目地址：https://github.com/fatedier/frp frp内网穿透官方中文文档：https://github.com/fatedier/frp/blob/master/README_zh.md Frp实现内网穿透：https://zhuanlan.zhihu.com/p/45445979 QQ互联文档：http://wiki.connect.qq.com/准备工作_oauth2-0 微信开放平台文档：https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419316505&amp;token=&amp;lang=zh_CN GitHub第三方登录文档：https://developer.github.com/apps/building-oauth-apps/ 谷歌Oauth2文档：https://developers.google.com/identity/protocols/OpenIDConnect 微软Oauth2文档：https://docs.microsoft.com/zh-cn/graph/auth-v2-user 小米开放平台账号服务文档：https://dev.mi.com/console/doc/detail?pId=707]]></content>
      <categories>
        <category>开源</category>
        <category>JustAuth</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>开源</tag>
        <tag>JustAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Vagrant快速搭建Centos/7虚拟机]]></title>
    <url>%2F2019%2F04%2F24%2Fuse-vagrant-build-linux-virtual-machine.html</url>
    <content type="text"><![CDATA[前言 日常开发过程中，为了保证开发环境的统一并且又不想污染我们本机的环境，通常我们有 2 种方式可以做到，一种是状态火热的docker虚拟化技术，另一种就是我们经久不衰的虚拟机了。本文介绍在 Mac 下使用 Vagrant 快速搭建Centos7 虚拟机。 1. 什么是 Vagrant 1.1. Vagrant 简介 什么是 Vagrant，要回答这个问题，最好的答案应该来自官网(https://www.vagrantup.com/intro/index.html) Vagrant is a tool for building and managing virtual machine environments in a single workflow. With an easy-to-use workflow and focus on automation, Vagrant lowers development environment setup time, increases production parity, and makes the “works on my machine” excuse a relic of the past. 翻译：Vagrant 是一个在单个工作流中实现构建和管理虚拟机环境的工具。通过一种简单易用的工作流并专注于自动化，Vagrant 减少了开发环境的配置时间，提高了生产效率，也正因为 Vagrant 的存在，使得『这个在我的电脑可以运行』这种借口成为过去。 官网的简介，我们简单的总结一下：Vagrant 是一个可以快速构建并管理虚拟机的工具。 1.2. Vagrant 优势 配置简单，避免相同环境重复配置，仅需共享一个 Vagrantfile 即可快速搭建一个相同配置的虚拟机。 一处配置，多端运行，不受系统环境影响，Linux / Mac OS X / Windows 启用命令一致。 安装简单，卸载干净。安装虚拟机，只会在当前 Vagrantfile 目录生成少数的缓存文件，卸载时可以卸载的干干净净，丝毫不污染宿主机环境。 支持多种 provider，便于用户自行选择 provider 去挂载虚拟机，包括：VirtualBox，VMware，AWS，Docker 等。 2. 安装 Vagrant 2.1. 环境准备 安装 provider，主要用于挂载虚拟机。本文将采用开源免费的 VirtualBox 作为 Vagrant 的 provider 来挂载我们的虚拟机。VirtualBox 是一款开源免费的虚拟机软件，相比 VMware 体系的软件来说，更加 小巧（主要是 免费）。 下载地址：https://www.virtualbox.org/wiki/Downloads 笔者使用的 VirtualBox 版本是 6.0.6 。 安装方式是傻瓜式安装，只需要选择好对应系统的版本，下一步操作即可。 2.2. 安装 Vagrant 主角登场，接下来我们来安装 Vagrant。 下载地址：https://www.vagrantup.com/downloads.html 笔者使用的 Vagrant 版本是 2.2.4 。 安装方式和 VirtualBox 一样，同样是傻瓜式安装，只需要选择好对应系统的版本，下一步操作即可。 安装完成之后，前往 Terminal 执行命令验证是否安装成功： 12345$ vagrant versionInstalled Version: 2.2.4Latest Version: 2.2.4You're running an up-to-date version of Vagrant! 3. Vagrant 命令 1234567891011121314151617vagrant init &lt;名称&gt; # 初始化box的操作vagrant box add &lt;虚拟机名&gt; &lt;box文件名&gt; # 添加box的操作vagrant up # 启动虚拟机的操作vagrant ssh &lt;hostname&gt; # 登录拟机的操作，也可以指定hostname登陆vagrant box list # 显示当前已经添加的box列表vagrant box remove 名称 # 删除相应的box vagrant destroy # 停止当前正在运行的虚拟机并销毁所有创建的资源vagrant halt # 关机vagrant status &lt;hostname&gt; # 获取当前虚拟机的状态，也可以查看指定hostnamevagrant suspend # 挂起当前的虚拟机vagrant resume # 恢复前面被挂起的状态vagrant reload # 重新启动虚拟机，主要用于重新载入配置文件vagrant global-status # 查看所有虚拟机的ID号vagrant plugin # 用于安装卸载插件vagrant ssh-config # 输出用于ssh连接的一些信息vagrant package # 打包命令，可以把当前的运行的虚拟机环境进行打包vagrant ssh-config # 查看ssh登录信息，可以把这些信息 保存到.ssh文件下config中，先用vagrant ssh 登录，然后把宿主机的ssh公钥保存到虚拟机的authorized_keys文件里，然后在宿主机ssh &lt;名称&gt;就可以免密码登录 4. Vagrant 实战 本小节我们完成一个实战，使用 Vagrant 安装 centos7。 4.1. 寻找box box 就是我们系统的初始化镜像，我们可以在 http://www.vagrantbox.es/ 找到我们需要的系统镜像 建议大家去给这个仓库点个 Star，方便好用的东西永远值得表扬! 附上仓库链接：https://github.com/garethr/vagrantboxes-heroku 。 理论上这里能搜到的 box，都可以在下面的初始化中直接使用 init 命令直接初始化。（但是国内的网络会导致经常失败。） 因此我们可以拷贝上面的 box 链接，先单独下载，再进行安装。 假设我们的 box 下载地址为：/Users/yangkai.shen/Downloads/vagrant-images/CentOS-7-x86_64-Vagrant-1803_01.VirtualBox.box 打开 Terminal，输入如下命令： 12345$ vagrant box add centos/7 /Users/yangkai.shen/Downloads/vagrant-images/CentOS-7-x86_64-Vagrant-1803_01.VirtualBox.box==&gt; box: Box file was not detected as metadata. Adding it directly...==&gt; box: Adding box 'centos/7' (v0) for provider: box: Unpacking necessary files from: file:///Users/yangkai.shen/Downloads/vagrant-images/CentOS-7-x86_64-Vagrant-1803_01.VirtualBox.box==&gt; box: Successfully added box 'centos/7' (v0) for 'virtualbox'! 这样，我们就可以使用我们添加的 box 进行初始化了。 4.2. 初始化 我们创建一个目录 centos7，然后在 Terminal 中进入该目录，然后执行初始化命令。 12345$ vagrant init centos/7A `Vagrantfile` has been placed in this directory. You are nowready to `vagrant up` your first virtual environment! Please readthe comments in the Vagrantfile as well as documentation on`vagrantup.com` for more information on using Vagrant. 此时会发现 centos7 目录下已经创建了一个 Vagrantfile，里面已经包含了默认的配置。 4.3. 安装 / 启动 在 Terminal 中输入如下命令，即可进行自动安装虚拟机： 1$ vagrant up 等待几分钟，即可安装成功。 4.4. 登录 在 Terminal 中执行如下命令： 1$ vagrant ssh 就会登录到虚拟机的 bash 中，非常方便。 这里需要注意，windows用户直接使用cmd命令不能使用ssh，建议使用 git-bash.exe 进行操作 5. Vagrant 高阶操作 5.1. 共享宿主机文件夹 实现共享文件夹，首先我们必须先安装一个 Vagrant 插件：vagrant-vbguest，打开 Terminal 输入以下命令安装： 12345$ vagrant plugin install vagrant-vbguestInstalling the 'vagrant-vbguest' plugin. This can take a few minutes...Fetching: micromachine-2.0.0.gem (100%)Fetching: vagrant-vbguest-0.17.2.gem (100%)Installed the plugin 'vagrant-vbguest (0.17.2)'! 安装成功后，我们只需要在 Vagrantfile 中配置共享文件夹，参考如下： 123# 第一个参数是宿主机文件夹地址# 第二个参数是虚拟机中映射过去的虚拟文件夹地址config.vm.synced_folder "../data", "/vagrant_data" 5.2. 网络代理配置 这里我们总共有 3 个步骤实现网络代理： 5.2.1. 安装插件 实现网络代理，首先我们必须先安装一个 Vagrant 插件：vagrant-proxyconf，打开 Terminal 输入以下命令安装： 1234$ vagrant plugin install vagrant-proxyconfInstalling the 'vagrant-proxyconf' plugin. This can take a few minutes...Fetching: vagrant-proxyconf-2.0.1.gem (100%)Installed the plugin 'vagrant-proxyconf (2.0.1)'! 5.2.2. 配置宿主机固定 IP 注意：这里我们是对 VirtualBox 全局设置，前往不要仅对某一台虚拟机设置了，这样的好处是所有的虚拟机都会绑定上我们配置的网卡信息。 安装成功后，我们还需要拿到宿主机的一个固定 IP，显然这个 IP 需要在我们切换网络环境的时候，仍然保证固定不变。此时我们可以通过 VirtualBox 自带的一个小技巧实现~ 打开 VirtualBox，找到左上角 『工具』右侧的小图标，点击该图标，选择『网络』，可以看到如下界面： 可以看到网卡列表里存在网卡信息，如果不存在，可以自己手动创建。这里网卡信息里的必须选择『手动配置网卡』。我们可以从虚拟机中访问宿主机的固定IP就是这里的IPv4地址。 5.2.3. 配置 Vagrantfile 最后，我们需要在 Vagrantfile 中配置代理，参考如下： 12345if Vagrant.has_plugin?("vagrant-proxyconf") config.proxy.http = "http://192.168.205.1:1087/" config.proxy.https = "http://192.168.205.1:1087/" config.proxy.no_proxy = "localhost,127.0.0.1"end 这样启动虚拟机之后，我们的网络请求都会通过我们宿主机的 1087 端口代理出去。 5.3. 安装后系统环境配置 Vagrant 可以在虚拟机安装之后，使用 shell 命令对系统环境做一些初始化配置，我们可以在 Vagrantfile 中配置。 Vagrant 支持 2 种方式执行 shell，第一种方式是直接在 Vagrantfile 中写 shell 命令，如下： 1234config.vm.provision "shell", privileged: true, inline: &lt;&lt;-SHELL apt-get update apt-get install -y apache2SHELL 第二种方式，支持引用外部 shell 脚本，如下： 1config.vm.provision "shell", privileged: true, path: "./setup.sh" 5.4. 如何配置聚群化环境 5.4.1. 设置硬件参数 设置虚拟机内存大小和CPU核数，在 Vagrantfile 中配置如下信息即可： 1234config.vm.provider "virtualbox" do |v| v.customize ["modifyvm", :id, "--memory", "1024"] v.customize ["modifyvm", :id, "--cpus", "1"]end 5.4.2. 设置hostname 在 Vagrantfile 中配置如下信息即可： 1config.vm.hostname = "master1" 5.4.3. 设置静态IP 在 Vagrantfile 中配置如下信息即可： 1config.vm.network "private_network", ip: "192.168.205.10" 5.5. 可用插件 从上面的 共享宿主机文件夹、网络代理 等高阶操作，我们可以发现，Vagrant 拥有丰富的插件可以帮助我们完成很多个性化需求，对于这些插件，官方提供了一个地址，专门整理了大量的 Vagrant 插件。 插件列表地址：https://github.com/hashicorp/vagrant/wiki/Available-Vagrant-Plugins 6. Vagrantfile 案例 本小节，我们展示一个 Vagrantfile 启动 3 台虚拟机节点，设置好硬件信息、安装docker、并设置开机启动，同时开启代理配置。 Vagrantfile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- mode: ruby -*-# vi: set ft=ruby :# 设置虚拟机配置，包括hostname，ip，内存，CPU等boxes = [ &#123; :name =&gt; "master1", :eth1 =&gt; "192.168.205.10", :mem =&gt; "1024", :cpu =&gt; "1" &#125;, &#123; :name =&gt; "slave1", :eth1 =&gt; "192.168.205.11", :mem =&gt; "1024", :cpu =&gt; "1" &#125;, &#123; :name =&gt; "slave2", :eth1 =&gt; "192.168.205.12", :mem =&gt; "1024", :cpu =&gt; "1" &#125;]Vagrant.configure("2") do |config| # box名称 config.vm.box = "centos/7" # 循环设置每台虚拟机 boxes.each do |opts| config.vm.define opts[:name] do |config| # 配置 hostname config.vm.hostname = opts[:name] # 配置内存和CPU config.vm.provider "virtualbox" do |v| v.customize ["modifyvm", :id, "--memory", opts[:mem]] v.customize ["modifyvm", :id, "--cpus", opts[:cpu]] end # 配置 IP config.vm.network :private_network, ip: opts[:eth1] # 设置网络代理(需要安装 vagrant-proxyconf 插件) if Vagrant.has_plugin?("vagrant-proxyconf") config.proxy.http = "http://192.168.205.1:1087/" config.proxy.https = "http://192.168.205.1:1087/" config.proxy.no_proxy = "localhost,127.0.0.1" end # 设置启动后初始化脚本，注意 privileged: true，表示以 sudo 方式运行 config.vm.provision "shell", privileged: true, path: "./setup.sh" # 设置宿主机共享文件夹(需要安装 vagrant-vbguest 插件) # config.vm.synced_folder "../data", "/vagrant_data" end endend setup.sh 1234567891011121314151617181920212223242526272829303132#/bin/sh# set timezoneecho "set timezone"timedatectl set-timezone Asia/Shanghaiecho "vagrant ALL=(ALL) NOPASSWD: ALL" &gt;&gt; /etc/sudoers# change yum repoecho "change yum repo -&gt; aliyun repo"sudo yum install -y wget yum-utilssudo cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.baksudo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.reposudo wget -P /etc/yum.repos.d/ http://mirrors.aliyun.com/repo/epel-7.repo sudo yum clean allsudo yum makecache# install some toolsecho "install some tools"sudo yum install -y yum-utils device-mapper-persistent-data lvm2 git vim gcc glibc-static telnet bridge-utils# install dockerecho "install docker"sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.reposudo yum makecache fastsudo yum -y install docker-ce# start docker serviceecho "start docker service"sudo groupadd dockersudo usermod -aG docker vagrantsudo systemctl enable docker 参考 Mac下使用Vagrant配置CentOS虚拟环境 Vagrant 笔记 使用vagrant和vitrualBox搭建虚拟开发环境 Vagrant搭建虚拟化开发环境]]></content>
      <categories>
        <category>技术相关</category>
        <category>vagrant</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>kubernetes</tag>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scaffold 组件相关文档]]></title>
    <url>%2F2019%2F03%2F12%2Fscaffold-doc.html</url>
    <content type="text"><![CDATA[前言 scaffold: 脚手架的意思，是一款封装了一些通用组件的，让Spring Boot快速开发的工具集。 1. Scaffold组件图谱 2. 项目信息 项目地址： https://github.com/xkcoding/scaffold 目录结构： 1234567891011scaffold├── scaffold-bom scaffold依赖管理├── scaffold-common 通用工具类├── scaffold-launcher 通用启动器├── scaffold-log 日志包├── scaffold-swagger swagger配置├── scaffold-test 通用单元测试├── scaffold-web 通用web配置├── scaffold-code 通用验证码组件├── scaffold-notification 通用通知组件└── scaffold-codegen 代码生成器 版本更新记录：CHANGELOG 3.安装方式 当前最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-$&#123;模块名&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;最新版本&#125;&lt;/version&gt;&lt;/dependency&gt; 4. 各个模块功能介绍及使用方法 4.1. scaffold-bom 版本依赖管理 主要功能 用于统一管理 scaffold 的版本，不需要用户控制各个模块的版本依赖 使用方法 scaffold-bom 最新版本: 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-bom&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-bom.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;!--不需要定义版本--&gt; &lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-$&#123;模块名&#125;&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.2. scaffold-launcher 启动器模块 主要功能 环境划分：dev（开发）、test（测试）、prod（正式），默认 dev。 启动器配置，代码中可以注入 ScaffoldProperties 来读取启动器的一些配置信息，比如 env 等。 scaffold.prop 可以在配置文件中自定义配置。然后再在代码中使用 ScaffoldProperties 读取。 插件扩展，更加方便的去注入一些通用配置，降低使用难度。插件扩展基于 java SPI 技术，关于 java SPI 具体使用可以百度。 注意：如果使用了 scaffold-launcher，单元测试需要使用 scaffold-test 组件，使用方法请看文档 使用方法 ① 创建spring boot 项目 ② 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-launcher 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-launcher&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-launcher.version&#125;&lt;/version&gt;&lt;/dependency&gt; ③ 修改启动类代码 123456789@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; // SpringApplication.run(DemoApplication.class, args); ScaffoldApplication.run("demo", DemoApplication.class, args); &#125;&#125; ④ 设置使用环境 java命令行：java -jar app.jar --spring.profiles.active=dev JAVA_OPS：set JAVA_OPTS=&quot;-Dspring.profiles.active=test&quot; 注解方式（代码层面，junit单元测试非常实用）：@ActiveProfiles({&quot;dev&quot;,&quot;test&quot;}) ENV方式：系统环境变量SPRING_PROFILES_ACTIVE（注意：是大写） idea开发场景下设置参考下图 ⑤ 自定义配置项 ScaffoldProperties.java 配置项 默认值 说明 scaffold.env dev 【只读】scaffold 环境变量，方便在代码中获取，设置无效 scaffold.name 无 【只读】当前服务名称 scaffold.is-local false 【只读】判断是否为 本地开发环境 scaffold.prop 无 装载自定义配置 scaffold.prop.xxx 在 application.yml 中配置 1234scaffold: prop: author: xkcoding blog: https://xkcoding.com 使用配置 1234567@Autowiredprivate ScaffoldProperties scaffoldProperties;public void test() &#123; String author = scaffoldProperties.get("author"); String blog = scaffoldProperties.get("blog"); // .....&#125; ⑥ 自定义启动插件 实现 LauncherService，重写 launcher 方法，下面是 LauncherService 的代码。 12345678910111213public interface LauncherService &#123; /** * 启动时 处理 SpringApplicationBuilder * * @param builder SpringApplicationBuilder * @param appName 服务名 * @param profile 配置名 * @param isLocalDev 是否本地开发 */ void launcher(SpringApplicationBuilder builder, String appName, String profile, boolean isLocalDev);&#125; 编写 SPI 文件放置到 resources 目录下，文件路径和文件名 META-INF/services/com.xkcoding.launcher.service.LauncherService。 内容为你编写的插件完整类名，例如：com.xxxx.CustomLauncherServiceImpl。 4.3. scaffold-common 通用工具 主要功能 通用API层返回格式封装 通用分页查询参数封装 常用工具类封装 使用方法 ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-common 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-common&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-common.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 统一API返回格式 类名：com.xkcoding.common.api.R 判断返回是否为成功：R.isSuccess(R result); 判断返回是否为不成功：R.isNotSuccess(R result); 获取data：R.getData(R result); 返回成功：R.success(); 成功-携带数据：R.success(Object data); 根据状态返回成功或者失败：R.status(boolean status, String msg); 根据状态返回成功或者失败：R.status(boolean status, IResultCode sCode); 返回失败信息：R.fail(); 返回失败信息，用于 web：R.fail(String msg); 返回失败信息：R.fail(IResultCode rCode); 返回失败信息：R.fail(IResultCode rCode, String msg); 返回失败信息：R.fail(int code, String msg); 返回失败信息-携带数据：R.fail(IResultCode rCode, T data); ③ 状态码接口 类名：com.xkcoding.common.api.IResultCode ④ 内置状态码 枚举值 状态码 描述 ResultCode.SUCCESS 200 操作成功 ResultCode.FAILURE -1 业务异常 ResultCode.UN_AUTHORIZED 401 请求未授权 ResultCode.NOT_FOUND 404 没找到请求 ResultCode.MSG_NOT_READABLE 400 消息不能读取 ResultCode.METHOD_NOT_SUPPORTED 405 不支持当前请求方法 ResultCode.MEDIA_TYPE_NOT_SUPPORTED 415 不支持当前媒体类型 ResultCode.REQ_REJECT 403 请求被拒绝 ResultCode.INTERNAL_SERVER_ERROR 500 服务器异常 ResultCode.PARAM_MISS 400 缺少必要的请求参数 ResultCode.PARAM_TYPE_ERROR 400 请求参数类型错误 ResultCode.PARAM_BIND_ERROR 400 请求参数绑定错误 ResultCode.PARAM_VALID_ERROR 400 参数校验失败 ⑤ 常用工具类 已经内置 hutool 工具类，额外新增TreeUtil(树节点操作)、IpUtil(获取IP信息)、UrlUtil(URL编解码)、Ip2AddressUtil(根据IP获取地址信息)、WebUtil(Web 工具类，操作 request/response/cookie)、ServletUtil(Servlet 工具类)等 4.4. scaffold-log 通用日志组件 主要功能 对操作日志进行封装 @ApiLog，自定义操作人，以及自定义日志处理 基于Spring Event异步处理日志信息 使用方法 ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-log 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-log&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-log.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② application.yml 中开启操作日志拦截 123scaffold: log: enabled: true ③ Controller层添加注解@ApiLog 12345@GetMapping("/")@ApiLog("测试操作")public R&lt;User&gt; test(@RequestBody User user) &#123; return R.data(user);&#125; ④ 自定义日志操作 创建一个类，继承 DefaultScaffoldLogServiceImpl（也可以实现LogService接口） 重写对应方法，不需要全部重写，只需要重写部分即可 12345678910111213141516171819202122232425262728293031323334353637public class CustomLogServiceImpl extends DefaultScaffoldLogServiceImpl &#123; /** * 保存操作日志 * * @param logApi 操作日志实体 * @return 是否保存成功 */ @Override public R&lt;Boolean&gt; saveApiLog(LogApi logApi) &#123; // 自定义操作，比如保存到数据库中 return super.saveApiLog(logApi); &#125; /** * 保存错误日志 * * @param logError 错误日志实体 * @return 是否保存成功 */ @Override public R&lt;Boolean&gt; saveErrorLog(LogError logError) &#123; // 自定义操作，比如保存到数据库中 return super.saveErrorLog(logError); &#125; /** * 保存自定义日志 * * @param logCustom 自定义日志实体 * @return 是否保存成功 */ @Override public R&lt;Boolean&gt; saveCustomLog(LogCustom logCustom) &#123; // 自定义操作，比如保存到数据库中 return super.saveCustomLog(logCustom); &#125;&#125; 再将自定义的日志操作放到 Spring 容器中 1234567@Configurationpublic class LogConfig &#123; @Bean public LogService logService()&#123; return new CustomLogServiceImpl(); &#125;&#125; 注意：如果当前 scaffold-launcher 配置的 spring.profiles.active 环境是 dev、test 则日志实体里会拦截到请求中的参数等信息，如果是 prod 则不会拦截请求参数 ⑤ 自定义当前操作人 scaffold-log 中默认当前操作人为 匿名用户 ，用户可以通过实现 SecurityService 接口，重写 getCurrentUserName 实现自己的业务逻辑，之后务必加到 Spring 容器中，操作同上，不再赘述。 4.5. scaffold-swagger 通用swagger配置 主要功能 集成swagger的自动装配，方便集成 使用方法 ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-swagger 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-swagger&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-swagger.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 配置swagger基础信息 123456789101112#swagger配置信息swagger: title: Demo 接口文档系统 description: Demo 接口文档系统 version: 1.0.0 license: Powered By xkcoding # 注意这里必须配置你当前项目的包名 base-package: com.example.demo.controller contact: name: Yangkai.Shen email: 237497819@qq.com url: https://xkcoding.com ③ 启动项目 访问 http://${host}:${port}/${contextPath}/doc.html，比如：http://localhost:8080/demo/doc.html 注意：如果当前 scaffold-launcher 配置的 spring.profiles.active 环境是 dev、test 则可以访问接口文档，如果是 prod 则访问不到。 4.6. scaffold-test 通用单元测试组件 主要功能 由于在 scaffold-launcher 里设置了一些启动参数，所以提供了 scaffold-test 方便在单元测试的时候使用。 使用方法 ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-test 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-test&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-test.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 单元测试一 采用 @RunWith(ScaffoldSpringRunner.class)。 12345678910@SpringBootTest@ScaffoldTest(profile = "dev",appName = "demo-test")@RunWith(ScaffoldSpringRunner.class)public class DemoTests &#123; @Test public void test() &#123; &#125;&#125; ③单元测试二 继承 ScaffoldBaseTest。 12345678910@SpringBootTest@ScaffoldTest(profile = "dev",appName = "demo-test")public class DemoTests extends ScaffoldBaseTest &#123; @Test public void test() &#123; &#125;&#125; 4.7. scaffold-web 通用web配置 主要功能 Redis序列化配置 Jackson序列化配置 通用全局异常拦截配置，未知异常触发 Event 事件，由 scaffold-log 监听处理 dev、test 环境下打印请求明细，方便代码调试 异步线程池通用配置 Mybatis-Plus 配置，dev、test 环境下启用SQL执行效率插件 使用方法 ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-web 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-web&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-web.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 异步线程池配置 配置项 默认值 说明 scaffold.async.corePoolSize 2 异步核心线程数，默认：2 scaffold.async.maxPoolSize 50 异步最大线程数，默认：50 scaffold.async.queueCapacity 10000 队列容量，默认：10000 scaffold.async.keepAliveSeconds 300 线程存活时间，默认：300 ③ 监控打印请求 123456789101112131415161718192019-03-13 15:38:11.650 INFO 6846 --- [ XNIO-1 task-2] com.xkcoding.web.logger.RequestLogAspect : RequestLogAspect.java:157 - ================ Request Start ===================&gt; POST: /demo/ Parameters: &#123;"name":"","id":0,"age":0,"email":""&#125;===headers=== Origin : http://localhost:8080===headers=== Cookie : Hm_lvt_bc38887aa5588add05a38704342ad7e8=1549855562; Hm_lvt_521f6d48d3fa40ce529ba993fc1a46b4=1548829297,1551345825; scroll-cookie=1900|/===headers=== Request-Origion : SwaggerBootstrapUi===headers=== Accept : */*===headers=== X-Requested-With : XMLHttpRequest===headers=== User-Agent : Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36 QQBrowser/4.5.121.400===headers=== Connection : keep-alive===headers=== Referer : http://localhost:8080/demo/doc.html===headers=== Host : localhost:8080===headers=== Accept-Encoding : gzip, deflate, br===headers=== Accept-Language : zh-CN,zh;q=0.9===headers=== Content-Length : 50===headers=== Content-Type : application/json===Result=== &#123;"msg":"操作成功","code":200,"data":&#123;"name":"","id":0,"age":0,"email":""&#125;,"success":true&#125;&lt;=== POST: /demo/ (2 ms)================ Request End ================ 4.8. scaffold-code 通用验证码组件 主要功能 随机验证码，可配置随机验证码的字符串、长度、宽度、高度 简单算术验证码，可配置验证码宽度、高度 使用方法 注意：验证码组件需要配合缓存使用，建议使用Redis ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-code 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-code&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-code.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 在 application.yml 中开启验证码，同时设置Redis相关配置 1234567891011121314151617181920212223scaffold: code: enabled: truespring: redis: host: localhost # 连接超时时间（记得添加单位，Duration） timeout: 10000ms # Redis默认情况下有16个分片，这里配置具体使用的分片 # database: 0 lettuce: pool: # 连接池最大连接数（使用负值表示没有限制） 默认 8 max-active: 8 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1 max-wait: -1ms # 连接池中的最大空闲连接 默认 8 max-idle: 8 # 连接池中的最小空闲连接 默认 0 min-idle: 0 cache: # 一般来说是不用配置的，Spring Cache 会根据依赖的包自行装配 type: redis ③ 自定义配置项 配置项 默认值 说明 scaffold.code.enabled false 是否开启验证码 scaffold.code.cookie-name scaffold-code 验证码默认cookie名 scaffold.code.cache-name SCAFFOLD::CODE 验证码默认缓存 scaffold.code.pool ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 验证码生成策略，默认：大写字母+数字 scaffold.code.width 108 验证码宽度 scaffold.code.height 40 验证码高度 scaffold.code.length 4 验证码长度 ④ 示例代码 1234567891011121314151617181920212223242526272829@RestController@Slf4jpublic class DemoController &#123; @Autowired private ScaffoldCode scaffoldCode; @GetMapping(value = "/code/math.jpg", produces = MediaType.IMAGE_JPEG_VALUE) public ResponseEntity&lt;Resource&gt; mathCode(HttpServletResponse response) &#123; return scaffoldCode.generateMathCode(response); &#125; @GetMapping("/verify/math/&#123;code&#125;") public R&lt;Boolean&gt; verifyMathCode(HttpServletResponse response, @PathVariable String code) &#123; boolean flag = scaffoldCode.validateMath(response, code); return R.status(flag, "验证码错误"); &#125; @GetMapping(value = "/code/random.jpg", produces = MediaType.IMAGE_JPEG_VALUE) public ResponseEntity&lt;Resource&gt; randomCode(HttpServletResponse response) &#123; return scaffoldCode.generateRandomCode(response); &#125; @GetMapping("/verify/random/&#123;code&#125;") public R&lt;Boolean&gt; verifyCode(HttpServletResponse response, @PathVariable String code) &#123; boolean flag = scaffoldCode.validateRandom(response, code); return R.status(flag, "验证码错误"); &#125;&#125; 4.9. scaffold-notification 通用通知组件 主要功能 钉钉机器人通知，支持多种消息类型，包括text类型、link类型、markdown类型、整体跳转ActionCard类型、独立跳转ActionCard类型、FeedCard类型 短信通知，集成阿里大鱼短信服务，稳定、快速 邮件通知，支持多种类型邮件，包括简单文本邮件、HTML模板邮件、附件、静态资源 使用方法 ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-notification 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-notification&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-notification.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 在 application.yml 中开启不同类型的通知配置，如果使用邮件通知类型，一定需要额外配置邮箱信息 123456789101112131415161718192021222324252627282930313233343536scaffold: notification: dingtalk: enabled: true # 钉钉机器人 webhook 地址 webhook: https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxx email: enabled: true aliyun: enabled: true # 阿里云 AccessKey ID access-key: *********** # 阿里云 Access Key Secret secret-key: *********** # 参见阿里大鱼短信服务的模板管理，格式为：模版名称:模版CODE，注意模板名称不能为中文 channels: article_notification: SMS_160576086spring: mail: # 邮箱 smtp 服务器地址 host: smtp.qq.com # 邮箱 smtp 服务器端口，一般存在ssl和非ssl的区别，比如QQ邮箱ssl端口为465，非ssl端口为587 port: 465 # 你的邮箱地址 username: ********@qq.com # 你的邮箱密码 password: ******** protocol: smtp test-connection: true default-encoding: UTF-8 properties: mail.smtp.auth: true # 下面三项根据自己邮箱是否使用ssl端口来设置，使用ssl为true，不使用ssl为false mail.smtp.starttls.enable: true mail.smtp.starttls.required: true mail.smtp.ssl.enable: true ③ 自定义配置项 配置项 默认值 说明 scaffold.notification.dingtalk.enabled false 是否启用钉钉机器人通知 scaffold.notification.dingtalk.webhook 无 钉钉机器人webhook地址 scaffold.notification.aliyun.enabled false 是否启用阿里大鱼短信通知 scaffold.notification.aliyun.access-key 无 阿里云 AccessKey scaffold.notification.aliyun.secret-key 无 阿里云 AccessSecret scaffold.notification.aliyun.channels 无 模板与模板CODE的映射关系，参见阿里大鱼短信服务的模板管理，格式为：模版名称:模版CODE，注意模板名称不能为中文 scaffold.notification.email.enabled false 是否启用邮箱通知，如果启用，一定需要额外配置邮箱信息 scaffold.notification.email.prefix classpath:/email/ 邮件模板位置 scaffold.notification.email.suffix .html 邮件模板后缀 ④ 示例代码 在 application.yml 中，配置好上述配置后，可参考如下代码，实现钉钉、短信、邮箱三种类型的消息通知 这里钉钉消息，只演示了 text 类型和 link 类型，其余类型，可以举一反三实现，官方文档地址：https://open-doc.dingtalk.com/microapp/serverapi2/qf2nxq 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.xkcoding.scaffold.demo;import cn.hutool.core.io.resource.ResourceUtil;import com.google.common.collect.Maps;import com.xkcoding.scaffold.notification.constants.EmailType;import com.xkcoding.scaffold.notification.model.dingtalk.Attention;import com.xkcoding.scaffold.notification.model.dingtalk.Link;import com.xkcoding.scaffold.notification.model.dingtalk.LinkDingTalkMessage;import com.xkcoding.scaffold.notification.model.dingtalk.TextDingTalkMessage;import com.xkcoding.scaffold.notification.model.email.EmailMessage;import com.xkcoding.scaffold.notification.model.sms.SmsMessage;import com.xkcoding.scaffold.notification.service.dingtalk.DingTalkMessageSender;import com.xkcoding.scaffold.notification.service.email.EmailMessageSender;import com.xkcoding.scaffold.notification.service.sms.SmsAliyunMessageSender;import com.xkcoding.scaffold.test.ScaffoldBaseTest;import com.xkcoding.scaffold.test.ScaffoldTest;import lombok.extern.slf4j.Slf4j;import org.assertj.core.util.Lists;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.io.File;import java.net.URL;import java.util.List;import java.util.Map;/** * &lt;p&gt; * 通知测试 * &lt;/p&gt; * * @package: com.xkcoding.scaffold.demo * @description: 通知测试 * @author: yangkai.shen * @date: Created in 2019-03-18 22:59 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@SpringBootTest@ScaffoldTest(profile = "prod", appName = "scaffold-notification-test")@Slf4jpublic class NotificationTest extends ScaffoldBaseTest &#123; @Autowired private DingTalkMessageSender dingTalkMessageSender; @Autowired private EmailMessageSender emailMessageSender; @Autowired private SmsAliyunMessageSender smsAliyunMessageSender; @Test public void testTextDingTalk() &#123; TextDingTalkMessage textDingTalkMessage = new TextDingTalkMessage(); textDingTalkMessage.setText(new TextDingTalkMessage.Text("你好，我是钉钉机器人")); textDingTalkMessage.setAt(new Attention(Lists.newArrayList( "17326075631"), false)); dingTalkMessageSender.execute(textDingTalkMessage); &#125; @Test public void testLinkDingTalk()&#123; LinkDingTalkMessage linkDingTalkMessage = new LinkDingTalkMessage(); Link link = new Link(); link.setMessageUrl("https://xkcoding.com"); link.setText("代码日记更新博客了。。。。。"); link.setTitle("博客更新"); linkDingTalkMessage.setLink(link); dingTalkMessageSender.execute(linkDingTalkMessage); &#125; @Test public void testSimpleEmail() &#123; EmailMessage emailMessage = new EmailMessage(); emailMessage.setEmailType(EmailType.SIMPLE); emailMessage.setTos(Lists.newArrayList("237497819@qq.com")); emailMessage.setFrom("xkcoding"); emailMessage.setSubject("简单邮件标题"); emailMessage.setContent("这是一封简单邮件的内容"); emailMessageSender.execute(emailMessage); &#125; @Test public void testMimeEmail() &#123; EmailMessage emailMessage = new EmailMessage(); emailMessage.setEmailType(EmailType.MIME); emailMessage.setTos(Lists.newArrayList("237497819@qq.com")); emailMessage.setFrom("xkcoding"); emailMessage.setSubject("复杂邮件标题"); // 设置模板，位置：resources/email/template.html emailMessage.setTemplate("template"); // 设置变量 Map&lt;String, Object&gt; params = Maps.newHashMap(); params.put("project", "Spring Boot Demo"); params.put("author", "Yangkai.Shen"); params.put("url", "https://github.com/xkcoding/spring-boot-demo"); emailMessage.setParams(params); // 设置附件，文件位置：resources/db/data-h2.sql、resources/db/schema-h2.sql URL data = ResourceUtil.getResource("db/data-h2.sql"); URL schema = ResourceUtil.getResource("db/schema-h2.sql"); List&lt;EmailMessage.Attachment&gt; attachments = Lists.newArrayList(new EmailMessage.Attachment("data.sql", new File(data .getPath())), new EmailMessage.Attachment("schema.sql", new File(schema.getPath()))); emailMessage.setAttachments(attachments); // 设置静态资源，图片位置：resources/static/favicon.png URL favicon = ResourceUtil.getResource("static/favicon.png"); List&lt;EmailMessage.StaticResource&gt; staticResources = Lists.newArrayList(new EmailMessage.StaticResource("favicon", new File(favicon .getPath()))); emailMessage.setStaticResources(staticResources); emailMessageSender.execute(emailMessage); &#125; @Test public void testSmsAliyunMessageSender() &#123; SmsMessage smsMessage = new SmsMessage(); smsMessage.setMobile("17326075631"); Map&lt;String, String&gt; params = Maps.newHashMap(); // 根据短信模板里的变量设置参数 // 此处我的模板内容为：尊敬的读者，代码日记发布文章《$&#123;article&#125;》，欢迎阅读！ params.put("article", "scaffold-doc"); smsMessage.setParams(params); smsMessage.setSignName("代码日记"); smsMessage.setTemplate("article_notification"); smsMessage.setType("短信通知"); smsAliyunMessageSender.execute(smsMessage); &#125;&#125; 邮件模板，位置：resources/email/template.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;SpringBootDemo(入门SpringBoot的首选Demo)&lt;/title&gt; &lt;style&gt; body &#123; text-align: center; margin-left: auto; margin-right: auto; &#125; #welcome &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="welcome"&gt; &lt;div style="text-align: center; padding: 10px"&gt;&lt;img src="cid:favicon"&gt;&lt;/div&gt; &lt;h3&gt;欢迎使用 &lt;span th:text="$&#123;project&#125;"&gt;&lt;/span&gt; - Powered By &lt;span th:text=" $&#123;author&#125;"&gt;&lt;/span&gt;&lt;/h3&gt; &lt;span th:text="$&#123;url&#125;"&gt;&lt;/span&gt; &lt;div style="text-align: center; padding: 10px"&gt; &lt;a style="text-decoration: none;" href="#" th:href="@&#123;$&#123;url&#125;&#125;" target="_bank"&gt; &lt;strong&gt;spring-boot-demo，入门Spring Boot的首选Demo！:)&lt;/strong&gt; &lt;/a&gt; &lt;/div&gt; &lt;div style="text-align: center; padding: 4px"&gt; 如果对你有帮助,请任意打赏 &lt;/div&gt; &lt;div style="width: 100%;height: 100%;text-align: center;display: flex"&gt; &lt;div style="flex: 1;"&gt;&lt;/div&gt; &lt;div style="display: flex;width: 400px;"&gt; &lt;div style="flex: 1;text-align: center;"&gt; &lt;div&gt; &lt;img width="180px" height="180px" src="http://xkcoding.com/resources/wechat-reward-image.png"&gt; &lt;/div&gt; &lt;div&gt;微信打赏&lt;/div&gt; &lt;/div&gt; &lt;div style="flex: 1;text-align: center;"&gt; &lt;div&gt;&lt;img width="180px" height="180px" src="http://xkcoding.com/resources/alipay-reward-image.png"&gt; &lt;/div&gt; &lt;div&gt;支付宝打赏&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="flex: 1;"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ⑤ 效果图 钉钉消息 简单邮件 复杂邮件 短信 ⑥ 文档参考 钉钉机器人：https://open-doc.dingtalk.com/microapp/serverapi2/qf2nxq 阿里大鱼：https://help.aliyun.com/document_detail/101300.html 4.10. scaffold-codegen 代码生成器 主要功能 支持生成前端api、Controller、Mapper、Service、Model代码，暂时仅支持mysql数据源 Controller、Model代码集成swagger注解 提供前端下载页面 使用方法 ① 添加依赖 推荐使用 scaffold-bom 管理 scaffold 模块版本，使用方法请看文档 scaffold-codegen 最新版本: 12345&lt;dependency&gt; &lt;groupId&gt;com.xkcoding&lt;/groupId&gt; &lt;artifactId&gt;scaffold-codegen&lt;/artifactId&gt; &lt;version&gt;$&#123;scaffold-codegen.version&#125;&lt;/version&gt;&lt;/dependency&gt; ② 自定义配置项 配置项 默认值 说明 scaffold.codegen.author com.xkcoding 基础包名 scaffold.codegen.base-package-name codegen 模块名 scaffold.codegen.module-name Yangkai.Shen 作者 scaffold.codegen.table-prefix tb_ 表前缀(类名不会包含表前缀) ③ 在application.yml中添加数据源信息 123456spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/spring-boot-demo username: root password: root ④ 启动项目，访问 http://localhost:8080/demo/codegen.html 注意：如果当前 scaffold-launcher 配置的 spring.profiles.active 环境是 dev、test 则可以访问接口文档，如果是 prod 则访问不到。 TODO scaffold-cache 通用基于redis或者ehcache的缓存配置，设计缓存key，保证全系统key统一 scaffold-auth 通用认证授权配置]]></content>
      <categories>
        <category>开源</category>
        <category>scaffold</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>scaffold</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Mybatis动态SQL构建通用自定义高级查询]]></title>
    <url>%2F2019%2F02%2F18%2Fuse-mybatis-dynamic-sql-to-build-common-custom-advance-query.html</url>
    <content type="text"><![CDATA[前言 动态SQL是Mybatis中最强大的特性之一。实际开发中，数据的查询条件是动态多变的，因此动态SQL可以很方便的构建多条件的 where 语句的拼装。但是where条件里的查询条件跟表中的字段还是息息相关，我们在编写*Mapper.xml 文件的时候，还是需要在 &lt;where&gt; 节点里写编写很多的 &lt;if test=&quot;condition&quot;&gt; 条件。程序猿都是一种爱偷懒的物种，于是乎，便有了此文的主题『使用Mybatis动态SQL构建通用自定义高级查询』。话不多说，进入正题。 1. 思路 我们需要构建通用的自定义高级查询，那么首先有以下几个必须满足的点： 满足通用的要求，那么查询字段就不能写死在 &lt;where&gt; 节点中。 满足高级查询的要求，那么查询条件的个数就是不确定的。 满足自定义的要求，那么查询操作符肯定不可以限死是 = 或者 like 等。 根据上面提出要求，也就是说我们需要定义一个查询参数去接收前端传到后台的查询条件。查询条件需要满足3个要素：①查询字段②查询操作符③查询数据。当我们接收到查询条件的时候，根据动态SQL的语法构建出动态查询条件。 2. 实现 步骤一：定义高级查询条件模型 AdcanceQuery.java 12345678910111213141516171819202122232425262728293031323334package com.xkcoding.demo.model.query;import lombok.Data;import java.util.List;/** * &lt;p&gt; * 高级搜索条件 * &lt;/p&gt; * * @package: com.xkcoding.demo.model.query * @description: 高级搜索条件 * @author: yangkai.shen * @date: Created in 2019-02-14 15:33 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Datapublic class AdvanceQuery &#123; /** * 查询条件 */ private String key; /** * 查询操作符 */ private String op; /** * 查询内容 */ private List&lt;Object&gt; value;&#125; 步骤二：修改对应的Mapper Java文件 UserMapper.java 123456789101112131415161718192021222324252627282930313233package com.xkcoding.demo.mapper;import java.util.List;import com.xkcoding.demo.common.MyMapper;import com.xkcoding.demo.model.User;import com.xkcoding.demo.model.query.AdvanceQuery;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Component;/** * &lt;p&gt; * UserMapper * &lt;/p&gt; * * @package: com.xkcoding.demo.mapper * @description: UserMapper * @author: yangkai.shen * @date: Created in 2019-02-14 15:33 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Componentpublic interface UserMapper extends MyMapper&lt;User&gt; &#123; /** * 查询用户列表 * * @param advanceQueryList 高级搜索条件 * @return 用户列表 */ List&lt;User&gt; selectList(@Param("advanceQuery") List&lt;AdvanceQuery&gt; advanceQueryList);&#125; 步骤三：修改对应的Mapper XML文件，添加高级查询SQL片段 UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xkcoding.demo.mapper.UserMapper"&gt; &lt;resultMap id="BaseResultMap" type="com.xkcoding.demo.model.User"&gt; &lt;id column="id" jdbcType="INTEGER" property="id"/&gt; &lt;result column="username" jdbcType="VARCHAR" property="username"/&gt; &lt;result column="dept_id" jdbcType="INTEGER" property="deptId"/&gt; &lt;result column="gender" jdbcType="INTEGER" property="gender"/&gt; &lt;result column="nickname" jdbcType="VARCHAR" property="nickname"/&gt; &lt;result column="open_id" jdbcType="VARCHAR" property="openId"/&gt; &lt;result column="birthday" jdbcType="Date" property="birthday"/&gt; &lt;result column="last_login_time" jdbcType="Date" property="lastLoginTime"/&gt; &lt;result column="last_ip" jdbcType="VARCHAR" property="lastIp"/&gt; &lt;result column="lock" jdbcType="INTEGER" property="lock"/&gt; &lt;/resultMap&gt; &lt;select id="selectList" resultType="com.xkcoding.demo.model.User"&gt; SELECT temp.* FROM ( SELECT t.* FROM t_user t )temp &lt;where&gt; &lt;include refid="advance_query_sql"/&gt; &lt;/where&gt; &lt;/select&gt; &lt;sql id="advance_query_sql"&gt; &lt;foreach item="item" collection="advanceQuery" open=" AND " separator=" AND " close=" "&gt; &lt;choose&gt; &lt;when test="item.op != null and item.op == 'eq'"&gt; temp.$&#123;item.key&#125; = #&#123;item.value[0]&#125; &lt;/when&gt; &lt;when test="item.op != null and item.op == 'gte'"&gt; temp.$&#123;item.key&#125; &amp;gt;= #&#123;item.value[0]&#125; &lt;/when&gt; &lt;when test="item.op != null and item.op == 'lte'"&gt; temp.$&#123;item.key&#125; &amp;lt;= #&#123;item.value[0]&#125; &lt;/when&gt; &lt;when test="item.op != null and item.op == 'between'"&gt; temp.$&#123;item.key&#125; BETWEEN #&#123;item.value[0]&#125; AND #&#123;item.value[1]&#125; &lt;/when&gt; &lt;when test="item.op != null and item.op == 'in'"&gt; temp.$&#123;item.key&#125; IN &lt;foreach item="value" collection="item.value" open="(" separator="," close=")"&gt; #&#123;value&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;when test="item.op != null and item.op == 'no'"&gt; (temp.$&#123;item.key&#125; IS NULL OR trim(temp.$&#123;item.key&#125;) = '') &lt;/when&gt; &lt;when test="item.op != null and item.op == 'yes'"&gt; (temp.$&#123;item.key&#125; IS NOT NULL AND trim(temp.$&#123;item.key&#125;) != '') &lt;/when&gt; &lt;when test="item.op != null and item.op == 'notin'"&gt; temp.$&#123;item.key&#125; NOT IN &lt;foreach item="value" collection="item.value" open="(" separator="," close=")"&gt; #&#123;value&#125; &lt;/foreach&gt; &lt;/when&gt; &lt;when test="item.op != null and item.op == 'like'"&gt; &lt;if test="item.value.size == 1"&gt; temp.$&#123;item.key&#125; LIKE CONCAT("%", #&#123;item.value[0]&#125;, "%") &lt;/if&gt; &lt;if test="item.value.size &gt; 1"&gt; &lt;foreach item="value" collection="item.value" open="(" separator=" OR " close=")"&gt; temp.$&#123;item.key&#125; LIKE CONCAT("%", #&#123;value&#125;, "%") &lt;/foreach&gt; &lt;/if&gt; &lt;/when&gt; &lt;otherwise&gt; 1 = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/foreach&gt; &lt;/sql&gt;&lt;/mapper&gt; 这里改造之前的查询语句，只需要在外层再包一层，并且别名改成temp即可。 如下： 123&lt;select&gt; SELECT * FROM table where xxx;&lt;/select&gt; 改为： 123456789&lt;select&gt; SELECT temp.* FROM ( SELECT * FROM table where xxx; )temp &lt;where&gt; &lt;include refid="advance_query_sql"/&gt; &lt;/where&gt;&lt;/select&gt; 步骤四：Controller层 查询方法由 @GetMapping 改为 @PostMapping，参数 @RequestBody List&lt;AdvanceQuery&gt; advanceQueryList 3. 测试 使用 PostMan 测试，参数使用 Body 发送 json 数据类似如下格式： 1234567891011121314151617[ &#123; "key":"username", "op":"like", "value":["xk","coding"] &#125;, &#123; "key":"gender", "op":"eq", "value":[1] &#125;, &#123; "key":"birthday", "op":"between", "value":["1994-11-01 00:00:00","1994-12-01 00:00:00"] &#125;] 4. 操作符说明 内容 含义 value值备注 eq 等于 有且只有 1 个 gte 大于等于 有且只有 1 个 lte 小于等于 有且只有 1 个 between 介于 有且只有 2 个 in 包含 大于等于 1 个 notin 不包含 大于等于 1 个 no 不存在 空数组 yes 存在 空数组 like 模糊 大于等于 1 个，多个 value 时，会使用 OR 构建查询条件 5. 思考 目前支持的操作符就是以上几种，但是基本够用，其余语法还需要自己扩展。 目前仅支持多条件 AND 拼接。 xml模板目前没有类似继承的特性，所以这个sql片段需要在每个使用到的地方都写一遍，造成代码冗余。后期可以参考Mybatis拦截器的特性，对查询SQL进行封装，解决冗余。 6. 参考 MyBatis 3 | 动态SQL - MyBatis.org]]></content>
      <categories>
        <category>代码片段</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之创建型设计模式-工厂方法模式]]></title>
    <url>%2F2019%2F02%2F15%2Fdesign-pattern-factory-method.html</url>
    <content type="text"><![CDATA[1. 模式简介 工厂方法模式(Factory Method Pattern)：又称为工厂模式，属于创建型设计模式。在工厂方法模式中，工厂父类负责定义创建对象的公共接口，工厂子类负责生成具体的对象，这样做的目的是将具体类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体对象。本文将使用 糖果工厂生产不同口味的糖果 这个实际场景，用代码来实现 工厂方法模式。 2. 模式角色 工厂方法模式包含以下4种角色： 抽象实体(Candy)：糖果类基类 具体实体实现(LemonCandy 和 WatermelonCandy)：具体口味糖果实现 抽象工厂(CandyFactory)：糖果工厂类基类 具体工厂实现(LemonCandyFactory 和 WatermelonCandyFactory)：具体口味糖果工厂类实现 3. UML图例 4. 代码实现 4.1. 步骤一：创建抽象糖果类 Candy.java 1234567891011121314151617181920/** * &lt;p&gt; * 糖果抽象类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.factorymethod * @description: 糖果抽象类 * @author: yangkai.shen * @date: Created in 2019-02-14 11:28 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public abstract class Candy &#123; /** * 口味 */ public abstract void taste();&#125; 4.2. 步骤二：创建抽象糖果工厂类 CandyFactory.java 123456789101112131415161718192021/** * &lt;p&gt; * 糖果工厂抽象类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.factorymethod * @description: 糖果工厂抽象类 * @author: yangkai.shen * @date: Created in 2019-02-14 11:29 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public abstract class CandyFactory &#123; /** * 生产糖果 * * @return 对应口味的糖果 */ public abstract Candy produceCandy();&#125; 4.3. 步骤三：创建具体的不同口味的糖果类 LemonCandy.java 12345678910111213141516171819202122/** * &lt;p&gt; * 柠檬味糖果 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.factorymethod * @description: 柠檬味糖果 * @author: yangkai.shen * @date: Created in 2019-02-14 11:28 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class LemonCandy extends Candy &#123; /** * 口味 */ @Override public void taste() &#123; System.out.println("柠檬味"); &#125;&#125; WatermelonCandy.java 12345678910111213141516171819202122/** * &lt;p&gt; * 西瓜味糖果 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.factorymethod * @description: 西瓜味糖果 * @author: yangkai.shen * @date: Created in 2019-02-14 11:28 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class WatermelonCandy extends Candy &#123; /** * 口味 */ @Override public void taste() &#123; System.out.println("西瓜味"); &#125;&#125; 4.4. 步骤四：创建具体的不同口味的糖果工厂类 LemonCandyFactory.java 123456789101112131415161718192021222324/** * &lt;p&gt; * 柠檬味糖果工厂类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.factorymethod * @description: 柠檬味糖果工厂类 * @author: yangkai.shen * @date: Created in 2019-02-14 11:30 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class LemonCandyFactory extends CandyFactory &#123; /** * 生产柠檬味糖果 * * @return 柠檬味糖果 */ @Override public Candy produceCandy() &#123; return new LemonCandy(); &#125;&#125; WatermelonCandyFactory.java 123456789101112131415161718192021222324/** * &lt;p&gt; * 西瓜味糖果工厂类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.factorymethod * @description: 西瓜味糖果工厂类 * @author: yangkai.shen * @date: Created in 2019-02-14 11:30 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class WatermelonCandyFactory extends CandyFactory &#123; /** * 生产西瓜味糖果 * * @return 西瓜味糖果 */ @Override public Candy produceCandy() &#123; return new WatermelonCandy(); &#125;&#125; 4.5. 步骤五： 测试 PatternTest.java 1234567891011121314151617181920212223242526272829import com.xkcoding.design.pattern.creational.factorymethod.Candy;import com.xkcoding.design.pattern.creational.factorymethod.CandyFactory;import com.xkcoding.design.pattern.creational.factorymethod.LemonCandyFactory;import com.xkcoding.design.pattern.creational.factorymethod.WatermelonCandyFactory;/** * &lt;p&gt; * 工厂方法模式测试类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.factorymethod.run * @description: 工厂方法模式测试类 * @author: yangkai.shen * @date: Created in 2019-02-14 14:54 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class PatternTest &#123; public static void main(String[] args) &#123; CandyFactory factory1 = new LemonCandyFactory(); Candy candy1 = factory1.produceCandy(); candy1.taste(); CandyFactory factory2 = new WatermelonCandyFactory(); Candy candy2 = factory2.produceCandy(); candy2.taste(); &#125;&#125; 5. 应用 12// JDK中的应用// 获取日历对象 -&gt; Calendar.getInstance() -&gt; createCalendar(TimeZone zone,Locale aLocale) 6. 场景 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 7. 优缺点 优点： 以本例为例，1、扩展性高，如果想增加一个具体口味的糖果，只需要添加具体口味的糖果实现，同时添加具体口味的糖果工厂即可。2、屏蔽糖果的具体实现，调用方只关心抽象实体的通用接口在具体口味糖果类中的不同实现。 缺点： 以本例为例，每增加一种糖果口味，都需要增加一种具体的实现类，同时增加具体的工厂类，如果系统中存在很多不同口味的糖果，则会导致类的数量成倍增加，增加了系统的复杂度。 8. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/creational/factorymethod]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之创建型设计模式-简单工厂模式]]></title>
    <url>%2F2019%2F02%2F13%2Fdesign-pattern-simple-factory.html</url>
    <content type="text"><![CDATA[1. 模式简介 简单工厂模式(Simple Factory Pattern)：它属于创建型设计模式，不属于23种设计模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。本文将使用 糖果工厂生产不同口味的糖果 这个实际场景，用代码来实现 简单工厂模式。 2. 模式角色 简单工厂包含3个角色： 工厂角色(CandyFactory)：主要负责创建具体的实例。 抽象实体(Candy)：它是工厂角色所创建的所有实例的父类，包含所有具体实例所共有的公共接口。 具体特征的实体(LemonCandy 和 WatermelonCandy)：所有由工厂角色创建出来的实例都属于具体实体。 3. UML图例 3.1. 未使用简单工厂模式的UML图 3.2. 使用简单工厂模式之后的UML图 4. 代码实现 4.1. 步骤一：创建抽象糖果类 Candy.java 1234567891011121314151617181920/** * &lt;p&gt; * 糖果抽象类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.simplefactory * @description: 糖果抽象类 * @author: yangkai.shen * @date: Created in 2019-02-13 10:32 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public abstract class Candy &#123; /** * 口味 */ public abstract void taste();&#125; 4.2. 步骤二：创建具体的不同口味的糖果类 LemonCandy.java 12345678910111213141516171819202122/** * &lt;p&gt; * 柠檬味糖果 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.simplefactory * @description: 柠檬味糖果 * @author: yangkai.shen * @date: Created in 2019-02-13 10:34 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class LemonCandy extends Candy &#123; /** * 口味 */ @Override public void taste() &#123; System.out.println("柠檬味"); &#125;&#125; WatermelonCandy.java 12345678910111213141516171819202122/** * &lt;p&gt; * 西瓜味糖果 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.simplefactory * @description: 西瓜味糖果 * @author: yangkai.shen * @date: Created in 2019-02-13 10:36 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class WatermelonCandy extends Candy &#123; /** * 口味 */ @Override public void taste() &#123; System.out.println("西瓜味"); &#125;&#125; 4.3. 步骤三：创建糖果工厂 CandyFactory.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * &lt;p&gt; * 糖果工厂类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.simplefactory * @description: 糖果工厂类 * @author: yangkai.shen * @date: Created in 2019-02-13 10:43 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class CandyFactory &#123; /** * 生产糖果 * * @param taste 具体口味 * @return 对应口味的糖果 */ public Candy produceCandy(String taste) &#123; if ("lemon".equalsIgnoreCase(taste)) &#123; return new LemonCandy(); &#125; else if ("watermelon".equalsIgnoreCase(taste)) &#123; return new WatermelonCandy(); &#125; return null; &#125; /** * 生产糖果 * @param c 具体口味的糖果类 * @return 对应口味的糖果 */ public Candy produceCandy(Class c) &#123; Candy candy = null; try &#123; candy = (Candy) Class.forName(c.getSimpleName()).newInstance(); &#125; catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return candy; &#125;&#125; 4.4. 步骤四：调用工厂类生产具体口味的糖果 12345678910111213141516171819202122232425262728293031323334import com.xkcoding.design.pattern.creational.simplefactory.Candy;import com.xkcoding.design.pattern.creational.simplefactory.CandyFactory;import com.xkcoding.design.pattern.creational.simplefactory.LemonCandy;import com.xkcoding.design.pattern.creational.simplefactory.WatermelonCandy;/** * &lt;p&gt; * 简单工厂模式测试类 * &lt;/p&gt; * * @package: com.xkcoding.design.pattern.creational.simplefactory.run * @description: 简单工厂模式测试类 * @author: yangkai.shen * @date: Created in 2019-02-13 10:40 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class PatternTest &#123; public static void main(String[] args) &#123; CandyFactory factory = new CandyFactory(); // 测试工厂类方法 - 1 Candy candy1 = factory.produceCandy("lemon"); candy1.taste(); Candy candy2 = factory.produceCandy("watermelon"); candy2.taste(); // 测试工厂类方法 - 2 Candy candy3 = factory.produceCandy(LemonCandy.class); candy3.taste(); Candy candy4 = factory.produceCandy(WatermelonCandy.class); candy4.taste(); &#125;&#125; 5. 应用 12// Slf4j日志// 获取日志对象 -&gt; LoggerFactory.getLogger(String name) -&gt; getILoggerFactory() -&gt; getLogger(name) 6. 场景 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 7. 优缺点 优点： 以本例为例，1、糖果调用方想创建一个具体口味的糖果对象，只要知道其口味就可以。 2、扩展性高，如果想增加一个具体口味的糖果，只要在工厂类中添加一种生产逻辑就可以实现。 3、屏蔽糖果的具体实现，调用方只关心抽象实体的通用接口在具体口味糖果类中的不同实现。 缺点： 以本例为例，每增加一种糖果口味，都需要增加一种具体的实现类，同时在工厂类中添加对应的生产逻辑，如果系统中存在很多不同口味的糖果，则会导致类的数量成倍增加，增加了系统的复杂度，同时增加类之间的依赖。 8. 完整代码地址 https://github.com/xkcoding/design-pattern/tree/master/src/main/java/com/xkcoding/design/pattern/creational/simplefactory]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Maven管理Spring Boot Profile]]></title>
    <url>%2F2019%2F02%2F04%2Fuse-maven-manage-spring-boot-profile.html</url>
    <content type="text"><![CDATA[前言 Spring Boot开发的项目中，多环境配置极大的提升了开发效率，避免了因为测试(test)、开发(dev)、生产(prod)导致频繁修改一个配置文件，导致出现配置错误的情况。 那么Spring Boot如何做到多环境配置？还有没有更优雅的方式管理Spring Boot的多环境配置呢？ 1. Spring Boot多环境配置 Spring Boot 项目可使用 profile 来实现多环境配置，通过 spring.profiles.active 属性决定使用具体哪个环境的profile。 Spring Boot 的配置文件默认为 application.yml(或properties，此外仅以yml配置为说明)。不同 profile 下的配置文件由 application-{profile}.yml 管理，同时 application-{profile}.yml 配置文件会覆盖默认配置文件(application.yml)下的同一属性。 一般 profile 有以下几种：dev(开发)，test(单元测试)，prod(生产环境) 2. Maven多环境配置 大部分项目基于 Maven 构建，此处不介绍 Gradle 方式构建。所以使用 Maven 可以更加方便优雅的管理 profile。 2.1. Maven Profile 配置 在项目的 pom.xml (或者具体 module 的pom.xml)中添加 profiles 节点 1234567891011121314151617181920212223&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profileActive&gt;dev&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;prod&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;profileActive&gt;test&lt;/profileActive&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 其中 profile 节点里还可以指定额外的依赖以及管理依赖的版本等等，十分的方便。 properties 中的 profileActive 是自定义变量，后续为了指定 Spring Boot 所使用的profile。 2.2. 根据 Maven Profile 过滤资源文件 Spring Boot 的 profile 选择需要在 application.yml 中配置 spring.profiles.active，如果写死在配置文件中，那么每次打包都需要手动修改，很麻烦，而且容易出错。在 pom.xml 里定义变量，就可以在 application.yml 中 通过 @xxxx@ 获取变量的内容，此处变量为 profileActive。 资源过滤需要在 pom.xml 的 build 节点下配置 resources 节点： 12345678910111213141516171819202122232425&lt;build&gt; &lt;finalName&gt;$&#123;artifactId&#125;&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 过滤资源 --&gt; &lt;excludes&gt; &lt;exclude&gt;application*.yml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 是否替换@xx@表示的maven properties属性值 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!-- 引入资源 --&gt; &lt;includes&gt; &lt;include&gt;application.yml&lt;/include&gt; &lt;include&gt;application-$&#123;profileActive&#125;.yml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; ...省略部分内容 &lt;/plugins&gt;&lt;/build&gt; resources 节点中第一个 resource 去掉了src/main/resources下的所有 application*.yml 文件，* 是通配符，表示此处有任何内容（没有也可以）都匹配。 第二个 resource 添加了application.yml 默认配置文件和由 profileActive 属性决定的相应 profile 配置文件。并且 filtering 为 true 表示，会将文件内容中的 @xx@ 替换为相应的变量（此处文件中的 @profileActive@ 会替换为pom中配置的 profileActive 属性值）。 2.3. 修改 application.yml 123spring: profiles: active: @profileActive@ @profileActive@ 表示该属性值会在 maven 构建时被替换为对应的内容。 2.4. 构建 2.4.1. 命令行构建 1mvn clean package -Dmaven.test.skip=true -P dev 如果需要打成 prod 包，则把 -P 的参数替换成 prod 即可。也可以写一个 shell 脚本，方便后续打包。 12345678#!/bin/bashprofileActive=prodif [[ -n "$1" ]]; then profileActive=$1fimvn clean package -Dmaven.test.skip=true -P $&#123;profileActive&#125; 该脚本接收一个参数，即打包对应的 profile。默认情况下如果不带参数，会打包成prod。 2.4.2. 工具构建 如果我们使用 IDEA为开发工具的话，就会方便很多了。上一张图，不过多解释~ 3. 参考 https://blog.csdn.net/lihe2008125/article/details/50443491 https://www.jianshu.com/p/755a57511928 https://segmentfault.com/a/1190000011770028]]></content>
      <categories>
        <category>技术相关</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 使用枚举类型作为请求参数]]></title>
    <url>%2F2019%2F01%2F30%2Fspring-boot-request-use-enums-params.html</url>
    <content type="text"><![CDATA[1. 场景 在我们实际开发中，枚举类型应用十分广泛，可以避免在项目中定义大量的『魔法值』变量。但是，在web开发中，如何将枚举对象作为请求参数传进Controller，做到类型自动转换？直接使用 @RequestParam 和 @RequestBody 断然是不够的，这里就需要我们自定义 Converter 来实现类型转化了。 2. 需求 比如一个用户对象，里面的性别属性，我们定义一个枚举类型 Gender。 GenderEnum.java 12345678910111213141516171819202122232425262728293031323334/** * &lt;p&gt; * 性别枚举 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.constants.enums * @description: 性别枚举 * @author: yangkai.shen * @date: Created in 2019-01-30 11:06 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Getterpublic enum GenderEnum &#123; /** * 男 */ MALE(0), /** * 女 */ FEMALE(1); /** * 性别编码 */ private Integer code; GenderEnum(int code) &#123; this.code = code; &#125;&#125; 请求对象封装 QueryRequest QueryRequest.java 1234567891011121314151617/** * &lt;p&gt; * 请求参数 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.controller.enum_test * @description: 请求参数 * @author: yangkai.shen * @date: Created in 2019-01-30 14:02 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Datapublic class QueryRequest &#123; private GenderEnum gender;&#125; 在Controller层直接使用如下方式，期望参数自动进行类型转换 EnumTestController.java 12345678910111213141516171819202122232425262728293031/** * &lt;p&gt; * 测试参数是枚举类型，自动转换 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.controller.enum_test * @description: 测试参数是枚举类型，自动转换 * @author: yangkai.shen * @date: Created in 2019-01-30 13:56 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Slf4j@RestController@RequestMapping("/enum")public class EnumTestController &#123; @GetMapping("/get") public Dict testGet(QueryRequest request) &#123; log.info("【get-request】= &#123;&#125;", JSONUtil.toJsonStr(request)); return Dict.create().set("get-request", request); &#125; @PostMapping("/post") public Dict testPost(@RequestBody QueryRequest request) &#123; log.info("【post-request】= &#123;&#125;", JSONUtil.toJsonStr(request)); return Dict.create().set("post-request", request); &#125;&#125; 这么写的时候，gender只能接收到 MALE 、FEMALE 这样的参数，除此以外，均会报类型不匹配的错误信息，此时是无法处理 0 、1 这样的参数的。 需求： 接收到 MALE 、FEMALE 这样的参数，可以自动转为对应的枚举值； 接收到 0 、1 这样的参数，也可以自动转为对应的枚举值。 3. 解决 此时，本文的『主角』Converter 就可以隆重登场了。 注意，Converter 是 org.springframework.core.convert.converter.Converter ，别导错包了。 IntegerCodeToGenderEnumConverter.java 12345678910111213141516171819202122232425262728293031/** * &lt;p&gt; * 编码 -&gt; 性别 转换器 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.config.convert * @description: 编码 -&gt; 性别 转换器 * @author: yangkai.shen * @date: Created in 2019-01-30 11:14 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class IntegerCodeToGenderEnumConverter implements Converter&lt;Integer, GenderEnum&gt; &#123; private Map&lt;Integer, GenderEnum&gt; enumMap = Maps.newHashMap(); public IntegerCodeToGenderEnumConverter() &#123; for (GenderEnum genderEnum : GenderEnum.values()) &#123; enumMap.put(genderEnum.getCode(), genderEnum); &#125; &#125; @Override public GenderEnum convert(Integer source) &#123; GenderEnum genderEnum = enumMap.get(source); if (ObjectUtil.isNull(genderEnum)) &#123; throw new IllegalArgumentException("无法匹配对应的枚举类型"); &#125; return genderEnum; &#125;&#125; 其实这里已经可以实现类型转换了，但是引出另外一个问题，当我们的枚举类特别多的时候，我们就需要写很多个 自定义的Converter来满足类型转化。 所以我们不使用上面直接使用 Converter 的这种方法，我们引入 ConverterFactory 来解决这个问题。 3.1. 抽取公共枚举接口 以后的枚举类都需要实现这个接口 BaseEnum.java 123456789101112131415161718192021/** * &lt;p&gt; * 通用枚举接口 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.constants * @description: 通用枚举接口 * @author: yangkai.shen * @date: Created in 2019-01-30 11:04 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public interface BaseEnum &#123; /** * 获取枚举编码 * * @return 编码 */ Integer getCode();&#125; 3.2. 调整GenderEnum枚举类 GenderEnum.java 12345678910111213141516171819202122232425262728293031323334/** * &lt;p&gt; * 性别枚举 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.constants.enums * @description: 性别枚举 * @author: yangkai.shen * @date: Created in 2019-01-30 11:06 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Getterpublic enum GenderEnum implements BaseEnum &#123; /** * 男 */ MALE(0), /** * 女 */ FEMALE(1); /** * 性别编码 */ private Integer code; GenderEnum(int code) &#123; this.code = code; &#125;&#125; 3.3. 创建通用 Integer -&gt; Enum 的 Converter 类 IntegerToEnumConverter.java 1234567891011121314151617181920212223242526272829303132/** * &lt;p&gt; * 枚举编码 -&gt; 枚举 转化器 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.config.convert * @description: 枚举编码 -&gt; 枚举 转化器 * @author: yangkai.shen * @date: Created in 2019-01-30 11:21 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class IntegerToEnumConverter&lt;T extends BaseEnum&gt; implements Converter&lt;Integer, T&gt; &#123; private Map&lt;Integer, T&gt; enumMap = Maps.newHashMap(); public IntegerToEnumConverter(Class&lt;T&gt; enumType) &#123; T[] enums = enumType.getEnumConstants(); for (T e : enums) &#123; enumMap.put(e.getCode(), e); &#125; &#125; @Override public T convert(Integer source) &#123; T t = enumMap.get(source); if (ObjectUtil.isNull(t)) &#123; throw new IllegalArgumentException("无法匹配对应的枚举类型"); &#125; return t; &#125;&#125; 3.4. 创建对应的自定义 ConverterFactory 工厂类 IntegerCodeToEnumConverterFactory.java 1234567891011121314151617181920212223242526272829303132/** * &lt;p&gt; * 编码 -&gt; 枚举 转化器工厂类 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.config.convert.factory * @description: 编码 -&gt; 枚举 转化器工厂类 * @author: yangkai.shen * @date: Created in 2019-01-30 11:09 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class IntegerCodeToEnumConverterFactory implements ConverterFactory&lt;Integer, BaseEnum&gt; &#123; private static final Map&lt;Class, Converter&gt; CONVERTERS = Maps.newHashMap(); /** * 获取一个从 Integer 转化为 T 的转换器，T 是一个泛型，有多个实现 * * @param targetType 转换后的类型 * @return 返回一个转化器 */ @Override public &lt;T extends BaseEnum&gt; Converter&lt;Integer, T&gt; getConverter(Class&lt;T&gt; targetType) &#123; Converter&lt;Integer, T&gt; converter = CONVERTERS.get(targetType); if (converter == null) &#123; converter = new IntegerToEnumConverter&lt;&gt;(targetType); CONVERTERS.put(targetType, converter); &#125; return converter; &#125;&#125; 3.5. 创建通用 String -&gt; Enum 的 Converter 类和对应的 ConverterFactory 工厂类 因为 Post 请求可以对传入的 json 属性定义类型，但是 Get 请求后台接收到的参数都是 String 类型，因此需要在创建一个Converter类 StringToEnumConverter.java 1234567891011121314151617181920212223242526272829303132/** * &lt;p&gt; * 枚举编码 -&gt; 枚举 转化器 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.config.convert * @description: 枚举编码 -&gt; 枚举 转化器 * @author: yangkai.shen * @date: Created in 2019-01-30 11:21 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class StringToEnumConverter&lt;T extends BaseEnum&gt; implements Converter&lt;String, T&gt; &#123; private Map&lt;String, T&gt; enumMap = Maps.newHashMap(); public StringToEnumConverter(Class&lt;T&gt; enumType) &#123; T[] enums = enumType.getEnumConstants(); for (T e : enums) &#123; enumMap.put(e.getCode().toString(), e); &#125; &#125; @Override public T convert(String source) &#123; T t = enumMap.get(source); if (ObjectUtil.isNull(t)) &#123; throw new IllegalArgumentException("无法匹配对应的枚举类型"); &#125; return t; &#125;&#125; StringCodeToEnumConverterFactory.java 1234567891011121314151617181920212223242526272829303132/** * &lt;p&gt; * 编码 -&gt; 枚举 转化器工厂类 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.config.convert.factory * @description: 编码 -&gt; 枚举 转化器工厂类 * @author: yangkai.shen * @date: Created in 2019-01-30 11:09 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */public class StringCodeToEnumConverterFactory implements ConverterFactory&lt;String, BaseEnum&gt; &#123; private static final Map&lt;Class, Converter&gt; CONVERTERS = Maps.newHashMap(); /** * 获取一个从 Integer 转化为 T 的转换器，T 是一个泛型，有多个实现 * * @param targetType 转换后的类型 * @return 返回一个转化器 */ @Override public &lt;T extends BaseEnum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) &#123; Converter&lt;String, T&gt; converter = CONVERTERS.get(targetType); if (converter == null) &#123; converter = new StringToEnumConverter&lt;&gt;(targetType); CONVERTERS.put(targetType, converter); &#125; return converter; &#125;&#125; 3.6. 将转化器工厂添加进 Spring Boot 配置 WebMvcConfig.java 12345678910111213141516171819202122232425/** * &lt;p&gt; * MVC通用配置 * &lt;/p&gt; * * @package: com.xkcoding.springboottest.config * @description: MVC通用配置 * @author: yangkai.shen * @date: Created in 2019-01-30 11:33 * @copyright: Copyright (c) 2019 * @version: V1.0 * @modified: yangkai.shen */@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; /** * 枚举类的转换器工厂 addConverterFactory */ @Override public void addFormatters(FormatterRegistry registry) &#123; registry.addConverterFactory(new IntegerCodeToEnumConverterFactory()); registry.addConverterFactory(new StringCodeToEnumConverterFactory()); &#125;&#125; 这样我们就可以优雅的实现枚举对象参数的自动转换了，并且支持多个类型转换。其中的类型转换失败异常，可以使用全局异常拦截来处理，不会的小伙伴可以参考以前的文章。https://xkcoding.com/2018/08/20/spring-boot-global-exception-handler.html 4. 测试 4.1. Get 请求 4.2. Post 请求 5. 代码地址 https://github.com/xkcoding/owntest/tree/master/spring-boot-test]]></content>
      <categories>
        <category>技术相关</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改 git 提交的时间]]></title>
    <url>%2F2019%2F01%2F21%2Fmodify-git-commit-timestamp.html</url>
    <content type="text"><![CDATA[有时候我们需要修改 git commit 时间，可以通过下面的方法解决。 修改当前本地提交的commit时间 1git commit --amend --date="2019-01-01T00:00:00+0800" -am ":memo: 更新 TODO.md" 修改之前提交的某次commit时间，首先通过 git log 获取提交的唯一id，然后 1git commit --amend --date="2019-01-01T00:00:00+0800" -C edd2dbbe31fbab492f337628011119493a12a9c6 对于之前已经提交到远程仓库的，需要再 git push 一次，即可推送到远程仓库]]></content>
      <categories>
        <category>技术相关</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 Nginx 413 Request Entity Too Large 问题]]></title>
    <url>%2F2019%2F01%2F17%2Fsolve-nginx-413-problem.html</url>
    <content type="text"><![CDATA[使用 Spring Boot 文件上传的时候，前端使用 nginx 代理后端请求，出现如下 413 Request Entity Too Large 这个错误。 解决方法其实也十分简单，只需要在 nginx 配置文件里添加如下内容，重启 nginx，即可解决。 1234567server &#123; # ... listen 80; server_name localhost; client_max_body_size 20M; # ...&#125; 重启 nginx，nginx -s reload，大功告成！]]></content>
      <categories>
        <category>技术相关</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 Mac 安装最新版 minikube 出现的问题]]></title>
    <url>%2F2019%2F01%2F14%2Fsolve-mac-install-minikube-problem.html</url>
    <content type="text"><![CDATA[kubernetes (本文后续简称 k8s )，是一个开源的，用于管理云平台中多个主机上的容器化的应用。Mac 本地运行 k8s 最快的方式，肯定是基于单节点的 minikube 来搭建。人人都说 minikube 搭建 k8s 最简单、快速、只需要傻瓜式输入命令就可以搭建成功，可事实并非如此，比如笔者在搭建的过程中就遇到了 版本 和 代理 的问题。 下面我将对遇到的问题一一进行解答。 1. 硬件环境 系统：MacOS Mojave 10.14.2 (18C54) 2. 软件环境 2.1. 虚拟机 这里我使用的是 VirtualBox，使用版本Virtual Box 5.2.22 r126460 (Qt5.6.3)，当然也可以使用其他虚拟软件，参考：https://kubernetes.io/docs/tasks/tools/install-minikube/#install-a-hypervisor 2.2. 安装 kubectl 笔者安装的时候，最新版本为 v1.13.1 有2种安装方式： 使用 brew 安装，brew install kubernetes-cli 使用二进制方式安装 下载二进制文件 curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.13.1/bin/darwin/amd64/kubectl 修改文件权限 chmod +x ./kubectl 移动文件到用户 bin 目录 sudo mv ./kubectl /usr/local/bin/kubectl 2.3. 安装 minikube 笔者安装的时候，最新版本为 v0.32.0 有2种安装方式： 使用 brew 安装，brew cask install minikube 使用二进制方式安装 下载二进制文件并修改文件权限 curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.32.0/minikube-darwin-amd64 \ &amp;&amp; chmod +x minikube 移动文件到用户 bin 目录 sudo cp minikube /usr/local/bin &amp;&amp; rm minikube 3. 使用 minikube 启动 k8s minikube start 4. 💣 异常 💣 minikube 默认使用的 k8s 版本与本地 kubecli 版本不一致，部分错误日志如下： 123456789101112131415161718192021222324252627$ minikube startStarting local Kubernetes v1.12.4 cluster...Starting VM...Downloading Minikube ISO 178.88 MB / 178.88 MB [============================================] 100.00% 0sGetting VM IP address...E0109 17:30:57.090762 47169 start.go:211] Error parsing version semver: Version string emptyMoving files into cluster...Downloading kubeadm v1.12.4Downloading kubelet v1.12.4Finished Downloading kubeadm v1.12.4Finished Downloading kubelet v1.12.4Setting up certs...Connecting to cluster...Setting up kubeconfig...Stopping extra container runtimes...Starting cluster components...E0109 17:38:49.423563 47169 start.go:343] Error starting cluster: kubeadm init errorsudo /usr/bin/kubeadm init --config /var/lib/kubeadm.yaml --ignore-preflight-errors=DirAvailable--etc-kubernetes-manifests --ignore-preflight-errors=DirAvailable--data-minikube --ignore-preflight-errors=Port-10250 --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml --ignore-preflight-errors=FileAvailable--etc-kubernetes-manifests-etcd.yaml --ignore-preflight-errors=Swap --ignore-preflight-errors=CRI running command: : Process exited with status 2================================================================================An error has occurred. Would you like to opt in to sending anonymized crashinformation to minikube to help prevent future errors?To opt out of these messages, run the command: minikube config set WantReportErrorPrompt false================================================================================Please enter your response [Y/n]: % 解决： https://github.com/kubernetes/minikube/issues/3517#issuecomment-453035044 因为 minikube 默认使用的 v1.12.x 版本的 k8s，但是我们安装的 kubectl 版本为 v1.13.1，所以可以使用如下命令解决，minikube start --alsologtostderr --kubernetes-version v1.13.1 代理问题，因为我们伟大的祖国繁荣富强，导致无法下载k8s镜像，部分错误日志如下： 12345I0114 10:47:38.727892 4695 utils.go:224] ! error execution phase preflight: [preflight] Some fatal errors occurred:I0114 10:47:38.727931 4695 utils.go:224] ! [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-apiserver:v1.13.1: output: Error response from daemon: Get https://k8s.gcr.io/v2/: proxyconnect tcp: dial tcp :80: connect: connection refusedI0114 10:47:38.727941 4695 utils.go:224] ! , error: exit status 1I0114 10:47:38.727963 4695 utils.go:224] ! [ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-controller-manager:v1.13.1: output: Error response from daemon: Get https://k8s.gcr.io/v2/: proxyconnect tcp: dial tcp :80: connect: connection refusedI0114 10:47:38.727975 4695 utils.go:224] ! , error: exit status 1 解决： https://github.com/kubernetes/minikube/issues/3517#issuecomment-453906287 在启动 minikube 的时候加上代(fan)理(qiang)地址，使用 --docker-env 参数添加系统环境变量，完整命令如下： minikube start --alsologtostderr --kubernetes-version v1.13.1 --docker-env HTTP_PROXY=http://10.0.2.2:1087 --docker-env HTTPS_PROXY=http://10.0.2.2:1087 --docker-env NO_PROXY=10.0.2.2,$(minikube ip) 参数解析： 10.0.2.2 这个ip其实是因为 virtual box 里虚拟机如果使用NAT模式的网卡的时候 10.0.2.2 默认指向的是宿主机的 127.0.0.1，参考地址：https://forums.docker.com/t/beginner-having-trouble-with-docker-behind-company-proxy/3968 5. 启动 部分启动成功日志信息： 123456789101112131415.....I0114 13:35:19.102229 7316 utils.go:224] &gt; Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:I0114 13:35:19.102246 7316 utils.go:224] &gt; https://kubernetes.io/docs/concepts/cluster-administration/addons/I0114 13:35:19.102260 7316 utils.go:224] &gt; You can now join any number of machines by running the following on each nodeI0114 13:35:19.102287 7316 utils.go:224] &gt; as root:I0114 13:35:19.102307 7316 utils.go:224] &gt; kubeadm join localhost:8443 --token agf5vb.45h4fw6jqy7o2yff --discovery-token-ca-cert-hash sha256:c60ce3456d2ac3225edc119d1792d1b6c20b40b03cf0812ddf8d2fc867f21bf3Verifying kubelet health ...I0114 13:35:19.134467 7316 ssh_runner.go:137] Run with output: sudo systemctl is-active kubeletI0114 13:35:19.141912 7316 utils.go:224] &gt; activeVerifying apiserver health ...I0114 13:35:19.149990 7316 kubeadm.go:99] https://192.168.99.101:8443/healthz response: &lt;nil&gt; &amp;&#123;Status:200 OK StatusCode:200 Proto:HTTP/1.1 ProtoMajor:1 ProtoMinor:1 Header:map[Date:[Mon, 14 Jan 2019 05:35:19 GMT] Content-Length:[2] Content-Type:[text/plain; charset=utf-8]] Body:0xc0004b9d00 ContentLength:2 TransferEncoding:[] Close:false Uncompressed:false Trailer:map[] Request:0xc0002da500 TLS:0xc000354000&#125;Kubectl is now configured to use the cluster.Loading cached images from config file.Everything looks great. Please enjoy minikube! minikube dashboard 之后，启动 dashboad 截图：]]></content>
      <categories>
        <category>技术相关</category>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
        <tag>minikube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[溜了溜了2018，来了来了2019]]></title>
    <url>%2F2018%2F12%2F31%2Fbye2018-hello2019.html</url>
    <content type="text"><![CDATA[18年不知不觉已到尽头，但自己总觉得好像18年只过了9个月一样。抓住18年的小尾巴，给自己的2018做个年终总结，为2019做个展望。 1. 总结18 1.1. 生活方面 今年相比去年，少了一次旅游，但是吃的方面，比去年更讲究了不少。有她的日子都很精致。 1.2. 感情方面 18年算是迈出了关键的一步吧。正月里去了她家，见了下她的父母，经历了下那儿的过年的风俗，还算顺利。5月带她回家，见了爸妈，虽然还有些小意外，不过我坚信自己可以处理好。 1.3. 工作方面 18年3月初，毅然决然的离开了北京，离开了那个氛围很好的图迹，回到杭州，不过生活并没想象中的美好，说实话，挺后悔的。嗯，不过，在美创的日子也还算不错，组长人好，团队成员也好相处，但总没有图迹的感觉，也可能是想那群“哥文化”的小伙伴了吧。 今年工作上最大的收货应该就是，之前东哥、明哥安排工作，我去依照时间计划执行，现在需要我去定todo-list，定工作量，安排小伙伴一起开发；之前只需对自己得代码负责，现在需要对自己得产品负责；之前考虑代码功能实现，现在考虑产品整体架构。 1.4. 技术方面 作为一个“伪全栈”，今年几乎没写前端，应该是最大的遗憾了。不过好在后端技术没落下，给team一起组织了几场topic，分享了下《Java8新特性》《微服务架构》，为团队引入优秀的开源框架hutool、guava、lombok等，并定义一套web开发规范，team也按照这个在执行，对团队也还算有些贡献。 负责元数据产品的开发，也对elasticsearch和neo4j等技术更加熟练的使用。 swarm，k8s，rancher自己瞎玩的也还算顺溜。 1.5. 开源方面 今年最大的坚持应该就是spring-boot-demo，地址：https://github.com/xkcoding/spring-boot-demo ，稍微介绍下吧，基于SpringBoot版本2.1.0.RELEASE版本，里面总共包含47个demo，当然都不仅仅是简单的demo而已，从基础的功能集成，到定时任务的管理，再到大家比较关注的前后端分离的动态权限管理、工作流等等都有涉及，希望可以做成入门SpringBoot最快，集成最简单的demo。 然后就是shiny-telegram，地址：https://github.com/xkcoding/shiny-telegram ，主要就是爬虫，爬取Mac破解软件网站https://xclient.info/ 的破解软件下载地址和版本信息，主要使用技术点xpath、jsoup、selenium和phantomjs。 还有个半成品 scaffold，地址：https://github.com/xkcoding/scaffold ，主要就是一个快速开发的脚手架工程，前后端分离，包含基础权限管理，用户管理，日志管理，菜单管理，定时任务管理，工作流等功能，希望明年可以给它完善。 还有最后一个spring-cloud-learning-simple-demo，地址：https://github.com/xkcoding/spring-cloud-learning-simple-demo ，主要就是给team分享微服务的时候写的一个springcloud的集成demo，帮助学习各个组件使用的，当然啦，也是基于SpringBoot 2.X的。总得来说，对自己今年的执行力还算满意。 1.6. 博客方面 emmm… 这是今年最大的痛，今年更新的博文频率比较低，不找理由，就是自己太懒。 2. 展望19 希望父母头发可以白的慢一点，希望自己和她可以相处的更好，希望父母可以更好的接纳她，希望自己可以成为精致的猪猪男孩，希望来一次旅游。 希望19年博客可以每月保底3篇。 希望19年可以每天都在github留下足迹，不管有没有人star自己的项目，但是我想对已经star的小伙伴和我自己的代码负责到底，这是我的态度。 希望自己可以有些存款，17、18年底都是口袋空空，希望19的年底可以不空了。 希望自己仍然可以保持对代码的热爱，对技术执着，我一直相信自己的能力，我一直在等待一个合适的机会。]]></content>
      <categories>
        <category>总结展望</category>
      </categories>
      <tags>
        <tag>总结展望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,Spring Boot!]]></title>
    <url>%2F2018%2F11%2F07%2Fspring-boot-start.html</url>
    <content type="text"><![CDATA[Spring Boot 是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 官网这个logo下有这么一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 1. 了解 Spring Boot 1.1. 为什么学习 Spring Boot java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： 复杂的配置。 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.2. Spring Boot特点 Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 2. 快速入门 2.1.创建工程 在IDEA中选择 Spring Initializr 配置项目基础信息 选择依赖，也可以后续在 pom.xml 里手动添加 配置项目路径 FINISH！ 2.2. 启动类 Spring Boot项目通过main函数即可启动，刚刚创建工程的时候已经自动创建了一个启动类： 然后查看启动类： 1234567@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 2.3. 编写Controller 接下来，我们就可以像以前那样开发 SpringMVC 的项目了！ 我们编写一个Controller： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("/hello") public String hello() &#123; return "hello, spring boot!"; &#125;&#125; 2.4. 启动测试 接下来，我们运行main函数，查看控制台： ①是Spring MVC的映射路径 ②是Tomcat监听的端口是8080 打开页面访问：http://localhost:8080/hello 测试成功了！]]></content>
      <categories>
        <category>技术相关</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后台运行node服务]]></title>
    <url>%2F2018%2F09%2F28%2Frun-node-service-in-background.html</url>
    <content type="text"><![CDATA[前言 很多时候，我们需要后台运行我们的 node 服务，有3种方式可以实现。 使用Linux自带的nohup命令 使用forever命令 使用PM2管理node进程 这里推荐使用PM2来管理和运行我们的node服务 1. 简介 PM2 是一个开源的带有负载均衡功能的 node 应用的进程管理器，包括守护进程，监控，日志的一整套完整的功能，基本是Nodejs应用程序不二的守护进程选择，事实上它并不仅仅可以启动Nodejs的程序，只要是一般的脚本的程序它同样可以胜任。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载，PM2是完美的选择。 2. 安装 1npm install pm2 -g 3. 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ pm2 start app.js # 启动app.js应用程序$ pm2 start app.js -i 4 # cluster mode 模式启动4个app.js的应用实例 # 4个应用程序会自动进行负载均衡$ pm2 start app.js --name="api" # 启动应用程序并命名为 "api"$ pm2 start app.js --watch # 当文件变化时自动重启应用$ pm2 start npm -- start # 当前目录执行npm start$ pm2 start npm --name "es-head" -- start # 当前目录执行npm start并命名为 "es-head"$ pm2 start script.sh # 启动 bash 脚本$ pm2 list # 列表 PM2 启动的所有的应用程序$ pm2 monit # 显示每个应用程序的CPU和内存占用情况$ pm2 show [app-name] # 显示应用程序的所有信息$ pm2 logs # 显示所有应用程序的日志$ pm2 logs [app-name] # 显示指定应用程序的日志$ pm2 stop all # 停止所有的应用程序$ pm2 stop 0 # 停止 id为 0的指定应用程序$ pm2 restart all # 重启所有应用$ pm2 reload all # 重启 cluster mode下的所有应用$ pm2 gracefulReload all # Graceful reload all apps in cluster mode$ pm2 delete all # 关闭并删除所有应用$ pm2 delete 0 # 删除指定应用 id 0$ pm2 scale api 10 # 把名字叫api的应用扩展到10个实例$ pm2 reset [app-name] # 重置重启数量$ pm2 startup # 创建开机自启动命令$ pm2 save # 保存当前应用列表$ pm2 resurrect # 重新加载保存的应用列表 4. 参考 PM2官方文档]]></content>
      <categories>
        <category>技术相关</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Neo4j 和 Mysql 查询基本语法的区别]]></title>
    <url>%2F2018%2F09%2F20%2Fquery-language-differences-between-neo4j-and-mysql.html</url>
    <content type="text"><![CDATA[每种数据库都有自己的一套查询语言或者标准，即使是同为关系型数据库的Oracle、Sql Server 和 MySQL，其在一些语法细节上也有差异，更别说 Mongo, Redis 类似的非关系型数据库了。Neo4j 也一样，有自己专属的查询语言 Cypher。深入学习其实发现 Neo4j 的查询语法并不难去学习，因为 Cypher 的语意确实简洁，直观。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384-- 1. 全表扫描 ---- mysql --SELECT p.*FROM products as p;-- neo4j --MATCH (p:Product)RETURN p;-- 2. 查询价格最贵的10个商品，只返回商品名字和单价 ---- mysql --SELECT p.ProductName, p.UnitPriceFROM products as pORDER BY p.UnitPrice DESCLIMIT 10;-- neo4j --MATCH (p:Product)RETURN p.productName, p.unitPriceORDER BY p.unitPrice DESCLIMIT 10;-- 3. 按照商品名字筛选 ---- mysql --SELECT p.ProductName, p.UnitPriceFROM products AS pWHERE p.ProductName = &apos;Chocolade&apos;;-- neo4j --MATCH (p:Product)WHERE p.productName = &quot;Chocolade&quot;RETURN p.productName, p.unitPrice;-- 其他的写法 --MATCH (p:Product &#123;productName:&quot;Chocolade&quot;&#125;)RETURN p.productName, p.unitPrice;-- 4. 按照商品名字筛选2 ---- mysql --SELECT p.ProductName, p.UnitPriceFROM products as pWHERE p.ProductName IN (&apos;Chocolade&apos;,&apos;Chai&apos;);-- neo4j --MATCH (p:Product)WHERE p.productName IN [&apos;Chocolade&apos;,&apos;Chai&apos;]RETURN p.productName, p.unitPrice;-- 5. 模糊查询和数值过滤 ---- mysql --SELECT p.ProductName, p.UnitPriceFROM products AS pWHERE p.ProductName LIKE &apos;C%&apos; AND p.UnitPrice 100;-- neo4j --MATCH (p:Product)WHERE p.productName STARTS WITH &quot;C&quot; AND p.unitPrice 100RETURN p.productName, p.unitPrice;-- 6. 多表联合查询---- mysql --SELECT DISTINCT c.CompanyNameFROM customers AS cJOIN orders AS o ON (c.CustomerID = o.CustomerID)JOIN order_details AS od ON (o.OrderID = od.OrderID)JOIN products AS p ON (od.ProductID = p.ProductID)WHERE p.ProductName = &apos;Chocolade&apos;;-- neo4j --MATCH (p:Product &#123;productName:&quot;Chocolade&quot;&#125;)&lt;-[:PRODUCT]-(:Order)&lt;-[:PURCHASED]-(c:Customer)RETURN distinct c.companyName;-- 7. 分组查询 ---- mysql --SELECT e.EmployeeID, count(*) AS CountFROM Employee AS eJOIN Order AS o ON (o.EmployeeID = e.EmployeeID)GROUP BY e.EmployeeIDORDER BY Count DESC LIMIT 10;-- neo4j --MATCH (:Order)&lt;-[:SOLD]-(e:Employee)RETURN e.name, count(*) AS cntORDER BY cnt DESC LIMIT 10]]></content>
      <categories>
        <category>技术相关</category>
        <category>neo4j</category>
      </categories>
      <tags>
        <tag>neo4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 如何更新 fork 的项目到原项目的最新版本]]></title>
    <url>%2F2018%2F09%2F18%2Fhow-to-update-the-fork-project.html</url>
    <content type="text"><![CDATA[在 github 上 fork 了一个项目之后，如何使自己 fork 的项目和原先作者的项目分支保持同步呢，下面我使用 hutool 的项目做示范，手摸手示范如何使 fork 的项目与原项目分支保持同步。 查看远程的版本库地址 123$ git remote -v origin https://github.com/xkcoding/hutool.git (fetch) origin https://github.com/xkcoding/hutool.git (push) 添加原项目 git 地址到本地版本库 1$ git remote add upstream https://github.com/looly/hutool.git 检查版本库是否添加成功 12345$ git remote -vorigin https://github.com/xkcoding/hutool.git (fetch)origin https://github.com/xkcoding/hutool.git (push)upstream https://github.com/looly/hutool.git (fetch)upstream https://github.com/looly/hutool.git (push) 原项目更新内容同步到本地 123456789$ git fetch upstream remote: Counting objects: 360, done.remote: Compressing objects: 100% (148/148), done.remote: Total 360 (delta 158), reused 339 (delta 137), pack-reused 0Receiving objects: 100% (360/360), 87.95 KiB | 45.00 KiB/s, done.Resolving deltas: 100% (158/158), completed with 66 local objects.From https://github.com/looly/hutool * [new branch] v4-dev -&gt; upstream/v4-dev * [new branch] v4-master -&gt; upstream/v4-master 查看本地分支 1234567$ git branch -a * v4-master remotes/origin/HEAD -&gt; origin/v4-master remotes/origin/v4-dev remotes/origin/v4-master remotes/upstream/v4-dev remotes/upstream/v4-master 同步更新内容到本地对应分支 1$ git merge upstream/v4-master 提交更新内容到 fork 地址 1git push]]></content>
      <categories>
        <category>技术相关</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 全局异常处理]]></title>
    <url>%2F2018%2F08%2F20%2Fspring-boot-global-exception-handler.html</url>
    <content type="text"><![CDATA[我们在做 Web 应用的时候，请求处理过程中发生错误异常是一个非常常见的情况，但是异常的处理方式和放回的异常内容并没有做一个统一的处理。在现在这种前后端分离的时代，不论响应成功还是失败的数据格式都需要保持一致。 1. 返回格式统一封装 Api.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.xkcoding.scaffold.common;import com.xkcoding.scaffold.common.status.Status;import lombok.Data;import java.io.Serializable;/** * &lt;p&gt; * API 统一返回格式封装 * &lt;/p&gt; * * @package: com.xkcoding.scaffold.common * @description： API 统一返回格式封装 * @author: yangkai.shen * @date: Created in 2018/8/2 下午6:15 * @copyright: Copyright (c) 2018 * @version: V1.0 * @modified: yangkai.shen */@Datapublic class Api implements Serializable &#123; private static final long serialVersionUID = 1672493411204459264L; /** * 返回码 */ private Integer code; /** * 返回信息 */ private String msg; /** * 返回数据 */ private Object data; /** * 默认构造 */ public Api() &#123; this.code = Status.SUCCESS.getCode(); this.msg = Status.SUCCESS.getMsg(); &#125; /** * 构造 API 返回对象 * * @param code 返回码 * @param msg 返回信息 * @param data 数据 */ public Api(Integer code, String msg, Object data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; /** * 通用构造包含返回信息的 Api &lt;br&gt; * 主要用于只包含返回信息，不包含数据时的返回 * * @param code 状态码 * @param msg 信息 * @return Api */ public static Api of(int code, String msg, Object data) &#123; return new Api(code, msg, data); &#125; /** * 通用构造包含返回信息的 Api &lt;br&gt; * 主要用于只包含返回信息，不包含数据时的返回 * * @param code 状态码 * @param msg 信息 * @return Api */ public static Api ofMessage(int code, String msg) &#123; return new Api(code, msg, null); &#125; /** * 通用构造包含返回信息的 Api &lt;br&gt; * 主要用于只包含返回信息，不包含数据时的返回 * * @param msg 信息 * @return Api */ public static Api ofMessage(String msg) &#123; return new Api(Status.SUCCESS.getCode(), msg, null); &#125; /** * 通用构造包含返回数据的 Api &lt;br&gt; * 主要用于操作成功时的返回(不带数据) * * @return Api */ public static Api ofSuccess() &#123; return new Api(Status.SUCCESS.getCode(), Status.SUCCESS.getMsg(), null); &#125; /** * 通用构造包含返回数据的 Api &lt;br&gt; * 主要用于操作成功时的返回 * * @param data 操作成功时需要返回的数据 * @return Api */ public static Api ofSuccess(Object data) &#123; return new Api(Status.SUCCESS.getCode(), Status.SUCCESS.getMsg(), data); &#125; /** * 通过 Status 构造 Api &lt;br&gt; * 主要用于出现异常时的返回 * * @param status &#123;@link Status&#125; * @return Api */ public static Api ofStatus(Status status) &#123; return new Api(status.getCode(), status.getMsg(), null); &#125;&#125; 2. 通用状态统一封装 Status.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.xkcoding.scaffold.common.status;import com.xkcoding.scaffold.common.BaseEnum;import lombok.Getter;/** * &lt;p&gt; * 状态码枚举 * &lt;/p&gt; * * @package: com.xkcoding.scaffold.common * @description： 状态码枚举 * @author: yangkai.shen * @date: Created in 2018/8/2 下午7:49 * @copyright: Copyright (c) 2018 * @version: V1.0 * @modified: yangkai.shen */@Getterpublic enum Status implements BaseEnum &#123; /** * 成功 */ SUCCESS(200, "成功"), /** * 请求错误 */ BAD_REQUEST(400, "请求错误"), /** * 尚未登录 */ UNAUTHORIZED(401, "尚未登录"), /** * 权限不够 */ FORBIDDEN(403, "权限不够"), /** * 请求不存在 */ REQUEST_NOT_FOUND(404, "请求不存在"), /** * 服务器内部错误 */ INTERNAL_SERVER_ERROR(500, "服务器内部错误"), /** * 用户名或密码错误 */ USERNAME_OR_PASSWORD_ERROR(50000, "用户名或密码错误"), /** * 用户不存在 */ USER_NOT_EXIST(50001, "账号不存在"), /** * 用户已被禁用 */ USER_DISABLE(50002, "账号已被禁用"), /** * 账号已删除 */ USER_DELETED(50003, "账号已删除"), /** * 验证码错误 */ VERIFY_CODE_ERROR(50004, "验证码错误"), /** * 登录成功 */ LOGIN_SUCCESS(50005, "登录成功"), /** * 退出成功 */ LOGOUT_SUCCESS(50006, "退出成功"), /** * 验证码异常 */ CODE_ERROR(50007, "验证码异常"), /** * 获取验证码的值失败 */ CODE_GET_ERROR(50008, "获取验证码的值失败"), /** * 验证码的值不能为空 */ CODE_VALUE_NOT_NULL(50009, "验证码的值不能为空"), /** * 验证码不存在 */ CODE_NOT_FOUND(50010, "验证码不存在"), /** * 验证码已过期 */ CODE_IS_EXPIRED(50011, "验证码已过期"), /** * 验证码不匹配 */ CODE_NOT_MATCH(50012, "验证码不匹配"), /** * 验证码发送异常 */ CODE_SEND_ERROR(50012, "验证码发送异常"); private Integer code; private String msg; Status(Integer code, String msg) &#123; this.code = code; this.msg = msg; &#125;&#125; 3. 自定义业务异常类 ScaffoldException.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.xkcoding.scaffold.exception;import com.xkcoding.scaffold.common.status.Status;import lombok.Getter;/** * &lt;p&gt; * 通用全局异常 * &lt;/p&gt; * * @package: com.xkcoding.scaffold.exception * @description： 通用全局异常 * @author: yangkai.shen * @date: Created in 2018/8/2 下午7:59 * @copyright: Copyright (c) 2018 * @version: V1.0 * @modified: yangkai.shen */@Getterpublic class ScaffoldException extends Exception &#123; /** * 异常码 */ private Integer code; /** * 返回信息 */ private String msg; /** * 返回内容 */ private Object data; public ScaffoldException(Integer code, String msg) &#123; super(msg); this.code = code; this.msg = msg; &#125; public ScaffoldException(Integer code, String msg, Object data) &#123; super(msg); this.code = code; this.msg = msg; this.data = data; &#125; public ScaffoldException(Status status) &#123; super(status.getMsg()); this.code = status.getCode(); this.msg = status.getMsg(); &#125; public ScaffoldException(Status status, Object data) &#123; super(status.getMsg()); this.code = status.getCode(); this.msg = status.getMsg(); this.data = data; &#125;&#125; 4. 配置 Spring Boot 配置 application.yml 主要是为了对404错误作处理 1234567spring: ### 开启404异常抛出 ### mvc: throw-exception-if-no-handler-found: true ### 关闭静态资源映射 ### resources: add-mappings: false 5. 统一异常处理 GlobalExceptionHandler.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.xkcoding.scaffold.handler;import com.xkcoding.scaffold.common.Api;import com.xkcoding.scaffold.common.status.Status;import com.xkcoding.scaffold.exception.ScaffoldException;import lombok.extern.slf4j.Slf4j;import org.springframework.security.access.AccessDeniedException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.NoHandlerFoundException;/** * &lt;p&gt; * 全局异常处理 * &lt;/p&gt; * * @package: com.xkcoding.scaffold.handler * @description： 全局异常处理 * @author: yangkai.shen * @date: Created in 2018/8/2 下午8:05 * @copyright: Copyright (c) 2018 * @version: V1.0 * @modified: yangkai.shen */@Slf4j@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(value = Exception.class) @ResponseBody public Api handlerException(Exception e) &#123; if (e instanceof NoHandlerFoundException) &#123; log.error("【全局异常拦截】NoHandlerFoundException: 请求方法 &#123;&#125;, 请求路径 &#123;&#125;", ((NoHandlerFoundException) e).getRequestURL(), ((NoHandlerFoundException) e).getHttpMethod()); return Api.ofStatus(Status.REQUEST_NOT_FOUND); &#125; else if (e instanceof ScaffoldException) &#123; log.error("【全局异常拦截】ScaffoldException: 状态码 &#123;&#125;, 异常信息 &#123;&#125;", ((ScaffoldException) e).getCode(), e.getMessage()); return new Api(((ScaffoldException) e).getCode(), e.getMessage(), ((ScaffoldException) e).getData()); &#125; else if (e instanceof AccessDeniedException) &#123; log.error("【全局异常拦截】AccessDeniedException: 异常信息 &#123;&#125;", e.getMessage()); return Api.ofStatus(Status.FORBIDDEN); &#125; log.error("【全局异常拦截】: 异常信息 &#123;&#125; ", e.getMessage()); return Api.ofStatus(Status.INTERNAL_SERVER_ERROR); &#125;&#125; Tip 异常处理的时候，务必在全局异常处理类中，打印异常日志，打印异常日志，打印异常日志！ 相关代码地址：https://github.com/xkcoding/scaffold]]></content>
      <categories>
        <category>技术相关</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 学习整理]]></title>
    <url>%2F2018%2F07%2F30%2Fjava8-learning.html</url>
    <content type="text"><![CDATA[前言：Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。 Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。目前大部分公司都已经在使用 Java 8开发项目。本文是我在公司的一次Java 8分享的文章，开篇先介绍了 Java 8 的发展，再分别讲述 Java 8 的新特性，同时附上一些 Demo 代码（ https://github.com/xkcoding/java8_learning ），以便更好的入门学习 Java 8，厚脸皮的求个 Star。 1. Java 8 的发展 JDK 5 自动装箱与拆箱 JDK1.5为每一个基本数据类型定义了一个封装类。使java中的基本数据类型也有自己的对象 12345678int --&gt;Integerdouble --&gt; Doublelong --&gt; Longchar --&gt; Characterfloat --&gt; Floatboolean --&gt; Booleanshort --&gt; Shortbyte -- &gt; Byte 自动装包：将基本类型转换成为对象，例如：int --&gt; Integer 自动拆包：将对象转换成为基本数据类型，例如：Integer --&gt; int 对于 JDK1.5 之前集合总不能存放基本数据类型的问题，现在也能够解决。 枚举 枚举是 JDK1.5 推出的一个比较重要的特性。其关键字为 enum 例如：定义代表交通灯的枚举 123public enum MyEnum&#123; RED,GREEN,YELLOW&#125; 静态导入 优点：使用静态导入可以使被导入类的所有静态变量和静态方法在当前类直接可见，使用这些静态成员无需再给出他们的类名。 缺点：过度使用会降低代码的可读性 可变参数 在JDK1.5以前，当我们要为一个方法传递多个类型相同的参数时， 我们有两种方法解决 直接传递一个数组过去 有多少个参数就传递多少个参数。 例如： 12public void printColor(String red,String green,String yellow)&#123; &#125; 或者 123public void printColor(String[] colors)&#123;&#125; 这样编写方法参数虽然能够实现我们想要的效果，但是，这样是不是有点麻烦呢？ 再者，如果参数个数不确定，我们怎么办呢？Java JDK1.5为我们提供的可变参数就能够完美的解决这个问题. 例如： 123public void printColor(String... colors)&#123;&#125; 如果参数的类型相同，那么可以使用 类型+三个点 ，后面跟一个参数名称的形式。 这样的好处就是，只要参数类型相同，无论传递几个参数都没有限制 注意：可变参数必须是参数列表的最后一项（该特性对对象和基本数据类型都适用） 泛型 12//给集合指定存入类型，上面这个集合在存入数据的时候必须存入String类型的数据，否则编译器会报错List&lt;String&gt; strs = new ArrayList&lt;String&gt;(); “泛型” 意味着编写的代码可以被不同类型的对象所重用。 可见泛型的提出是为了编写重用性更好的代码。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 比如常见的集合类 LinkedList，其实现的接口名后有个特殊的部分 &lt;&gt;，而且它的成员的类型 Link 也包含一个 &lt;&gt;，这个符号的就是类型参数， 它使得在运行中，创建一个 LinkedList 时可以传入不同的类型，比如 new LinkedList，这样它的成员存放的类型也是 String。 For-Each循环 例如上面这个集合我们可以通过for-each遍历，这样更加简单清晰。 123for(String s : strs)&#123; System.out.println(s); &#125; 注意：使用for-each遍历集合时，要遍历的集合必须实现了Iterator接口 线程并发库 线程并发库是 Java1.5 提出的关于多线程处理的高级功能，所在包：java.util.concurrent 包括 线程互斥工具类：Lock，ReadWriteLock 线程通信：Condition 线程池：ExecutorService 同步队列：ArrayBlockingQueue 同步集合：ConcurrentHashMap，CopyOnWriteArrayList 线程同步工具：Semaphore JDK 6 Desktop类和SystemTray类 前者可以用来打开系统默认浏览器浏览指定的URL，打开系统默认邮件客户端给指定的邮箱发邮件，用默认应用程序打开或编辑文件(比如，用记事本打开以 txt 为后缀名的文件)，用系统默认的打印机打印文档；后者可以用来在系统托盘区创建一个托盘程序。 使用Compiler API 现在我们可以用JDK1.6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。 这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件。 当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统； Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译，而且是跨平台的。 轻量级Http Server API JDK1.6 提供了一个简单的 Http Server API，据此我们可以构建自己的嵌入式 Http Server，它支持Http和Https协议，提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的 Http Server API来实现，程序员必须自己实现 HttpHandler 接口，HttpServer 会调用 HttpHandler 实现类的回调方法来处理客户端请求，在这里，我们把一个 Http 请求和它的响应称为一个交换，包装成 HttpExchange 类，HttpServer 负责将 HttpExchange 传给 HttpHandler 实现类的回调方法。 用Console开发控制台程序 JDK1.6 中提供了 java.io.Console 类专用来访问基于字符的控制台设备。 你的程序如果要与 Windows 下的 cmd 或者 Linux 下的 Terminal 交互，就可以用 Console 类代劳。 但我们不总是能得到可用的 Console，一个JVM是否有可用的 Console 依赖于底层平台和 JVM 如何被调用。 如果JVM是在交互式命令行(比如 Windows 的 cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的 Console 实例。 对脚本语言的支持 如：ruby，groovy，javascript。 JDK 7 数字变量对下滑线的支持 JDK1.7可以在数值类型的变量里添加下滑线。 例如： 123int num = 1234_5678_9; float num2 = 222_33F; long num3 = 123_000_111L; 注意，有几个地方是不能添加的： 数字的开头和结尾 小数点前后 F或者L前 switch对String的支持 1234567891011String status = "orderState"; switch (status) &#123; case "ordercancel": System.out.println("订单取消"); break; case "orderSuccess": System.out.println("预订成功"); break; default: System.out.println("状态未知"); &#125; try-with-resource try-with-resources 是一个定义了一个或多个资源的 try 声明，这个资源是指程序处理完它之后需要关闭它的对象。 try-with-resources 确保每一个资源在处理完成后都会被关闭。 可以使用try-with-resources的资源有： 任何实现了 java.lang.AutoCloseable 接口 java.io.Closeable 接口的对象。 例如： 123456public static String readFirstLineFromFile(String path) throws IOException &#123; try (BufferedReader br = new BufferedReader(new FileReader(path))) &#123; return br.readLine(); &#125; &#125; 在 java 7 以及以后的版本里，BufferedReader 实现了 java.lang.AutoCloseable 接口。 由于 BufferedReader 定义在 try-with-resources 声明里，无论 try 语句正常还是异常的结束， 它都会自动的关掉。而在 java7 以前，你需要使用 finally 块来关掉这个对象。 捕获多种异常并用改进后的类型检查来重新抛出异常 12345678910public static void first()&#123; try &#123; BufferedReader reader = new BufferedReader(new FileReader("")); Connection con = null; Statement stmt = con.createStatement(); &#125; catch (IOException | SQLException e) &#123; //捕获多个异常，e就是final类型的 e.printStackTrace(); &#125; &#125; 优点：用一个 catch 处理多个异常，比用多个 catch 每个处理一个异常生成的字节码要更小更高效。 创建泛型时类型推断 只要编译器可以从上下文中推断出类型参数，你就可以用一对空着的尖括号 &lt;&gt; 来代替泛型参数。 这对括号私下被称为菱形(diamond)。 在Java SE 7之前，你声明泛型对象时要这样 1List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 而在Java SE7以后，你可以这样 1List&lt;String&gt; list = new ArrayList&lt;&gt;(); 因为编译器可以从前面(List)推断出推断出类型参数，所以后面的 ArrayList 之后可以不用写泛型参数了，只用一对空着的尖括号就行。 当然，你必须带着菱形 &lt;&gt;，否则会有警告的。 Java SE7 只支持有限的类型推断：只有构造器的参数化类型在上下文中被显著的声明了，你才可以使用类型推断，否则不行。 1234567List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("A"); //这个不行 list.addAll(new ArrayList&lt;&gt;()); // 这个可以 List&lt;? extends String&gt; list2 = new ArrayList&lt;&gt;(); list.addAll(list2); JDK 8 Lambda表达式和函数式接口 Lambda表达式（也称为闭包）是Java 8中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：函数式开发者非常熟悉这些概念。很多JVM平台上的语言（Groovy、Scala等）从诞生之日就支持Lambda表达式，但是Java开发者没有选择，只能使用匿名内部类代替Lambda表达式。 Lambda的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成。 Lambda的设计者们为了让现有的功能与Lambda表达式良好兼容，考虑了很多方法，于是产生了函数接口这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为Lambda表达式。java.lang.Runnable和java.util.concurrent.Callable是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解@FunctionalInterface（Java 库中的所有相关接口都已经带有这个注解了）。 接口的默认方法和静态方法 Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写。 由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。 尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果想了解更多细节，可以参考官方文档。 更好的类型推断 Java 8 编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。 参数 Value.defaultValue() 的类型由编译器推导得出，不需要显式指明。在Java 7中这段代码会有编译错误，除非使用 Value.&lt;String&gt;defaultValue()。 Optional Java应用中最常见的bug就是空指针异常。在Java 8之前，Google Guava引入了 Optionals 类来解决 NullPointerException，从而避免源码被各种 null 检查污染，以便开发者写出更加整洁的代码。Java 8也将Optional加入了官方库。 Optional 仅仅是一个容易存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查，可以参考Java 8官方文档了解更多细节。 如果Optional实例持有一个非空值，则 isPresent() 方法返回true，否则返回false；orElseGet() 方法，Optional实例持有null，则可以接受一个lambda表达式生成的默认值；map()方法可以将现有的 Optional 实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值。 Stream 新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。 Task 类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN 或者 CLOSED。现在假设有一个task集合，首先看一个问题：在这个task集合中一共有多少个OPEN状态的点？ 在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。 1234567891011121314final Collection&lt;Task&gt; tasks = Arrays.asList( new Task(Status.OPEN, 5), new Task(Status.OPEN, 13), new Task(Status.CLOSED, 8));// 使用sum()计算所有 OPEN 任务final long totalPointsOfOpenTasks = tasks .stream() .filter(task -&gt; task.getStatus() == Status.OPEN) .mapToInt(Task::getPoints) .sum();System.out.println("Total points: " + totalPointsOfOpenTasks); 首先，tasks集合被转换成steam表示；其次，在steam上的filter操作会过滤掉所有CLOSED的task；第三，mapToInt操作基于每个task实例的Task::getPoints方法将task流转换成Integer集合；最后，通过sum方法计算总和，得出最后的结果。 新的日期时间 API Java 8引入了新的Date-Time API(JSR 310)来改进时间、日期的处理。时间和日期的管理一直是最令Java开发者痛苦的问题。java.util.Date 和后来的 java.util.Calendar 一直没有解决这个问题（甚至令开发者更加迷茫）。因为上面这些原因，诞生了第三方库Joda-Time，可以替代Java的时间管理API。 Java 8中新的时间和日期管理API深受Joda-Time影响，并吸收了很多Joda-Time的精华。 第一，新的java.time包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从java.util.Calendar吸取的教训），如果某个实例需要修改，则返回一个新的对象。 第二，关注下LocalDate和LocalTime类。LocalDate仅仅包含ISO-8601日历系统中的日期部分；LocalTime则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用Clock对象构建得到。 第三，LocalDateTime类包含了LocalDate和LocalTime的信息，但是不包含ISO-8601日历系统中的时区信息。这里有一些关于LocalDate和LocalTime的例子： 如果你需要特定时区的data/time信息，则可以使用ZoneDateTime，它保存有ISO-8601日期系统的日期和时间，而且有时区信息。 Nashorn JavaScript引擎 Java 8提供了新的Nashorn JavaScript引擎，使得我们可以在JVM上开发和运行JS应用。 Nashorn JavaScript引擎是javax.script.ScriptEngine的另一个实现版本，这类Script引擎遵循相同的规则，允许Java和JavaScript交互使用。 Base64 对 Base64 编码的支持已经被加入到Java 8官方库中，这样不需要使用第三方库就可以进行Base64编码。 2. Lambda 表达式（★★） Demo 代码：https://github.com/xkcoding/java8_learning/tree/master/java8-lambda PS：个人理解类似前端 ES6 的箭头函数 2.1. 命令式和函数式 命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。 声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。 2.2. 什么是函数式编程？ 每个人对函数式编程的理解不尽相同。 我的理解是：在完成一个编程任务时，通过使用不可变的值或函数，对他们进行处理，然后得到另一个值的过程。 不同的语言社区往往对各自语言中的特性孤芳自赏。现在谈 Java 程序员如何定义函数式编程还为时尚早，但是，这根本不重要！ 我们关心的是如何写出好代码，而不是符合函数式编程风格的代码。 2.3. 行为参数化 把算法的策略（行为）作为一个参数传递给函数。 2.4. lambda 特点 匿名：它不像普通的方法那样有一个明确的名称：写得少而想得多！ 函数：Lambda函数不像方法那样属于某个特定的类。但和方法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。 传递：Lambda表达式可以作为参数传递给方法或存储在变量中。 简洁：无需像匿名类那样写很多模板代码。 2.5. 函数描述符 函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，这种抽象方法叫作函数描述符。 2.6. 函数式接口，类型推断 函数式接口定义且只定义了一个抽象方法，因为抽象方法的签名可以描述Lambda表达式的签名。 函数式接口的抽象方法的签名称为函数描述符。 所以为了应用不同的Lambda表达式，你需要一套能够描述常见函数描述符的函数式接口。 2.7. Lambda 及函数式接口的例子 使用案例 Lambda 的例子 对应的函数式接口 布尔表达式 (List&lt;String&gt; list) -&gt; list.isEmpty() Predicate&lt;List&lt;String&gt;&gt; 创建对象 () -&gt; new Project() Supplier&lt;Project&gt; 消费一个对象 (Project p) -&gt; System.out.println(p.getStars()) Consumer&lt;Project&gt; 从一个对象中选择/提取 (int a, int b) -&gt; a * b IntBinaryOperator 比较两个对象 (Project p1, Project p2) -&gt; p1.getStars().compareTo(p2.getStars()) Comparator&lt;Project&gt; 或 BiFunction&lt;Project, Project, Integer&gt; 或 ToIntBiFunction&lt;Project, Project&gt; 2.8. Lambda 小结 lambda 表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回 类型，可能还有一个可以抛出的异常的列表。 lambda 表达式让你可以简洁地传递代码。 只有在接受函数式接口的地方才可以使用 lambda 表达式。 lambda 表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。 Lambda表达式所需要代表的类型称为目标类型。 3. 方法引用 方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。 方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 方法引用使用一对冒号::。 示例： 123List&lt;Person&gt; result = list.stream() .filter(Person::isStudent) // 就是方法引用 .collect(Collectors.toList()); 4. 函数式接口 Demo 代码：https://github.com/xkcoding/java8_learning/tree/master/java8-functional 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 函数式接口可以被隐式转换为lambda表达式。 函数式接口可以现有的函数友好地支持 lambda。 JDK 1.8之前已有的函数式接口: java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.nio.file.PathMatcher java.lang.reflect.InvocationHandler java.beans.PropertyChangeListener java.awt.event.ActionListener javax.swing.event.ChangeListener JDK 1.8 新增加的函数接口： java.util.function java.util.function 这个包下包含了很多类，用来支持 Java的 函数式编程，包括 Predicate&lt;T&gt;、Function&lt;T,R&gt;、Supplier&lt;T&gt;、Consumer&lt;T&gt; 和 BinaryOperator&lt;T&gt;。 Comparator、Predicate 和 Function 等函数式接口都有几个可以用来结合 lambda 表达式的默认方法。 Java 8中的常用函数式接口 函数式接口 函数描述符 原始类型特化 Predicate&lt;T&gt; T-&gt;boolean IntPredicate,LongPredicate, DoublePredicate Consumer&lt;T&gt; T-&gt;void IntConsumer,LongConsumer, DoubleConsumer Function&lt;T,R&gt; T-&gt;R IntFunction&lt;R&gt;, IntToDoubleFunction, IntToLongFunction, LongFunction&lt;R&gt;, LongToDoubleFunction, LongToIntFunction, DoubleFunction&lt;R&gt;, ToIntFunction&lt;T&gt;, ToDoubleFunction&lt;T&gt;, ToLongFunction&lt;T&gt; Supplier&lt;T&gt; ()-&gt;T BooleanSupplier,IntSupplier, LongSupplier, DoubleSupplier UnaryOperator&lt;T&gt; T-&gt;T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator BinaryOperator&lt;T&gt; (T,T)-&gt;T IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator BiPredicate&lt;L,R&gt; (L,R)-&gt;boolean BiConsumer&lt;T,U&gt; (T,U)-&gt;void ObjIntConsumer&lt;T&gt;, ObjLongConsumer&lt;T&gt;, ObjDoubleConsumer&lt;T&gt; BiFunction&lt;T,U,R&gt; (T,U)-&gt;R ToIntBiFunction&lt;T,U&gt;, ToLongBiFunction&lt;T,U&gt;, ToDoubleBiFunction&lt;T,U&gt; 5. 默认方法 新增了接口的默认方法。 简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。 我们只需在方法名前面加个default关键字即可实现默认方法。 6. Stream（★★） Demo 代码：https://github.com/xkcoding/java8_learning/tree/master/java8-stream 6.1. 关于流 6.1.1. 什么是流？ 流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。 众所周知，集合操作非常麻烦，若要对集合进行筛选、投影，需要写大量的代码，而流是以声明的形式操作集合，它就像SQL语句，我们只需告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果交给你，无需我们自己手写代码。 因此，流的集合操作对我们来说是透明的，我们只需向流下达命令，它就会自动把我们想要的结果给我们。由于操作过程完全由Java处理，因此它可以根据当前硬件环境选择最优的方法处理，我们也无需编写复杂又容易出错的多线程代码了。 6.1.2. 流的特点 只能遍历一次 我们可以把流想象成一条流水线，流水线的源头是我们的数据源(一个集合)，数据源中的元素依次被输送到流水线上，我们可以在流水线上对元素进行各种操作。 一旦元素走到了流水线的另一头，那么这些元素就被“消费掉了”，我们无法再对这个流进行操作。当然，我们可以从数据源那里再获得一个新的流重新遍历一遍。 采用内部迭代方式 若要对集合进行处理，则需我们手写处理代码，这就叫做外部迭代。 而要对流进行处理，我们只需告诉流我们需要什么结果，处理过程由流自行完成，这就称为内部迭代。 6.1.3. 流的操作种类 流的操作分为两种，分别为中间操作和终端操作。 中间操作 当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为“中间操作”。 中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线。 终端操作 当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作。 终端操作将返回一个执行结果，这就是你想要的数据。 6.1.4. 流的操作过程 使用流一共需要三步： 准备一个数据源 执行中间操作 中间操作可以有多个，它们可以串连起来形成流水线。 执行终端操作 执行终端操作后本次流结束，你将获得一个执行结果。 6.2. 使用流 6.2.1. 创建流 在使用流之前，首先需要拥有一个数据源，并通过StreamAPI提供的一些方法获取该数据源的流对象。数据源可以有多种形式： 1. 集合 这种数据源较为常用，通过stream()方法即可获取流对象： 12List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); Stream&lt;Person&gt; stream = list.stream(); 2. 数组 通过Arrays类提供的静态函数stream()获取数组的流对象： 12String[] names = &#123;"chaimm","peter","john"&#125;;Stream&lt;String&gt; stream = Arrays.stream(names); 3. 值 直接将几个值变成流对象： 1Stream&lt;String&gt; stream = Stream.of("chaimm","peter","john"); 4. 文件 1234try(Stream lines = Files.lines(Paths.get("文件路径名"),Charset.defaultCharset()))&#123; //可对lines做一些操作&#125;catch(IOException e)&#123;&#125; PS：Java7简化了IO操作，把打开IO操作放在try后的括号中即可省略关闭IO的代码。 5. iterator 创建无限流 123Stream.iterate(0, n -&gt; n + 2) .limit(10) .forEach(System.out::println); 6.2.2. 筛选 filter filter 函数接收一个Lambda表达式作为参数，该表达式返回boolean，在执行过程中，流将元素逐一输送给filter，并筛选出执行结果为true的元素。 如，筛选出所有学生： 123List&lt;Person&gt; result = list.stream() .filter(Person::isStudent) .collect(Collectors.toList()); 6.2.3. 去重distinct 去掉重复的结果： 123List&lt;Person&gt; result = list.stream() .distinct() .collect(Collectors.toList()); PS：对象去重的时候，需要注意重写 equals 和 hashcode 方法 6.2.4. 截取 截取流的前N个元素： 123List&lt;Person&gt; result = list.stream() .limit(3) .collect(Collectors.toList()); 6.2.5. 跳过 跳过流的前n个元素： 123List&lt;Person&gt; result = list.stream() .skip(3) .collect(Collectors.toList()); 6.2.6. 映射 对流中的每个元素执行一个函数，使得元素转换成另一种类型输出。流会将每一个元素输送给map函数，并执行map中的Lambda表达式，最后将执行结果存入一个新的流中。 如，获取每个人的姓名(实则是将Perosn类型转换成String类型)： 123List&lt;String&gt; result = list.stream() .map(Person::getName) .collect(Collectors.toList()); 6.2.7. 合并多个流 例：列出List中各不相同的单词，List集合如下： 1234List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add("I am a boy");list.add("I love the girl");list.add("But the girl loves another girl"); 思路如下： 首先将list变成流： 1list.stream(); 按空格分词： 12list.stream() .map(line-&gt;line.split(" ")); 分完词之后，每个元素变成了一个String[]数组。 将每个 String[] 变成流： 123list.stream() .map(line-&gt;line.split(" ")) .map(Arrays::stream) 此时一个大流里面包含了一个个小流，我们需要将这些小流合并成一个流。 将小流合并成一个大流：用 flatMap 替换刚才的 map 123list.stream() .map(line-&gt;line.split(" ")) .flatMap(Arrays::stream) 去重 12345list.stream() .map(line-&gt;line.split(" ")) .flatMap(Arrays::stream) .distinct() .collect(Collectors.toList()); 6.2.8. 是否匹配任一元素：anyMatch anyMatch用于判断流中是否存在至少一个元素满足指定的条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。 如，判断list中是否有学生： 12boolean result = list.stream() .anyMatch(Person::isStudent); 6.2.9. 是否匹配所有元素：allMatch allMatch用于判断流中的所有元素是否都满足指定条件，这个判断条件通过Lambda表达式传递给anyMatch，执行结果为boolean类型。 如，判断是否所有人都是学生： 12boolean result = list.stream() .allMatch(Person::isStudent); 6.2.10. 是否未匹配所有元素：noneMatch noneMatch与allMatch恰恰相反，它用于判断流中的所有元素是否都不满足指定条件： 12boolean result = list.stream() .noneMatch(Person::isStudent); 6.2.11. 获取任一元素findAny findAny能够从流中随便选一个元素出来，它返回一个Optional类型的元素。 1Optional&lt;Person&gt; person = list.stream().findAny(); 6.2.12. 获取第一个元素findFirst 1Optional&lt;Person&gt; person = list.stream().findFirst(); 6.2.13. 归约 归约是将集合中的所有元素经过指定运算，折叠成一个元素输出，如：求最值、平均数等，这些操作都是将一个集合的元素折叠成一个元素输出。 在流中，reduce函数能实现归约。 reduce函数接收两个参数： 初始值 进行归约操作的Lambda表达式 元素求和：自定义Lambda表达式实现求和 例：计算所有人的年龄总和 1int age = list.stream().reduce(0, (person1,person2)-&gt;person1.getAge()+person2.getAge()); reduce的第一个参数表示初始值为0； reduce的第二个参数为需要进行的归约操作，它接收一个拥有两个参数的Lambda表达式，reduce会把流中的元素两两输给Lambda表达式，最后将计算出累加之和。 元素求和：使用Integer.sum函数求和 上面的方法中我们自己定义了Lambda表达式实现求和运算，如果当前流的元素为数值类型，那么可以使用Integer提供了sum函数代替自定义的Lambda表达式，如： 1int age = list.stream().reduce(0, Integer::sum); Integer类还提供了 min、max 等一系列数值操作，当流中元素为数值类型时可以直接使用。 6.2.14. 数值流的使用 采用reduce进行数值操作会涉及到基本数值类型和引用数值类型之间的装箱、拆箱操作，因此效率较低。 当流操作为纯数值操作时，使用数值流能获得较高的效率。 将普通流转换成数值流 StreamAPI提供了三种数值流：IntStream、DoubleStream、LongStream，也提供了将普通流转换成数值流的三种方法：mapToInt、mapToDouble、mapToLong。 如，将Person中的age转换成数值流： 1IntStream stream = list.stream().mapToInt(Person::getAge); 数值计算 每种数值流都提供了数值计算函数，如max、min、sum等。如，找出最大的年龄： 123OptionalInt maxAge = list.stream() .mapToInt(Person::getAge) .max(); 由于数值流可能为空，并且给空的数值流计算最大值是没有意义的，因此max函数返回OptionalInt，它是Optional的一个子类，能够判断流是否为空，并对流为空的情况作相应的处理。 此外，mapToInt、mapToDouble、mapToLong进行数值操作后的返回结果分别为：OptionalInt、OptionalDouble、OptionalLong 6.3. 中间操作和收集操作 操作 类型 返回类型 使用的类型/函数式接口 函数描述符 filter 中间 Stream&lt;T&gt; Predicate&lt;T&gt; T -&gt; boolean distinct 中间 Stream&lt;T&gt; skip 中间 Stream&lt;T&gt; long map 中间 Stream&lt;R&gt; Function&lt;T, R&gt; T -&gt; R flatMap 中间 Stream&lt;R&gt; Function&lt;T, Stream&lt;R&gt;&gt; T -&gt; Stream&lt;R&gt; limit 中间 Stream&lt;T&gt; long sorted 中间 Stream&lt;T&gt; Comparator&lt;T&gt; (T, T) -&gt; int anyMatch 终端 boolean Predicate&lt;T&gt; T -&gt; boolean noneMatch 终端 boolean Predicate&lt;T&gt; T -&gt; boolean allMatch 终端 boolean Predicate&lt;T&gt; T -&gt; boolean findAny 终端 Optional&lt;T&gt; findFirst 终端 Optional&lt;T&gt; forEach 终端 void Consumer&lt;T&gt; T -&gt; void collect 终端 R Collector&lt;T, A, R&gt; reduce 终端 Optional&lt;T&gt; BinaryOperator&lt;T&gt; (T, T) -&gt; T count 终端 long 6.4. Collectors 收集 收集器用来将经过筛选、映射的流进行最后的整理，可以使得最后的结果以不同的形式展现。 collect 方法即为收集器，它接收 Collector 接口的实现作为具体收集器的收集方法。 Collector 接口提供了很多默认实现的方法，我们可以直接使用它们格式化流的结果；也可以自定义 Collector 接口的实现，从而定制自己的收集器。 6.4.1. 归约 流由一个个元素组成，归约就是将一个个元素“折叠”成一个值，如求和、求最值、求平均值都是归约操作。 6.4.2. 一般性归约 若你需要自定义一个归约操作，那么需要使用 Collectors.reducing 函数，该函数接收三个参数： 第一个参数为归约的初始值 第二个参数为归约操作进行的字段 第三个参数为归约操作的过程 6.5. 汇总 Collectors类专门为汇总提供了一个工厂方法：Collectors.summingInt。 它可接受一 个把对象映射为求和所需int的函数，并返回一个收集器；该收集器在传递给普通的 collect 方法后即执行我们需要的汇总操作。 6.5.1. 分组 数据分组是一种更自然的分割数据操作，分组就是将流中的元素按照指定类别进行划分，类似于SQL语句中的 GROUPBY。 6.5.2. 多级分组 多级分组可以支持在完成一次分组后，分别对每个小组再进行分组。 使用具有两个参数的 groupingBy 重载方法即可实现多级分组。 第一个参数：一级分组的条件 第二个参数：一个新的 groupingBy 函数，该函数包含二级分组的条件 Collectors 类的静态工厂方法 工厂方法 返回类型 用途 示例 toList List&lt;T&gt; 把流中所有项目收集到一个 List List&lt;Project&gt; projects = projectStream.collect(toList()); toSet Set&lt;T&gt; 把流中所有项目收集到一个 Set，删除重复项 Set&lt;Project&gt; projects = projectStream.collect(toSet()); toCollection Collection&lt;T&gt; 把流中所有项目收集到给定的供应源创建的集合 Collection&lt;Project&gt; projects = projectStream.collect(toCollection(), ArrayList::new); counting Long 计算流中元素的个数 long howManyProjects = projectStream.collect(counting()); summingInt Integer 对流中项目的一个整数属性求和 int totalStars = projectStream.collect(summingInt(Project::getStars)); averagingInt Double 计算流中项目 Integer 属性的平均值 double avgStars = projectStream.collect(averagingInt(Project::getStars)); summarizingInt IntSummaryStatistics 收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值 IntSummaryStatistics projectStatistics = projectStream.collect(summarizingInt(Project::getStars)); joining String 连接对流中每个项目调用 toString 方法所生成的字符串 String shortProject = projectStream.map(Project::getName).collect(joining(&quot;, &quot;)); maxBy Optional&lt;T&gt; 按照给定比较器选出的最大元素的 Optional， 或如果流为空则为 Optional.empty() Optional&lt;Project&gt; fattest = projectStream.collect(maxBy(comparingInt(Project::getStars))); minBy Optional&lt;T&gt; 按照给定比较器选出的最小元素的 Optional， 或如果流为空则为 Optional.empty() Optional&lt;Project&gt; fattest = projectStream.collect(minBy(comparingInt(Project::getStars))); reducing 归约操作产生的类型 从一个作为累加器的初始值开始，利用 BinaryOperator 与流中的元素逐个结合，从而将流归约为单个值 int totalStars = projectStream.collect(reducing(0, Project::getStars, Integer::sum)); collectingAndThen 转换函数返回的类型 包含另一个收集器，对其结果应用转换函数 int howManyProjects = projectStream.collect(collectingAndThen(toList(), List::size)); groupingBy Map&lt;K, List&lt;T&gt;&gt; 根据项目的一个属性的值对流中的项目作问组，并将属性值作 为结果 Map 的键 Map&lt;String,List&lt;Project&gt;&gt; projectByLanguage = projectStream.collect(groupingBy(Project::getLanguage)); partitioningBy Map&lt;Boolean,List&lt;T&gt;&gt; 根据对流中每个项目应用断言的结果来对项目进行分区 Map&lt;Boolean,List&lt;Project&gt;&gt; vegetarianDishes = projectStream.collect(partitioningBy(Project::isVegetarian)); 6.5.3. 转换类型 有一些收集器可以生成其他集合。比如前面已经见过的 toList，生成了 java.util.List 类的实例。 还有 toSet 和 toCollection，分别生成 Set 和 Collection 类的实例。 到目前为止， 我已经讲了很多流上的链式操作，但总有一些时候，需要最终生成一个集合——比如： 已有代码是为集合编写的，因此需要将流转换成集合传入； 在集合上进行一系列链式操作后，最终希望生成一个值； 写单元测试时，需要对某个具体的集合做断言。 使用 Collectors.toCollection，用定制的集合收集元素 1stream.collect(Collectors.toCollection(TreeSet::new)); 还可以利用收集器让流生成一个值。 maxBy 和 minBy 允许用户按某种特定的顺序生成一个值。 6.5.4. 数据分区 分区是分组的特殊情况：由一个断言（返回一个布尔值的函数）作为分类函数，它称分区函数。 分区函数返回一个布尔值，这意味着得到的分组 Map 的键类型是 Boolean，于是它最多可以分为两组: true是一组，false是一组。 分区的好处在于保留了分区函数返回true或false的两套流元素列表。 6.5.5. 并行流 并行流就是一个把内容分成多个数据块，并用不不同的线程分别处理每个数据块的流。最后合并每个数据块的计算结果。 将一个顺序执行的流转变成一个并发的流只要调用 parallel() 方法 123public static long parallelSum(long n)&#123; return Stream.iterate(1L, i -&gt; i +1).limit(n).parallel().reduce(0L,Long::sum);&#125; 将一个并发流转成顺序的流只要调用 sequential() 方法 1stream.parallel().filter(...).sequential().map(...).parallel().reduce(); 这两个方法可以多次调用，只有最后一个调用决定这个流是顺序的还是并发的。 并发流使用的默认线程数等于你机器的处理器核心数。 通过这个方法可以修改这个值，这是全局属性。 1System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12"); 并非使用多线程并行流处理数据的性能一定高于单线程顺序流的性能，因为性能受到多种因素的影响。 如何高效使用并发流的一些建议： 如果不确定， 就自己测试。 尽量使用基本类型的流 IntStream, LongStream, DoubleStream 有些操作使用并发流的性能会比顺序流的性能更差，比如limit，findFirst，依赖元素顺序的操作在并发流中是极其消耗性能的。findAny的性能就会好很多，应为不依赖顺序。 考虑流中计算的性能(Q)和操作的性能(N)的对比, Q表示单个处理所需的时间，N表示需要处理的数量，如果Q的值越大, 使用并发流的性能就会越高。 数据量不大时使用并发流，性能得不到提升。 考虑数据结构：并发流需要对数据进行分解，不同的数据结构被分解的性能时不一样的。 流的数据源和可分解性 源 可分解性 ArrayList 非常好 LinkedList 差 IntStream.range 非常好 Stream.iterate 差 HashSet 好 TreeSet 好 流的特性以及中间操作对流的修改都会对数据对分解性能造成影响。 比如固定大小的流在任务分解的时候就可以平均分配，但是如果有filter操作，那么流就不能预先知道在这个操作后还会剩余多少元素。 考虑终端操作的性能：如果终端操作在合并并发流的计算结果时的性能消耗太大，那么使用并发流提升的性能就会得不偿失。 7. Optional 类（★） Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 Optional 类的引入很好的解决空指针异常。 Optional类的方法 方法 描述 empty 返回一个空的 Optional 实例 filter 如果值存在并且满足提供的断言， 就返回包含该值的 Optional 对象；否则返回一个空的 Optional 对象 map 如果值存在，就对该值执行提供的 mapping 函数调用 flatMap 如果值存在，就对该值执行提供的 mapping 函数调用，返回一个 Optional 类型的值，否则就返 回一个空的 Optional 对象 get 如果该值存在，将该值用 Optional 封装返回，否则抛出一个 NoSuchElementException 异常 ifPresent 如果值存在，就执行使用该值的方法调用，否则什么也不做 isPresent 如果值存在就返回 true，否则返回 false of 将指定值用 Optional 封装之后返回，如果该值为 null，则抛出一个 NullPointerException 异常 ofNullable 将指定值用 Optional 封装之后返回，如果该值为 null，则返回一个空的 Optional 对象 orElse 如果有值则将其返回，否则返回一个默认值 orElseGet 如果有值则将其返回，否则返回一个由指定的 Supplier 接口生成的值 orElseThrow 如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常 8. Nashorn, JavaScript 引擎 Nashorn 一个 javascript 引擎。 从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的invokedynamic，将JavaScript编译成Java字节码。 与先前的Rhino实现相比，这带来了2到10倍的性能提升。 9. 新的日期时间 API（★★） Demo 代码：https://github.com/xkcoding/java8_learning/tree/master/java8-datetime ZoneId Java 8中的时区操作被很大程度上简化了，新的时区类 java.time.ZoneId 是原有的 java.util.TimeZone 类的替代品。 ZoneId对象可以通过 ZoneId.of() 方法创建，也可以通过 ZoneId.systemDefault() 获取系统默认时区： 12ZoneId shanghaiZoneId = ZoneId.of("Asia/Shanghai");ZoneId systemZoneId = ZoneId.systemDefault(); of() 方法接收一个“区域/城市”的字符串作为参数，你可以通过 getAvailableZoneIds() 方法获取所有合法的“区域/城市”字符串： 1Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds(); 对于老的时区类 TimeZone，Java 8也提供了转化方法： 1ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId(); 有了 ZoneId，我们就可以将一个 LocalDate、LocalTime 或 LocalDateTime 对象转化为 ZonedDateTime 对象： 12LocalDateTime localDateTime = LocalDateTime.now();ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId); ZonedDateTime 对象由两部分构成，LocalDateTime 和 ZoneId，其中 2018-03-03T15:26:56.147 部分为 LocalDateTime，+08:00[Asia/Shanghai] 部分为ZoneId。 另一种表示时区的方式是使用 ZoneOffset，它是以当前时间和 世界标准时间（UTC）/格林威治时间（GMT） 的偏差来计算，例如： 123ZoneOffset zoneOffset = ZoneOffset.of("+09:00");LocalDateTime localDateTime = LocalDateTime.now();OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset); Instant Instant类在Java日期与时间功能中，表示了时间线上一个确切的点，定义为距离初始时间的时间差（初始时间为GMT 1970年1月1日00:00）经测量一天有86400秒，从初始时间开始不断向前移动。 创建一个Instant实例 你可以通过Instant类的工厂方法创建一个Instant实例，例如你可以调用instant.now()来创建一个确切的表达当前时间的Instant对象： 1Instant now = Instant.now(); 另外也有一些其它方法能创建Instant，具体请查阅Java官方文档。 访问Instant的时间 一个Instant对象里有两个域：距离初始时间的秒钟数、在当前一秒内的第几纳秒，他们的组合表达了当前时间点。你可以通过以下两个方法得到它们的值： 12long seconds = now.getEpochSecond()int nanos = now.getNano() Instant的计算 Instant类有一些方法，可以用于获得另一Instant的值，例如： plusSeconds() plusMillis() plusNanos() minusSeconds() minusMillis() minusNanos() 我下面将向你展示两个例子，来说明这些方法如何使用： 123Instant now = Instant.now();Instant later = now.plusSeconds(3);Instant earlier = now.minusSeconds(3); 第一行获得了一个Instant对象，表示当前时间。第二行创建了一个Instant表示三秒后，第三行创建了一个Instant表示三秒前。 seconds 表示从 1970-01-01 00:00:00 开始到现在的秒数，nanos 表示纳秒部分（nanos的值不会超过999,999,999） Clock Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。 某一个特定的时间点也可以使用Instant类来表示，Instant 类也可以用来创建老的 java.util.Date 对象。 1234Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date LocalDate LocalDate类是Java 8中日期时间功能里表示一个本地日期的类，它的日期是无时区属性的。 可以用来表示生日、节假日期等等。这个类用于表示一个确切的日期，而不是这个日期所在的时间（如java.util.Date中的2000.01.01表示的实际是这一天的00:00这个瞬间）。 LocalDate类位于java.time包下，类名叫java.time.LocalDate，创建出来的实例也是不可变对象，所以涉及它的计算方法将返回一个新的LocalDate。 创建一个LocalDate实例 我们有多种方式可以创建出 LocalDate 实例。第一种方法是使用 now() 方法获得值为今天当日的 LocalDate 对象： 1LocalDate localDate = LocalDate.now(); 另一种方法是使用年月日信息构造出LocalDate对象： 1LocalDate localDate2 = LocalDate.of(2018, 7, 19); LocalDate 的 of() 方法创建出一个指定年月日的日期，并且没有时区信息。 访问日期信息 可以用如下方法访问LocalDate中的日期信息： 12345int year = localDate.getYear();Month month = localDate.getMonth();int dayOfMonth = localDate.getDayOfMonth();int dayOfYear = localDate.getDayOfYear();DayOfWeek dayOfWeek = localDate.getDayOfWeek(); 可以注意到getMonth()与getDayOfWeek()方法返回了一个枚举类型代替一个int。你可以通过枚举类型中的getValue()来获得信息。 LocalDate计算 你可以进行一堆简单的日期计算，只要使用如下的方法： plusDays() plusWeeks() plusMonths() plusYears() minusDays() minusWeeks() minusMonths() minusYears() 以下举几个使用的例子来帮助理解使用： 123LocalDate d = LocalDate.of(2018, 7, 19);LocalDate d1 = localDate.plusYears(3);LocalDate d2 = localDate.minusYears(3); 第一行创建出一个新的LocalDate对象d，表示2018.7.19。 第二行创建了值等于d日期3年后的LocalDate对象，第三行也是一样，只是值改为d日期的三年前。 LocalTime LocalTime类是Java 8中日期时间功能里表示一整天中某个时间点的类，它的时间是无时区属性的（早上10点等等）。比如你需要描述学校几点开学，这个时间不涉及在什么城市，这个描述是对任何国家城市都适用的，此时使用无时区的LocalTime就足够了。 LocalTime类的对象也是不可变的，所以计算方法会返回一个新的LocalTime实例。 创建一个LocatTime实例 有多种方式可以新建LocalTime实例。比如使用当前时间作为值新建对象： 1LocalTime localTime = LocalTime.now(); 另一种方式是使用指定的时分秒和纳秒来新建对象： 1LocalTime localTime2 = LocalTime.of(21, 30, 59, 11001); 也有另一种版本的 of() 方法只需要小时分钟两项，或时分秒三项值作为参数。 访问LocalTime对象的时间 你可以通过这些方法访问其时、分、秒、纳秒： getHour() getMinute() getSecond() getNano() LocalTime的计算 LocalTime类包含一系列方法，能帮你完成时间计算： plusHours() plusMinutes() plusSeconds() plusNanos() minusHours() minusMinutes() minusSeconds() minusNanos() 以下举一个例子： 123LocalTime localTime2 = LocalTime.of(21, 30, 59, 11001);LocalTime localTimeLater = localTime.plusHours(3);LocalTime localTimeEarlier = localTime.minusHours(3); 第一行新建一个LocalTime实例，表示21:30:50的第11001纳秒。 第二行新建了一个LocalTime实例表示这个时间的三小时后，第三行表示三小时前。 LocalTime类是Java 8中日期时间功能里表示一整天中某个时间点的类，它的时间是无时区属性的（早上10点等等）。比如你需要描述学校几点开学，这个时间不涉及在什么城市，这个描述是对任何国家城市都适用的，此时使用无时区的LocalTime就足够了。 LocalTime类的对象也是不可变的，所以计算方法会返回一个新的LocalTime实例。 LocalDateTime LocalDateTime类是Java 8中日期时间功能里，用于表示当地的日期与时间的类，它的值是无时区属性的。你可以将其视为Java 8中LocalDate与LocalTime两个类的结合。 LocalDateTime类的值是不可变的，所以其计算方法会返回一个新的LocalDateTime实例。 创建一个LocatDateTime实例 可以通过LocalDateTime的静态工厂方法来创建LocalDateTime实例。以下举例使用 now() 方法创建： 1LocalDateTime localDateTime = LocalDateTime.now(); 另一种方式是使用指定的年月日、时分秒、纳秒来新建对象： 1LocalDateTime localDateTime2 = LocalDateTime.of(2018, 7, 19, 13, 55, 36, 123); 访问LocalDateTime对象的时间 你可以通过这些方法访问其日期时间： getYear() getMonth() getDayOfMonth() getDayOfWeek() getDayOfYear() getHour() getMinute() getSecond() getNano() 这些方法中有一些返回int有一些返回枚举类型，你可以通过枚举类型中的 getValue() 方法来获得int值。 LocalDateTime的计算 LocalDateTime 类包含一系列方法，能帮你完成时间计算： plusYears() plusMonths() plusDays() plusHours() plusMinutes() plusSeconds() plusNanos() minusYears() minusMonths() minusDays() minusHours() minusMinutes() minusSeconds() minusNanos() 以下举一个例子： 123LocalDateTime localDateTime = LocalDateTime.now();LocalDateTime localDateTime1 = localDateTime.plusYears(3);LocalDateTime localDateTime2 = localDateTime.minusYears(3); 第一行新建一个LocalDateTime实例表示当前这个时间。 第二行新建了一个LocalDateTime实例表示三年后。 第三行也新建了一个LocalDateTime实例表示三小时前。 ZonedDateTime ZonedDateTime类是Java 8中日期时间功能里，用于表示带时区的日期与时间信息的类。可以用于表示一个真实事件的开始时间，如某火箭升空时间等等。 ZonedDateTime 类的值是不可变的，所以其计算方法会返回一个新的ZonedDateTime 实例。 创建一个ZonedDateTime实例 有多种方式可以新建ZonedDateTime实例。比如使用当前时间作为值新建对象： 1ZonedDateTime dateTime = ZonedDateTime.now(); 另一种方式是使用指定的年月日、时分秒、纳秒以及时区ID来新建对象： 12ZoneId zoneId = ZoneId.of("UTC+1");ZonedDateTime dateTime2 = ZonedDateTime.of(2018, 7, 19, 11, 45, 59, 1234, zoneId); 访问ZonedDateTime对象的时间 你可以通过这些方法访问其日期时间： getYear() getMonth() getDayOfMonth() getDayOfWeek() getDayOfYear() getHour() getMinute() getSecond() getNano() 这些方法中有一些返回int有一些返回枚举类型，但可以通过枚举类型中的getValue()方法来获得int值。 ZonedDateTime的计算 ZonedDateTime类包含一系列方法，能帮你完成时间计算： plusYears() plusMonths() plusDays() plusHours() plusMinutes() plusSeconds() plusNanos() minusYears() minusMonths() minusDays() minusHours() minusMinutes() minusSeconds() minusNanos() 但注意计算时，若不巧跨越了夏令时（会补一小时或减一小时），可能得不到希望的结果。一个替代的正确做法是使用Period： 1ZonedDateTime zoneDateTime = previousDateTime.plus(Period.ofDays(3)); 时区 时区是用ZoneId类表示的，你可以使用ZoneId.now()或ZoneId.of(“xxx”)来实例化： 1ZoneId zoneId = ZoneId.of("UTC+1"); 传给 of() 方法的参数是时区的ID，如“UTC+1”指距离UTC（格林威治时间）有一小时的时差，你可以使用你想要的时差来表示ZoneId（如+1与-5等等） 你也可以使用另一种方式表示zone id，即使用地区名字，也是可以的： 12ZoneId zoneId2 = ZoneId.of("Europe/Copenhagen");ZoneId zoneId3 = ZoneId.of("Europe/Paris"); DateTimeFormatter DateTimeFormatter类是Java 8中日期时间功能里，用于解析和格式化日期时间的类，位于 java.time.format 包下。 预定义的DateTimeFormatter实例 DateTimeFormatter类包含一系列预定义（常量）的实例，可以解析和格式化一些标准时间格式。这将让你免除麻烦的时间格式定义，类中包含如下预定义的实例： 12345678910111213141516171819202122BASIC_ISO_DATEISO_LOCAL_DATEISO_LOCAL_TIMEISO_LOCAL_DATE_TIMEISO_OFFSET_DATEISO_OFFSET_TIMEISO_OFFSET_DATE_TIMEISO_ZONED_DATE_TIMEISO_INSTANTISO_DATEISO_TIMEISO_DATE_TIMEISO_ORDINAL_TIMEISO_WEEK_DATERFC_1123_DATE_TIME 每个预定义的DateTimeFormatter实例都有不同的日期格式，具体的可以查阅Java官方文档。 PS：推荐使用下期分享的 Hutool 工具类做这些格式化工作，格式更加丰富。 格式化日期 当你获取一个DateTimeFormatter实例后，就可以用format()方便来将一个日期格式化为某种字符串，例如： 123DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;String formattedDate = formatter.format(LocalDate.now());System.out.println(formattedDate); 这个样例把LocalDate对象格式化了，并输出20180719，这个输出表示现在2018年，7月19日。 再举一个关于ZonedDateTime的例子： 123DateTimeFormatter formatter = DateTimeFormatter.BASIC_ISO_DATE;String formattedZonedDate = formatter.format(ZonedDateTime.now());System.out.println("formattedZonedDate = " + formattedZonedDate); 这个例子会输出：20180719+0800 表示今年2018年，7月19日，位于UTC+8时区。 Duration 一个Duration对象表示两个Instant间的一段时间，是在Java 8中加入的新功能。 一个Duration实例是不可变的，当创建出对象后就不能改变它的值了。你只能通过Duration的计算方法，来创建出一个新的Durtaion对象。你会在之后的教程中见到的。 创建Duration实例 使用 Duration 类的工厂方法来创建一个 Duration 对象，以下是一个使用 between() 的例子： 1234Instant first = Instant.now();// 耗时操作，或者 Sleep 一段时间Instant second = Instant.now();Duration duration = Duration.between(first, second); 访问Duration的时间 一个Duration对象里有两个域：纳秒值（小于一秒的部分），秒钟值（一共有几秒），他们的组合表达了时间长度。注意与使用System.getCurrentTimeMillis()时不同，Duration不包含毫秒这个属性。 你可以通过以下两个方法得到它们的值： 12long seconds = duration.getSeconds()int nanos = duration.getNano() 你也可以转换整个时间到其它单位如纳秒、分钟、小时、天： toNanos() toMillis() toMinutes() toHours() toDays() 举例而言：toNanos() 与 getNano() 不同，toNanos() 获得的是 Duration 整个时间共有多少纳秒， 而 getNano() 只是获得这段时间中小于一秒的部分。 Duration计算 Duration类包含一系列的计算方法： plusNanos() plusMillis() plusSeconds() plusMinutes() plusHours() plusDays() minusNanos() minusMillis() minusSeconds() minusMinutes() minusHours() minusDays() 这些方法所做的事都是相似的，这里展示一个加减的例子： 123Duration start = ... //obtain a start durationDuration added = start.plusDays(3);Duration subtracted = start.minusDays(3); 第一行创建了一个Duration对象叫start，具体怎么创建可以参考前面的代码。 第二三行样例创建了两个新的Duration，通过调用start的加减操作，使得added对象表示的时间比start多三天，而substracted则少三天。 所有的计算方法都会返回一个新的Duration，以保证Duration的不可变属性。 123456long days = duration.toDays(); // 这段时间的总天数long hours = duration.toHours(); // 这段时间的小时数long minutes = duration.toMinutes(); // 这段时间的分钟数long seconds = duration.getSeconds(); // 这段时间的秒数long milliSeconds = duration.toMillis(); // 这段时间的毫秒数long nanoSeconds = duration.toNanos(); // 这段时间的纳秒数 其他操作 增加和减少日期 Java 8中的日期/时间类都是不可变的，这是为了保证线程安全。当然，新的日期/时间类也提供了方法用于创建对象的可变版本，比如增加一天或者减少一天： 123456789LocalDate date = LocalDate.of(2017, 1, 5); // 2017-01-05LocalDate date1 = date.withYear(2016); // 修改为 2016-01-05LocalDate date2 = date.withMonth(2); // 修改为 2017-02-05LocalDate date3 = date.withDayOfMonth(1); // 修改为 2017-01-01LocalDate date4 = date.plusYears(1); // 增加一年 2018-01-05LocalDate date5 = date.minusMonths(2); // 减少两个月 2016-11-05LocalDate date6 = date.plus(5, ChronoUnit.DAYS); // 增加5天 2017-01-10 上面例子中对于日期的操作比较简单，但是有些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日， 或者是下个月的最后一天，这时候我们可以使用 with() 方法的另一个重载方法，它接收一个TemporalAdjuster参数， 可以使我们更加灵活的调整日期： 12LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY)); // 返回下一个距离当前时间最近的星期日LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY)); // 返回本月最后一个星期六 要使上面的代码正确编译，你需要使用静态导入 TemporalAdjusters 对象： import static java.time.temporal.TemporalAdjusters.*; TemporalAdjusters 类中包含了很多静态方法可以直接使用，下面的表格列出了一些方法： 方法名 描述 dayOfWeekInMonth 返回同一个月中每周的第几天 firstDayOfMonth 返回当月的第一天 firstDayOfNextMonth 返回下月的第一天 firstDayOfNextYear 返回下一年的第一天 firstDayOfYear 返回本年的第一天 firstInMonth 返回同一个月中第一个星期几 lastDayOfMonth 返回当月的最后一天 lastDayOfNextMonth 返回下月的最后一天 lastDayOfNextYear 返回下一年的最后一天 lastDayOfYear 返回本年的最后一天 lastInMonth 返回同一个月中最后一个星期几 next / previous 返回后一个/前一个给定的星期几 nextOrSame / previousOrSame 返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回 如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的 TemporalAdjuster 接口的实现， TemporalAdjuster 也是一个函数式接口，所以我们可以使用Lambda表达式： 1234@FunctionalInterfacepublic interface TemporalAdjuster &#123; Temporal adjustInto(Temporal temporal);&#125; 比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）： 1234567891011121314151617181920LocalDate date = LocalDate.of(2018, 7, 19);date.with(temporal -&gt; &#123; // 当前日期 DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK)); // 正常情况下，每次增加一天 int dayToAdd = 1; // 如果是星期五，增加三天 if (dayOfWeek == DayOfWeek.FRIDAY) &#123; dayToAdd = 3; &#125; // 如果是星期六，增加两天 if (dayOfWeek == DayOfWeek.SATURDAY) &#123; dayToAdd = 2; &#125; return temporal.plus(dayToAdd, ChronoUnit.DAYS);&#125;); 其他历法 Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。 此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是： ThaiBuddhistDate：泰国佛教历 MinguoDate：中华民国历 JapaneseDate：日本历 HijrahDate：伊斯兰历 每个日期类都继承 ChronoLocalDate 类，所以可以在不知道具体历法的情况下也可以操作。不过这些历法一般不常用，除非是有某些特殊需求情况下才会使用。 这些不同的历法也可以用于向公历转换： 12LocalDate date = LocalDate.now();JapaneseDate jpDate = JapaneseDate.from(date); 由于它们都继承ChronoLocalDate类，所以在不知道具体历法情况下，可以通过ChronoLocalDate类操作日期： 12Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow(); 我们在开发过程中应该尽量避免使用 ChronoLocalDate，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。 再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。 在实际开发过程中建议使用 LocalDate，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用 ChronoLocalDate 类。 10. Base64 在Java 8中，Base64编码已经成为Java类库的标准。 Java 8 内置了 Base64 编码的编码器和解码器，这样不需要使用第三方库就可以进行Base64编码。 Base64工具类提供了一套静态方法获取下面三种BASE64编解码器： **基本：**输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。 **URL：**输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。 **MIME：**输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。 示例： 1234567891011final String text = "测试Base64编码";final String encoded = Base64 .getEncoder() .encodeToString(text.getBytes(StandardCharsets.UTF_8));System.out.println(encoded);final String decoded = new String( Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);System.out.println(decoded); 11. 参考资料 Java 8 新特性 SimpleDateFormat的线程安全问题与解决方案 为什么SimpleDateFormat不是线程安全的？ Java获取N天前，N天后的日期（如3天） What’s New in JDK 8 12. 附录 示例代码地址：https://github.com/xkcoding/java8_learning 如果可以的话，麻烦给个 Star 吧 (♥◠‿◠)ﾉﾞ]]></content>
      <categories>
        <category>技术相关</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <url>%2F2018%2F02%2F07%2Fregular-expression-list.html</url>
    <content type="text"><![CDATA[校验数字的表达式 12345678910111213141516171819数字：^[0-9]*$n位的数字：^\d&#123;n&#125;$至少n位的数字：^\d&#123;n,&#125;$m-n位的数字：^\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$非负整数：^\d+$ 或 ^[1-9]\d*|0$非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 校验字符的表达式 123456789101112汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$可以输入含有^%&amp;',;=?$\"等字符：[^%&amp;',;=?$\x22]+禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 123456789101112131415161718192021222324252627282930313233Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$手机号码：^(13[0-9]|14[0-9]|15[0-9]|166|17[0-9]|18[0-9]|19[8|9])\d&#123;8&#125;$电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 18位身份证号码(数字、字母x结尾)：^((\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$中文字符的正则表达式：[\u4e00-\u9fa5]双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))空白行的正则表达式：\n\s*\r (可以用来删除空白行)HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字)IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))]]></content>
      <categories>
        <category>代码片段</category>
        <category>regex</category>
      </categories>
      <tags>
        <tag>代码片段</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSX 常用软件汇总]]></title>
    <url>%2F2018%2F02%2F05%2Fosx-software-lists.html</url>
    <content type="text"><![CDATA[每次重装系统，或者新电脑到手的时候，最麻烦的莫过于重新安装之前常用的一些软件了。但是，平时常用的软件实在有点多，于是乎，整理一个 OSX 常用软件的列表，便于以后查找使用，以下整理的软件仅代表我个人平时常用的软件，不喜勿喷。 最喜欢的一个「免（破）费（解）」的 osx 软件下载网址：xclient.info ，有经济能力的童鞋还是请支持正版。。。 聊天类软件 软件 介绍及下载地址 QQ 略，http://im.qq.com/macqq/ 微信 略，Mac App Store 阿里旺旺 淘宝买家与卖家之间的沟通工具，https://alimarket.taobao.com/markets/qnww/portal-group/ww/download 钉钉 智能移动办公平台，https://www.dingtalk.com/ 影音类软件 软件 介绍及下载地址 网易云音乐 网易一款良心之作，听歌很棒，听歌看评论更棒，https://music.163.com/#/download Movist 对比过很多视频播放器，最终这款我比较喜欢，http://xclient.info/s/movist.html?_=80fb58a8555e8bf529af34d2f81df569 笔记类软件 软件 介绍及下载地址 有道云笔记 略，http://note.youdao.com/download.html#mac Evernote 略，https://www.yinxiang.com/download/ MWeb 一款 markdown 编辑器，比较喜欢的是可以将图片上传至七牛云等地方，适合做笔记，http://xclient.info/s/mweb.html?_=80fb58a8555e8bf529af34d2f81df569 Typora 和 MWeb 一样，是一款 markdown 编辑器，本文就是用这个软件写的，所见即所得，适合写博客文章，https://www.typora.io/ 摄影类软件 软件 介绍及下载地址 泼辣修图 国人开发的一款好用的修图软件，包含及其丰富的滤镜，http://xclient.info/s/polarr-photo-editor.html?_=80fb58a8555e8bf529af34d2f81df569 Snapseed 一款国内外知名的修图软件，需要一定的操作，Mac App Store Super PhotoCut Pro 超级抠图，http://xclient.info/s/super-photocut.html?_=80fb58a8555e8bf529af34d2f81df569 Photoshop 这个就不介绍了，摄影、修图必备，http://xclient.info/s/adobe-photoshop-cc.html?_=80fb58a8555e8bf529af34d2f81df569 Lightroom 对 RAW 格式的照片做处理，http://xclient.info/s/adobe-lightroom-cc.html?_=80fb58a8555e8bf529af34d2f81df569 效率类软件 软件 介绍及下载地址 Alfred 效率神器，可以不用鼠标，召唤出你想要的一切，http://xclient.info/s/alfred.html?_=80fb58a8555e8bf529af34d2f81df569 Clean My Mac 3 Mac 的一款包含磁盘垃圾清理及硬件资源监控等功能的软件，http://www.mycleanmymac.com/ CheetSheat 长按⌘键，展示当前窗口应用的快捷键，https://www.mediaatelier.com/CheatSheet/ Dash 开发者必备 API文档聚合，http://xclient.info/s/dash.html?_=80fb58a8555e8bf529af34d2f81df569 MindNote 思维导图工具，http://xclient.info/s/mind-node-pro.html?_=80fb58a8555e8bf529af34d2f81df569 XMind 思维导图工具，https://www.xmind.cn/download/ iTerm 替换自带的 Terminal 程序，更好用，http://www.iterm2.com/ Moom 强大的窗口布局工具，http://xclient.info/s/moom.html?_=80fb58a8555e8bf529af34d2f81df569 Microsoft PowerPoint PPT，Microsoft Office 2016 for Mac 套件中，http://xclient.info/s/office-for-mac-2016.html?_=80fb58a8555e8bf529af34d2f81df569 Microsoft Excel Excel，Microsoft Office 2016 for Mac 套件中，同上 Microsoft Word Word，Microsoft Office 2016 for Mac 套件中，同上 Microsoft OneNote OneNote，Microsoft Office 2016 for Mac 套件中，同上 Pages 一款文字处理和页面排版工具，类似 Word，Mac App Store Keynote 运行于Mac OS X操作系统下的演示幻灯片应用软件，类似 PPT，Mac App Store Numbers 一款电子表单应用程序，类似 Excel，Mac App Store OmniPlan 最NB的项目管理流程软件，http://xclient.info/s/omni-plan.html?_=80fb58a8555e8bf529af34d2f81df569 OmniGraffle 强大的图形工具，可以用来绘制图表，流程图，组织结构图以及插图，http://xclient.info/s/omnigraffle.html?_=80fb58a8555e8bf529af34d2f81df569 实用工具类软件 软件 介绍及下载地址 NewFileMenu 可以在 Mac 上使用右键创建文档，http://xclient.info/s/new-file-menu.html?_=80fb58a8555e8bf529af34d2f81df569 ScreenFlow 一款优秀的屏幕录像软件，http://xclient.info/s/screenflow.html?_=80fb58a8555e8bf529af34d2f81df569 百度网盘 提供文件的网络备份、同步和分享服务，https://pan.baidu.com/download#pan FlashFTP 一款高效的FTP、SFTP文件传输客户端，Mac App Store 迅雷 下载工具，http://mac.xunlei.com/ SpechtLite 科学上网工具，需配合「熊猫翻滚」使用，https://upcloud-pic.b0.upaiyun.com/panda/spechlite/0.10.7.zip PDF Expert 一款可以对 PDF 进行标注的阅读器，Mac App Store Rar Sharp rar文件解压工具，Mac App Store Things 3 一款优秀的 GTD 任务管理工具，http://xclient.info/s/things.html?_=80fb58a8555e8bf529af34d2f81df569 VMware Fusion 强大的虚拟机应用，http://xclient.info/s/vmware-fusion.html?_=80fb58a8555e8bf529af34d2f81df569 Gemini 2 高效的重复文件查找器，http://xclient.info/s/gemini.html?_=80fb58a8555e8bf529af34d2f81df569 EdrawMax 基于矢量的绘图工具，轻松绘制流程图 PP助手 可以将文件传给 iPhone，不喜欢 iTunes，https://pro.25pp.com/pp_mac_ios Charles 抓包工具，http://charles.iiilab.com/ VirtualBox 免费的虚拟机软件，https://www.virtualbox.org/ duet 可以将 mac 屏幕投影到 iPhone 或者 ipad 上，将其作为第二屏，https://www.duetdisplay.com/ Lantern 免费的科学上网神器，https://github.com/getlantern/lantern/releases/tag/latest TeamViewer 远程支持、远程访问、在线协作和会议，https://www.teamviewer.com/zhcn/download/mac/ Microsoft Remote Desktop Beta 支持让 Mac 远程连接到 windows 服务器，https://rink.hockeyapp.net/apps/5e0c144289a51fca2d3bfa39ce7f2b06/ Xee3 支持多格式的图片浏览工具，http://xclient.info/s/xee3.html?_=80fb58a8555e8bf529af34d2f81df569 Tuxera Disk Manager 让你的 Mac 支持读取 NTFS 格式的硬盘 iStatistica 一款高颜值的系统监控工具，http://xclient.info/s/istatistica.html?_=80fb58a8555e8bf529af34d2f81df569 TinyCal 一款小而美的日历，可以放置在通知栏上，支持阴历，http://xclient.info/s/tinycal.html?_=80fb58a8555e8bf529af34d2f81df569 开发类软件 软件 介绍及下载地址 IntelliJ IDEA Java 主力开发软件，http://www.jetbrains.com/idea/ WebStorm 前端开发，http://www.jetbrains.com/webstorm/ PyCharm Python 开发，http://www.jetbrains.com/pycharm/ Android Studio Android 开发，https://developer.android.com/studio/index.html Xcode IOS 开发，Mac App Store HBuilder 跨平台的 mui 应用开发，http://www.dcloud.io/ Sublime text 文本编辑器，https://www.sublimetext.com/ Virtual Studio Code 文本编辑器，https://code.visualstudio.com/download Navicat Premium 一个可多重连接的数据库管理工具，支持的数据库有： MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL，http://xclient.info/s/navicat-premium.html?_=80fb58a8555e8bf529af34d2f81df569 JD-GUI 反编译 class 文件，http://jd.benow.ca/ docker 容器，https://www.docker.com/get-docker rdm redis 桌面管理软件，https://github.com/uglide/RedisDesktopManager Genymotion 安卓模拟器，https://www.genymotion.com/ Beyond Compare 文件比对软件 Mock Plus 原型图软件，https://www.mockplus.cn/ Sketch 移动应用矢量绘图设计工具，http://xclient.info/s/sketch.html?_=80fb58a8555e8bf529af34d2f81df569 Axure RP 8 快速原型设计工具，http://xclient.info/s/axure-rp.html?_=80fb58a8555e8bf529af34d2f81df569 Postman HTTP 模拟请求工具，https://www.getpostman.com/ Insomnia HTTP 模拟请求工具，比 Postman 界面更干净，https://insomnia.rest/ SSH Shell 远程连接到 Linux 服务器，管理多个 SSH 会话，http://xclient.info/s/ssh-shell.html?_=80fb58a8555e8bf529af34d2f81df569 LaunchRocket 统一管理 Mac 上的一些服务，比如说 redis、mysql、zookeeper、rabbitmq等等服务，https://github.com/jimbojsb/launchrocket]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 MSSQL/MYSQL/ORACLE 的分页语句]]></title>
    <url>%2F2018%2F01%2F16%2Fdb-page-sqls.html</url>
    <content type="text"><![CDATA[MSSQL 的前 N 条记录 12--查询前 N 条记录，可以改成需要的数字SELECT TOP N * FROM TABLE_NAME MSSQL 的分页语句，第 N 条到第 M 条记录 1SELECT TOP N T.* FROM ( SELECT TOP M * FROM TABLE_NAME ORDER BY COLUMN_NAME ) T ORDER BY T.COLUMN_NAME DESC MYSQL 的前 N 条记录 12-- 通常0是可以省略的，直接写成 LIMIT N。0代表从第0条记录后面开始，也就是从第一条开始SELECT * FROM TABLE_NAME LIMIT 0,N MYSQL 的分页语句，第 N 条开始，每页 M 条 1SELECT * FROM TABLE_NAME LIMIT N,M ORACLE 的前 N 条记录 12-- N 为前多少条记录SELECT * FROM TABLE_NAME WHERE ROWNUM &lt; N ORACLE 的分页语句，第 N 条到第 M 条记录 12-- 这句就是从 N 到 M 的数据，分为三层结构SELECT * FROM ( SELECT T.*,T.ROWNUM RN FROM ( SELECT * FROM TABLE_NAME ) T WHERE T.ROWNUM &lt; M ) WHERE RN &gt; N]]></content>
      <categories>
        <category>代码片段</category>
        <category>sql</category>
      </categories>
      <tags>
        <tag>代码片段</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch 笔记]]></title>
    <url>%2F2018%2F01%2F12%2Felasticsearch_note.html</url>
    <content type="text"><![CDATA[ElasticSearch是一个基于 Lucene 的分布式搜索引擎，业内简称ES。它提供了基于 RESTful 风格的全文搜索API。Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前最流行的企业级搜索引擎。另外，它的分布式设计让它天生就适合用于云计算中，并能够达到准实时搜索，而且安装使用方便，还拥有稳定，可靠，快速等特性。本文是我对 ES 的一个完整记录，方便后期查阅。另外大家还可以查阅更多的相关资料对 ElasticSearch 有更深入的了解。 1. 安装 1.1. 单机安装 ElasticSearch 要求本地的 JDK 版本不低于1.8 去官网下载最新版的 ES 软件包 https://www.elastic.co/downloads/elasticsearch ，目前 ES 最新版本为6.1.1，我这里采用 wget 命令在终端下载 12cd appswget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.1.1.tar.gz 如果出现 command not found: wget，如果是 Linux，可以用 yum install -y wget 下载，如果是 Mac 就可以用 brew install wget 下载 检查本地 JDK 版本，必须保证为1.8版本以上 1234$ java -versionjava version "1.8.0_131"Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 解压软件包 1tar -zxvf elasticsearch-6.1.1.tar.gz 启动 ES 12cd elasticsearch-6.1.1./bin/elasticsearch 测试，打开 PostMan 测试 http://localhost:9200 ，查看返回的 JSON 信息 1.2. 分布式安装 这里我会在本地启动3个 ES 节点，分别用不同的端口号来模拟分布式的环境，一个节点为 master，另外两个节点为 slave 节点。 下载安装包，解压3份，分别命名为 elasticsearch-master，elasticsearch-slave1，elasticsearch-slave2 修改 elasticsearch-master 的配置文件，config/elasticsearch.yml 123456789101112http.cors.enabled: truehttp.cors.allow-origin: "*"## 用于指定集群名称cluster.name: xkcoding## 用于指定节点名称node.name: master## 用于指定当前节点是 master 节点node.master: truenetwork.host: 127.0.0.1http.port: 9200 修改 elasticsearch-slave1 的配置文件，config/elasticsearch.yml 12345678910111213http.cors.enabled: truehttp.cors.allow-origin: "*"## 用于指定集群名称cluster.name: xkcoding## 用于指定节点名称node.name: slave1network.host: 127.0.0.1http.port: 8200## 用于发现 master 节点discovery.zen.ping.unicast.hosts: ["127.0.0.1"] 修改 elasticsearch-slave2 的配置文件，config/elasticsearch.yml 12345678910111213http.cors.enabled: truehttp.cors.allow-origin: "*"## 用于指定集群名称cluster.name: xkcoding## 用于指定节点名称node.name: slave2network.host: 127.0.0.1http.port: 7200## 用于发现 master 节点discovery.zen.ping.unicast.hosts: ["127.0.0.1"] 启动 head 插件，打开浏览器，访问 http://localhost:9100，查看分布式节点的运行状态 1.3. 插件安装 1.3.1. head 插件 独立安装 独立安装是指，head插件安装在es外部， 独立安装 head 插件，要求本地的 Node 版本不低于8.0 前往 GitHub 搜索 elasticsearch-head ，这里我直接给出插件的 GitHub 仓库地址，https://github.com/mobz/elasticsearch-head ，clone 源代码 12cd ~/appsgit clone https://github.com/mobz/elasticsearch-head.git 检查本地 Node 版本，必须保证为8.0版本以上 12$ node -vv8.5.0 编译 head 插件 12cd ~/apps/elasticsearch-headnpm install 如果觉得这一步的依赖下载比较慢的话，有两种解决方式： 可以选择科学上网 使用国内阿里的镜像源，使用 cnpm 安装，具体如何配置，本文不做赘述。具体参考：http://npm.taobao.org/ 配置 ES 支持跨域访问，让 head 插件可以访问到 12cd ~/apps/elasticsearch-6.1.1vim config/elasticsearch.yml 添加进下面两行对跨域的配置 12http.cors.enabled: truehttp.cors.allow-origin: "*" 保存 :wq! 配置文件，启动 ES 1./bin/elasticsearch 运行 head 插件 12cd ~/apps/elasticsearch-headnpm run start 打开浏览器，访问 http://localhost:9100/ ，查看 head 插件运行效果 集成安装 ES 版本 5.x 以上，不支持这种方式安装，如果想使用head插件，请使用独立安装 使用ES提供的插件安装方式安装 1./bin/plugin install mobz/elasticsearch-head 打开浏览器，访问 http://localhost:9200/_plugin/head/ ，查看 head 插件运行效果 1.3.2. ik 中文分词插件 ik 分词插件版本与ES版本对照，请查阅：https://github.com/medcl/elasticsearch-analysis-ik#versions 手动安装 在 ES 的 plugins 目录下创建 ik 目录 1cd ./plugins &amp;&amp; mkdir ik 下载编译包到 ik 目录，下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases 解压下载的压缩包 1unzip elasticsearch-analysis-ik-&#123; ES 版本 &#125;.zip 重启 ES 自动安装 使用 ES 提供的插件安装方式安装，替换下面的ES 版本，具体信息可以去 https://github.com/medcl/elasticsearch-analysis-ik/releases 查看 1./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/&#123; ES 版本 &#125;/elasticsearch-analysis-ik-&#123; ES 版本 &#125;.zip 重启 ES 2. 常见错误 错误1：进程虚拟内存 1[3]: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144] vm.max_map_count：限制一个进程可以拥有的VMA(虚拟内存区域)的数量。 切换到root用户，修改配置文件： 1vim /etc/sysctl.conf 添加下面的内容： 1vm.max_map_count=655360 然后执行命令： 1sysctl -p 错误2：文件权限不足 1[1]: max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536] 用的是es用户，而不是root，所以文件权限不足。 使用root用户登录 修改配置文件： 1vim /etc/security/limits.conf 添加下面的内容： 1234567* soft nofile 65536* hard nofile 131072* soft nproc 4096* hard nproc 4096 重启终端窗口 所有错误修改完毕，一定要重启你的终端，否则配置无效。 3. 基础概念 3.1. 集群和节点 每个节点都是一个 ES 的单独实例，通过 node_name 来指定各个节点的名字。 集群是通过配置cluster_name来使得节点找到集群。 3.2. 索引 索引是含有相同属性的文档集合，在 ES 中是通过一个名字来识别的，而且要求是英文字母小写且不包含中划线 索引对应于 SQL 的 database 3.3. 类型 索引可以含有一个或者多个类型，文档必须属于一个类型 类型对应于 SQL 的 table 3.4. 文档 文档是可以被索引的基本数据单位 文档对应于 SQL 的一条记录 3.5. 分片 每个索引都有多个分片，每个分片都是一个 Lucene 索引 3.6. 备份 拷贝一份分片就完成了分片的备份 4. 基本用法 4.1. 请求方式 API 基本格式：http://&lt;ip&gt;:&lt;port&gt;/&lt;索引&gt;/&lt;类型&gt;/&lt;文档 id&gt; API 请求方式：GET、POST、PUT、DELETE 4.2. 索引 创建 假设创建一个 people 的索引，打开 PostMan，输入地址 http://localhost:9200/people ，将方法改为 PUT 方法，将👇的 json 放入 Body 请求体，点击 Send，若出现 &quot;acknowledged&quot;:true，则代表索引创建成功。 请求体的 json: 12345678910111213141516171819202122232425&#123; "settings":&#123; "number_of_shards":3, "number_of_replicas":1 &#125;, "mappings":&#123; "person":&#123; "properties":&#123; "name":&#123; "type":"text" &#125;, "age":&#123; "type":"integer" &#125;, "country":&#123; "type":"keyword" &#125;, "birthday":&#123; "type":"date", "format":"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis" &#125; &#125; &#125; &#125;&#125; json 请求体字段解释：settings 字段可以不指定number_of_shards 代表分片数（默认为5）number_of_replicas 代表备份数（默认为1）text 类型的字段搜索时将会被分词keyword 类型的字段搜索时将不会被分词epoch_millis 类型代表时间戳格式 返回值： 12345&#123; "acknowledged": true, "shards_acknowledged": true, "index": "people"&#125; 如图所示： 删除 打开 PostMan，输入地址 http://localhost:9200/people ，将方法改为 DELETE 方法，点击 Send。 返回值： 123&#123; "acknowledged": true&#125; 4.3. 插入 现在我们向之前创建的类型中添加一条文档记录，插入分为2种方式，一种是指定 ID，一种是不指定 ID，当不指定 ID 时，ID 由 ES 生成。 指定 ID 插入 打开 PostMan，输入地址 http://localhost:9200/people/person/1 ，将文档的 json 放入 Body 请求体，将方法改为 PUT 方法，点击 Send。 文档内容： 123456&#123; "name":"xkcoding", "age":24, "country":"中国", "birthday":"1994-11-22"&#125; 返回值： 1234567891011121314&#123; "_index": "people", "_type": "person", "_id": "1", "_version": 1, "result": "created", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 1&#125; 如图所示： 不指定 ID 插入 打开 PostMan，输入地址 http://localhost:9200/people/person ，将文档的 json 放入 Body 请求体，将方法改为 POST 方法，点击 Send。 文档内容： 123456&#123; "name":"中年xkcoding", "age":34, "country":"中国", "birthday":"1984-11-22"&#125; 返回值： 1234567891011121314&#123; "_index": "people", "_type": "person", "_id": "I4_sAmEBVnl1iCRF78pG", "_version": 1, "result": "created", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 1&#125; 如图所示： 然后前往 head 插件查看是否插入数据 4.4. 修改 修改文档数据，打开 PostMan，输入地址 http://localhost:9200/people/person/1/_update ，将请求的 json 放入 Body 请求体，将方法改为 POST 方法，点击 Send。 请求体： 12345&#123; "doc":&#123; "name":"沈扬凯" &#125;&#125; 注意：修改的时候 URL 必须后面跟_update，然后要修改的字段必须放在 doc 字段里。 返回值： 1234567891011121314&#123; "_index": "people", "_type": "person", "_id": "1", "_version": 2, "result": "updated", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 1, "_primary_term": 1&#125; 如图所示： 4.5. 删除 打开 PostMan，输入地址 http://localhost:9200/people/person/1 ，将方法改为 DELETE 方法，点击 Send。 返回值： 1234567891011121314&#123; "_index": "people", "_type": "person", "_id": "1", "_version": 3, "result": "deleted", "_shards": &#123; "total": 2, "successful": 2, "failed": 0 &#125;, "_seq_no": 2, "_primary_term": 1&#125; 4.6. 查询 ES 正如其名，本就是为了 Search 而生，所以查询是 ES 最牛逼的地方。使用上面提到的插入语法，预先插入一堆原始数据，用 head 查看。 简单查询 打开 PostMan，输入地址 http://localhost:9200/people/person/1 ，将方法改为 GET 方法，点击 Send。 返回 id 为1的文档数据： 12345678910111213&#123; "_index": "people", "_type": "person", "_id": "1", "_version": 1, "found": true, "_source": &#123; "name": "xkcoding", "age": 24, "country": "中国", "birthday": "1994-11-22" &#125;&#125; 条件查询 这里还是使用 PostMan 来测试我们的条件查询 请求地址：http://localhost:9200/people/_search 请求方式：POST 返回值因为文章篇幅有限，就不将返回的内容贴在文章中了，请自行测试下方请求体，验证结果 查询所有文档数据 请求体： 12345&#123; "query":&#123; "match_all":&#123;&#125; &#125;&#125; 分页查询文档数据，第 0 条开始，每页 3 条数据 请求体： 1234567&#123; "query":&#123; "match_all":&#123;&#125; &#125;, "from":0, "size":3&#125; 查询名字中包含「小」的文档 请求体： 1234567&#123; "query":&#123; "match":&#123; "name":"小" &#125; &#125;&#125; 查询名字中包含「小」的文档，并且按照生日降序排序 请求体： 1234567891011121314&#123; "query":&#123; "match":&#123; "name":"小" &#125; &#125;, "sort":[ &#123; "birthday":&#123; "order":"desc" &#125; &#125; ]&#125; 聚合查询 请求地址：http://localhost:9200/people/_search 请求方式：POST 按照年龄聚合数据，查出文档中不同年龄所占的人数 请求体： 123456789&#123; "aggs":&#123; "group_by_age":&#123; "terms":&#123; "field":"age" &#125; &#125; &#125;&#125; 多个聚合，分别按照年龄、生日聚合数据 请求体： 1234567891011121314&#123; "aggs":&#123; "group_by_age":&#123; "terms":&#123; "field":"age" &#125; &#125;, "group_by_birthday":&#123; "terms":&#123; "field":"birthday" &#125; &#125; &#125;&#125; 年龄最小 请求体： 123456789&#123; "aggs":&#123; "grades_ages":&#123; "min":&#123; "field":"age" &#125; &#125; &#125;&#125; 年龄最大 请求体： 123456789&#123; "aggs":&#123; "grades_ages":&#123; "max":&#123; "field":"age" &#125; &#125; &#125;&#125; 平均年龄 请求体： 123456789&#123; "aggs":&#123; "grades_ages":&#123; "avg":&#123; "field":"age" &#125; &#125; &#125;&#125; 年龄总和 请求体： 123456789&#123; "aggs":&#123; "grades_ages":&#123; "sum":&#123; "field":"age" &#125; &#125; &#125;&#125; 统计，将3、4、5、6的信息统一查询 请求体： 123456789&#123; "aggs":&#123; "grades_ages":&#123; "stats":&#123; "field":"age" &#125; &#125; &#125;&#125; 5. 高级查询 5.1. query 模糊匹配 查询名字中包含「小」的文档 请求体： 1234567&#123; "query":&#123; "match":&#123; "name":"小" &#125; &#125;&#125; 词组匹配 查询名字只包含「小凯」的文档，我们先使用如下的请求体查询 1234567&#123; "query":&#123; "match":&#123; "name":"小凯" &#125; &#125;&#125; 返回的结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 省略其余部分"hits": &#123; "total": 3, "max_score": 1.8386619, "hits": [ &#123; "_index": "people", "_type": "person", "_id": "2", "_score": 1.8386619, "_source": &#123; "name": "年轻的小凯", "age": 14, "country": "中国", "birthday": "2004-11-22" &#125; &#125;, &#123; "_index": "people", "_type": "person", "_id": "4", "_score": 0.8984401, "_source": &#123; "name": "狂小狗", "age": 20, "country": "中国", "birthday": "1998-01-01" &#125; &#125;, &#123; "_index": "people", "_type": "person", "_id": "9", "_score": 0.8142733, "_source": &#123; "name": "小泽", "age": 32, "country": "日本", "birthday": "1986-02-02" &#125; &#125; ]&#125; 通过结果，可以发现，通过 match 去查询的时候，ES 返回的是分别包含「小」、「凯」的文档，如何去查询 name 字段只包含「小凯」的文档呢？使用 match_phrase 可以满足要求。 请求体： 1234567&#123; "query":&#123; "match_phrase":&#123; "name":"小凯" &#125; &#125;&#125; 字段查询 查询所有的中国人 请求体： 1234567&#123; "query":&#123; "term":&#123; "country":"中国" &#125; &#125;&#125; 范围查询（支持数值型和日期型） 查询年龄 24 ≤ age＜30 直接的数据 请求体： 12345678910&#123; "query":&#123; "range":&#123; "age":&#123; "gte":24, "lt":30 &#125; &#125; &#125;&#125; 5.2. filter 一般结合 bool 一起使用， 查询年龄为23的文档数据 请求体： 1234567891011&#123; "query":&#123; "bool":&#123; "filter":&#123; "term":&#123; "age":23 &#125; &#125; &#125; &#125;&#125; 5.3. 复合条件查询 固定分数查询 查询名字中包含「小」的文档，并固定查询分数 请求体： 1234567891011&#123; "query":&#123; "constant_score":&#123; "filter":&#123; "match":&#123; "name":"小" &#125; &#125; &#125; &#125;&#125; 查询名字中包含「小」的文档，并固定查询分数为2 请求体： 123456789101112&#123; "query":&#123; "constant_score":&#123; "filter":&#123; "match":&#123; "name":"小" &#125; &#125;, "boost":2 &#125; &#125;&#125; 布尔查询 查询是国家为中国或者年龄为30的数据 请求体： 1234567891011121314151617&#123; "query":&#123; "bool":&#123; "should":[ &#123; "match":&#123; "country":"中国" &#125; &#125;,&#123; "match":&#123; "age":30 &#125; &#125; ] &#125; &#125;&#125; 查询国家为中国并且年龄为23的数据 请求体： 1234567891011121314151617&#123; "query":&#123; "bool":&#123; "must":[ &#123; "match":&#123; "country":"中国" &#125; &#125;,&#123; "match":&#123; "age":23 &#125; &#125; ] &#125; &#125;&#125; 查询国家为中国并且年龄为23并且生日比1995-07-01早的数据 请求体： 123456789101112131415161718192021222324&#123; "query":&#123; "bool":&#123; "must":[ &#123; "match":&#123; "country":"中国" &#125; &#125;,&#123; "match":&#123; "age":23 &#125; &#125; ], "filter":[&#123; "range":&#123; "birthday":&#123; "lt":"1995-07-01" &#125; &#125; &#125;] &#125; &#125;&#125; 6. Spring Boot 集成 ES 代码托管在 GitHub：戳我获取源码 6.1. Spring Boot 集成 ES 的配置类 在 Spring Boot 中配置类需要使用 @Configuration 来标注 application.yml 12345678server: port: 8080 context-path: /demoelasticsearch: host: 127.0.0.1 port: 9300 cluster: name: xkcoding ElasticSearchConfig.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.xkcoding.springbootdemoelasticsearch.config;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.TransportAddress;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.net.InetAddress;import java.net.UnknownHostException;/** * &lt;p&gt; * ES 的配置类 * &lt;/p&gt; * * @package: com.xkcoding.springbootdemoelasticsearch.config * @description： ES 的配置类 * @author: yangkai.shen * @date: Created in 2018/1/18 下午4:41 * @copyright: Copyright (c) 2018 * @version: 0.0.1 * @modified: yangkai.shen */@Configurationpublic class ElasticSearchConfig &#123; @Value("$&#123;elasticsearch.host&#125;") private String host; @Value("$&#123;elasticsearch.port&#125;") private int port; @Value("$&#123;elasticsearch.cluster.name&#125;") private String clusterName; @Bean public TransportClient esClient() throws UnknownHostException &#123; Settings settings = Settings.builder().put("cluster.name", this.clusterName).put("client.transport.sniff", true).build(); TransportAddress master = new TransportAddress(InetAddress.getByName(host), port); TransportClient client = new PreBuiltTransportClient(settings).addTransportAddress(master); return client; &#125;&#125; 6.2. 插入 123456789101112131415161718192021222324252627282930/** * 插入一条数据到 ES 中，id 由 ES 生成 * * @param name 名称 * @param country 国籍 * @param age 年龄 * @param birthday 生日 * @return 插入数据的主键 */@PostMapping("/person")public ApiResponse add(@RequestParam String name, @RequestParam String country, @RequestParam Integer age, @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") Date birthday) &#123; try &#123; XContentBuilder content = XContentFactory.jsonBuilder() .startObject() .field("name", name) .field("country", country) .field("age", age) .field("birthday", birthday.getTime()) .endObject(); IndexResponse response = esClient.prepareIndex(INDEX, TYPE).setSource(content).get(); return ApiResponse.ofSuccess(response.getId()); &#125; catch (IOException e) &#123; e.printStackTrace(); return ApiResponse.ofStatus(Status.INTERNAL_SERVER_ERROR); &#125;&#125; 6.3. 修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 根据主键，修改传递字段对应的值 * * @param id ES 中的 id * @param name 姓名 * @param country 国籍 * @param age 年龄 * @param birthday 生日 * @return UPDATED 代表文档修改成功 */@PutMapping("/person/&#123;id&#125;")public ApiResponse update(@PathVariable String id, @RequestParam(value = "name", required = false) String name, @RequestParam(value = "country", required = false) String country, @RequestParam(value = "age", required = false) Integer age, @RequestParam(value = "birthday", required = false) @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") Date birthday) &#123; UpdateRequest request = new UpdateRequest(INDEX, TYPE, id); try &#123; XContentBuilder builder = XContentFactory.jsonBuilder().startObject(); if (!Strings.isNullOrEmpty(name)) &#123; builder.field("name", name); &#125; if (!Strings.isNullOrEmpty(country)) &#123; builder.field("country", country); &#125; if (age != null &amp;&amp; age &gt; 0) &#123; builder.field("age", age); &#125; if (birthday != null) &#123; builder.field("birthday", birthday.getTime()); &#125; builder.endObject(); request.doc(builder); &#125; catch (IOException e) &#123; e.printStackTrace(); return ApiResponse.ofStatus(Status.INTERNAL_SERVER_ERROR); &#125; try &#123; UpdateResponse response = esClient.update(request).get(); return ApiResponse.ofSuccess(response); &#125; catch (Exception e) &#123; e.printStackTrace(); return ApiResponse.ofStatus(Status.INTERNAL_SERVER_ERROR); &#125;&#125; 6.4. 删除 1234567891011/** * 根据 id 删除 ES 的一条记录 * * @param id ES 中的 id * @return DELETED 代表删除 */@DeleteMapping("/person/&#123;id&#125;")public ApiResponse delete(@PathVariable String id) &#123; DeleteResponse response = esClient.prepareDelete(INDEX, TYPE, id).get(); return ApiResponse.ofSuccess(response.getResult());&#125; 6.5. 简单查询 1234567891011121314/** * 简单查询 根据 id 查 ES 中的文档内容 * * @param id ES 中存储的 id * @return 对应 id 的文档内容 */@GetMapping("/person/&#123;id&#125;")public ApiResponse get(@PathVariable String id) &#123; GetResponse response = esClient.prepareGet(INDEX, TYPE, id).get(); if (!response.isExists() || response.isSourceEmpty()) &#123; return ApiResponse.ofStatus(Status.NOT_FOUND); &#125; return ApiResponse.ofSuccess(response.getSource());&#125; 6.6. 复合查询 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 复合查询，根据传进来的条件，查询具体内容 * * @param name 根据姓名匹配 * @param country 根据国籍匹配 * @param gtAge 大于年龄 * @param ltAge 小于年龄 * @return 满足条件的文档内容 */@PostMapping("/person/query")public ApiResponse query(@RequestParam(value = "name", required = false) String name, @RequestParam(value = "country", required = false) String country, @RequestParam(value = "gt_age", defaultValue = "0") int gtAge, @RequestParam(value = "lt_age", required = false) Integer ltAge) &#123; BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); if (!Strings.isNullOrEmpty(name)) &#123; boolQueryBuilder.must(QueryBuilders.matchQuery("name", name)); &#125; if (!Strings.isNullOrEmpty(country)) &#123; boolQueryBuilder.must(QueryBuilders.matchQuery("country", country)); &#125; RangeQueryBuilder rangeQueryBuilder = QueryBuilders.rangeQuery("age").from(gtAge); if (ltAge != null &amp;&amp; ltAge &gt; 0) &#123; rangeQueryBuilder.to(ltAge); &#125; boolQueryBuilder.filter(rangeQueryBuilder); SearchRequestBuilder searchRequestBuilder = esClient.prepareSearch(INDEX) .setTypes(TYPE) .setSearchType(SearchType.DFS_QUERY_THEN_FETCH) .setQuery(boolQueryBuilder) .setFrom(0) .setSize(20); log.info("【query】:&#123;&#125;", searchRequestBuilder); SearchResponse searchResponse = searchRequestBuilder.get(); List&lt;Map&lt;String, Object&gt;&gt; result = Lists.newArrayList(); searchResponse.getHits().forEach(hit -&gt; &#123; result.add(hit.getSourceAsMap()); &#125;); return ApiResponse.ofSuccess(result);&#125; 6.8. 搜索建议（有时间补充） 6.7. 聚合查询（有时间补充） 7. 结语 ElasticSearch 在现在是一个应用十分广泛，且火热的技术，本文只是我在入门 ES 的一点小小的记录，更多 ES 的专业知识，优化技巧，还需要大量的学习与实践！ 推荐学习地址： 官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html Elastic 中文社区：https://elasticsearch.cn/]]></content>
      <categories>
        <category>技术相关</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驼峰命名和下划线命名互相转化]]></title>
    <url>%2F2018%2F01%2F11%2Fcamelcase-underline-transform.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.regex.Matcher;import java.util.regex.Pattern;/** * &lt;p&gt; * 驼峰命名和下划线命名互转 * &lt;/p&gt; * * @package: com.xkcoding * @description： 驼峰命名和下划线命名互转 * @author: yangkai.shen * @date: Created in 2018/1/11 上午9:49 * @copyright: Copyright (c) 2018 * @version: 0.0.1 * @modified: yangkai.shen */public class CasesUtil &#123; private static final Pattern CAMELCASE_PATTERN = Pattern.compile("[A-Z]"); private static final Pattern UNDERLINE_PATTERN = Pattern.compile("_[a-z]"); private static final char UNDERLINE = '_'; /** * 驼峰命名（形如：UserInfo）转化为下划线命名（user_info） * * @param camelCase 驼峰格式的字符串 * @return 下划线形式的字符串 */ public static String camelCase2UnderlineCase(String camelCase) &#123; Matcher matcher = CAMELCASE_PATTERN.matcher(camelCase); StringBuilder builder = new StringBuilder(camelCase); for (int i = 0; matcher.find(); i++) &#123; builder.replace(matcher.start() + i, matcher.end() + i, UNDERLINE + matcher.group().toLowerCase()); &#125; if (builder.charAt(0) == UNDERLINE) &#123; builder.deleteCharAt(0); &#125; return builder.toString(); &#125; /** * 下划线命名（user_info）转化为驼峰命名（形如：userInfo） * * @param underlineCase 下划线形式的字符串 * @return 驼峰格式的字符串 */ public static String underlineCase2CamelCase(String underlineCase) &#123; Matcher matcher = UNDERLINE_PATTERN.matcher(underlineCase); StringBuilder builder = new StringBuilder(underlineCase); for (int i = 0; matcher.find(); i++) &#123; builder.replace(matcher.start() - i, matcher.end() - i, matcher.group().substring(1).toUpperCase()); &#125; if (Character.isUpperCase(builder.charAt(0))) &#123; builder.replace(0, 1, String.valueOf(Character.toLowerCase(builder.charAt(0)))); &#125; return builder.toString(); &#125;&#125;]]></content>
      <categories>
        <category>代码片段</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DevOps 之 Jenkins 安装、配置、美化、插件及常见错误处理]]></title>
    <url>%2F2018%2F01%2F04%2Fdevops-jenkins.html</url>
    <content type="text"><![CDATA[继续上一篇的话题，既然已经搭建了 GitLab 的代码仓库，那么现在就可以开始进行下一步持续集成环境的搭建了。公司准备利用 Jenkins CI 进行持续集成，本文记录了 Jenkins 的安装、基础配置、界面美化、常用插件及常见错误处理。 1. 安装Jenkins 准备工作 安装 JDK，并配置环境变量 安装 maven 配置阿里云的 maven 镜像源地址，vim /usr/share/maven/conf/settings.xml 将👇内容添加进 mirrors 节点 1234567&lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 安装 git 配置镜像源地址 123sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keyyum install jenkins 修改访问 IP 和 端口号 vim /etc/sysconfig/jenkins JENKINS_PORT=&quot;10080&quot; 配置 JDK 路径到 Jenkins 中 vim /etc/init.d/jenkins 将自己的 java 目录加入到 candidates 里 123456789candidates=&quot;/etc/alternatives/java/usr/lib/jvm/java-1.8.0/bin/java/usr/lib/jvm/jre-1.8.0/bin/java/usr/lib/jvm/java-1.7.0/bin/java/usr/lib/jvm/jre-1.7.0/bin/java/usr/bin/java/opt/jdk1.8.0_144/bin/java&quot; 安装完毕后启动 1sudo service jenkins start # 启动jenkins服务 2. 配置 Jenkins 初始化密码 cat /var/lib/jenkins/secrets/initialAdminPassword 安装插件 选择左侧推荐的插件安装即可 配置管理员账号密码 配置 JDK、Maven、Git、Docker 系统管理 → 全局工具配置（尽量在服务器本地安装，然后输入安装路径，不推荐使用在线安装，因为在线安装有些资源都在国外，下载速度极慢） 配置邮件服务器信息 系统管理 → 系统设置，①Jenkins Location→系统管理员邮件地址②Extended E-mail Notification③邮件通知。 其中Extended E-mail Notification的两个地方可以做个性化配置： Default Content Type 邮件的内容类型，改为HTML(text/html)。 Default Subject 邮件的标题，改为构建通知：$PROJECT_NAME - Build # $BUILD_NUMBER - $BUILD_STATUS!。 Default Content 邮件的内容，改为👇内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;$&#123;PROJECT_NAME&#125;-第$&#123;BUILD_NUMBER&#125;次构建日志&lt;/title&gt;&lt;/head&gt;&lt;body leftmargin="8" marginwidth="0" topmargin="8" marginheight="4" offset="0"&gt; &lt;table width="95%" cellpadding="0" cellspacing="0" style="font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif"&gt; &lt;tr&gt; &lt;td&gt;(本邮件是程序自动下发的，请勿回复！)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;h2&gt; &lt;font color="#0000FF"&gt;构建结果 - $&#123;BUILD_STATUS&#125;&lt;/font&gt; &lt;/h2&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;br /&gt; &lt;b&gt;&lt;font color="#0B610B"&gt;构建信息&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;项目名称： $&#123;PROJECT_NAME&#125;&lt;/li&gt; &lt;li&gt;构建编号： 第$&#123;BUILD_NUMBER&#125;次构建&lt;/li&gt; &lt;li&gt;触发原因： $&#123;CAUSE&#125;&lt;/li&gt; &lt;li&gt;构建日志： &lt;a href="$&#123;BUILD_URL&#125;console"&gt;$&#123;BUILD_URL&#125;console&lt;/a&gt;&lt;/li&gt; &lt;li&gt;构建Url： &lt;a href="$&#123;BUILD_URL&#125;"&gt;$&#123;BUILD_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;工作目录： &lt;a href="$&#123;PROJECT_URL&#125;ws"&gt;$&#123;PROJECT_URL&#125;ws&lt;/a&gt;&lt;/li&gt; &lt;li&gt;项目Url： &lt;a href="$&#123;PROJECT_URL&#125;"&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color="#0B610B"&gt;Changes Since Last Successful Build:&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;ul&gt; &lt;li&gt;历史变更记录 : &lt;a href="$&#123;PROJECT_URL&#125;changes"&gt;$&#123;PROJECT_URL&#125;changes&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; $&#123;CHANGES_SINCE_LAST_SUCCESS,reverse=true, format="Changes for Build #%n:&lt;br /&gt;%c&lt;br /&gt;",showPaths=true,changesFormat="&lt;pre&gt;[%a]&lt;br /&gt;%m&lt;/pre&gt;",pathFormat=" %p"&#125; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;Test Informations&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;pre style="font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif"&gt;Total:$&#123;TEST_COUNTS,var="total"&#125;,Pass:$&#123;TEST_COUNTS,var="pass"&#125;,Failed:$&#123;TEST_COUNTS,var="fail"&#125;,Skiped:$&#123;TEST_COUNTS,var="skip"&#125;&lt;/pre&gt; &lt;br /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;b&gt;&lt;font color="#0B610B"&gt;构建日志 (最后 100行):&lt;/font&gt;&lt;/b&gt; &lt;hr size="2" width="100%" align="center" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;textarea cols="80" rows="30" readonly="readonly" style="font-family: Courier New"&gt;$&#123;BUILD_LOG, maxLines=100&#125;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 勾选上 Enable Debug Mode、Require Administrator for Template Testing、Enable watching for jobs、Allow sending to unregistered users 3. 美化 Jenkins 安利一款material风格的主题：http://afonsof.com/jenkins-material-theme/ ，支持使用 CDN，也支持自定义公司 logo 等等。 4. 常用插件 Maven Integration plugin：用于构建 Maven 项目 Gitlab Hook Plugin：用于触发 GitLab 的一些 WebHooks 来构建项目 Simple Theme Plugin：配合上面的美化 Jenkins 使用 FireLine Plugin：代码规范检查，已经集成了阿里巴巴的代码规约（P3C）检查 HTML Publisher plugin：将一些测试结果变成 HTML 文档 JUnit Plugin：JUnit 测试 Checkstyle Plug-in：检测代码风格 FindBugs Plug-in：检测构建出来的 class 文件是否安全 Static Analysis Collector Plug-in：对7、8两个插件检测出来的结果进行汇总 Extended E-mail Notification：个性化邮件模板 Dingding[钉钉] Plugin：钉钉通知插件 5. 常见错误解决 添加镜像源的时候出现如下错误： 123Resolving pkg.jenkins-ci.org (pkg.jenkins-ci.org)... failed: Temporary failure in name resolution.wget: unable to resolve host address ‘pkg.jenkins-ci.org’ 解决方法： vim /etc/resolv.conf 添加一行 nameserver 8.8.8.8 HTML Publisher Plugin 插件在新的Jenkins版本中，打开生成的网页中无法加载CSS、无法点击按钮等情况： 由于 CSP（Content Security Policy）所致，可在 系统管理→脚本命令行 中执行： System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;,&quot;&quot;)]]></content>
      <categories>
        <category>技术相关</category>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>jenkins</tag>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DevOps 之 GitLab 安装、汉化及常见错误处理]]></title>
    <url>%2F2018%2F01%2F03%2Fdevops-gitlab.html</url>
    <content type="text"><![CDATA[公司现在开始实行 DevOps 的开发模式，代码托管采用了 GitLab 搭建私有代码仓库，本文记录了 GitLab 的安装、汉化及常见错误处理。 1. 安装GitLab 准备工作 12345678sudo yum install curl policycoreutils openssh-server openssh-clientssudo systemctl enable sshdsudo systemctl start sshdsudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfixsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 配置镜像源地址 12curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashsudo yum install gitlab-ce 安装完毕后执行注册启动 1sudo gitlab-ctl reconfigure 修改访问 IP 和 端口号 vim /etc/gitlab/gitlab.rb 修改 external_url ，比如 http://localhost:9080 配置邮件发送服务 vim /etc/gitlab/gitlab.rb 修改与 email 有关的配置项 123456789101112131415161718192021222324252627## 邮箱基础配置gitlab_rails[&apos;gitlab_email_enabled&apos;] = truegitlab_rails[&apos;gitlab_email_from&apos;] = &apos;237497819@qq.com&apos;gitlab_rails[&apos;gitlab_email_display_name&apos;] = &apos;237497819&apos;gitlab_rails[&apos;gitlab_email_reply_to&apos;] = &apos;237497819@qq.com&apos;gitlab_rails[&apos;gitlab_email_subject_suffix&apos;] = &apos;&apos;gitlab_rails[&apos;gitlab_default_can_create_group&apos;] = truegitlab_rails[&apos;gitlab_username_changing_enabled&apos;] = true## smtp 配置gitlab_rails[&apos;smtp_enable&apos;] = truegitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.qq.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 25gitlab_rails[&apos;smtp_user_name&apos;] = &quot;237497819@qq.com&quot;gitlab_rails[&apos;smtp_password&apos;] = &quot;*********&quot;gitlab_rails[&apos;smtp_domain&apos;] = &quot;smtp.qq.com&quot;gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;smtp_tls&apos;] = falsegitlab_rails[&apos;smtp_openssl_verify_mode&apos;] = &apos;none&apos;gitlab_rails[&apos;smtp_ca_path&apos;] = &quot;/etc/ssl/certs&quot;gitlab_rails[&apos;smtp_ca_file&apos;] = &quot;/etc/ssl/certs/ca-certificates.crt&quot;## 用户配置user[&apos;git_user_email&apos;] = &quot;237497819@qq.com&quot; 2. 汉化 GitLab 注意：汉化之前是必须设置root密码登录过的，否则有些必须文件没有生成，汉化不成功。 汉化包版本选择：version ≤ 8.8、version &gt; 8.8 查看安装的 GitLab 的版本 12cat /opt/gitlab/embedded/service/gitlab-rails/VERSION10.3.2 停止 GitLab 服务：gitlab-ctl stop git clone https://gitlab.com/xhang/gitlab.git 汉化操作： 12cd gitlabyes|cp -rf ../gitlab/* /opt/gitlab/embedded/service/gitlab-rails/ 重新启动查看效果：gitlab-ctl start 3. 日常 GitLab 管理 1gitlab-ctl start|stop|status|restart 4. 常见错误解决 在卸载 GitLab 然后再次安装执行 sudo gitlab-ctl reconfigure 的时候往往会出现：ruby_block[supervise_redis_sleep] action run，会一直卡无法往下进行。 按住 CTRL+C 强制结束； 运行：sudo systemctl restart gitlab-runsvdir 再次执行：sudo gitlab-ctl reconfigure gitlab-ctl reconfigure 之后，访问浏览器出现如下错误：Whoops, GitLab is taking too much time to respond. 使用 gitlab-ctl tail 查看完整的 gitlab-ctl reconfigure 日志 我出现这个的错误是因为日志中出现了端口占用 123==&gt; /var/log/gitlab/unicorn/unicorn_stderr.log &lt;==Errno::EADDRINUSE: Address already in use - bind(2) for 127.0.0.1:8080 vim /etc/gitlab/gitlab.rb 去修改 unicorn 的 url 和 port 12unicorn[&apos;listen&apos;] = &apos;127.0.0.1&apos;unicorn[&apos;port&apos;] = 8888 再次执行：sudo gitlab-ctl reconfigure 有时也可能是超时引起的这个错误，vim /etc/gitlab/gitlab.rb 去修改 webhook_timeout 1234## unicorn 连接超时unicorn[&apos;worker_timeout&apos;] = 90## WebHook 超时时间gitlab_rails[&apos;webhook_timeout&apos;] = 60 5. 配置 push 操作时发送 diff 信息给指定人邮箱 创建用户的时候，邮箱保证正确。 User Settings --&gt; Profile --&gt; Main Settings --&gt; email / public email 里是你的邮箱 User Settings --&gt; Emails 保证第二步里显示的 email在这里是 verified 状态 User Settings --&gt; Notifications 里 email保证正确，选择 level 为第一个，并勾选接收通知如下图 创建一个项目 Settings --&gt; Integrations --&gt; email on push，具体如下图 ❤️enjoy it ~~]]></content>
      <categories>
        <category>技术相关</category>
        <category>devops</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提升 JAVA 编程技能]]></title>
    <url>%2F2017%2F12%2F11%2Ftips-for-improve-java-skill.html</url>
    <content type="text"><![CDATA[翻译自： How to improve Java programming skill 深入理解 OO 思想 多读 JAVA 相关的书籍 多练习，只有多去写代码，才能更懂代码 阅读关键的 API（java.lang.*，java.io.*，java.util.*）的源码 处理问题之前，花更多的时间去分析问题，这其实是在节约时间 通过帮助他人来提升自己对问题的理解 尽量写简单、容易理解的逻辑代码，而不是通过复杂的代码来彰显自己的代码多么牛逼，好的代码本身就是文档 多阅读大牛的技术博客 保持跟进新的 JAVA 技术，可以不去精通，但是你不能落后 多阅读文档 不要去和他人比较（最后一点，但并不是关键性的），最大的敌人永远是你自己]]></content>
      <categories>
        <category>技术相关</category>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux 和 mobx 初体验]]></title>
    <url>%2F2017%2F12%2F05%2Fredux-and-mobx-first.html</url>
    <content type="text"><![CDATA[前段时间搞了 Vue，现在又得开始写 React 了。 我堂堂的一个后端，真是太残忍啦 o(╯□╰)o 接触过 Vue 的应该都知道，Vue 的状态管理可以有两种实现，一种是 Vuex，还有一种是 eventBus 形式。 React 状态管理，老牌的应该是 Redux，但是存在了太多的概念，对于刚接触的童鞋不太友好。mobx 当属时代的新星了。不管从效率，还是易读性都远超 Redux。 下面带来俩小🌰大家感受下~~ 最简单的一个 redux 操作 123456789101112131415161718192021222324252627import &#123;createStore&#125; from 'redux';const ADD_ACTION = 'ADD';const add = (num) =&gt; &#123; return &#123; type: ADD_ACTION, num &#125;;&#125;;const initialState = &#123; count: 0&#125;;const reducers = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case ADD_ACTION: return Object.assign(&#123;&#125;, state, &#123;count: state.count + action.num&#125;); default: return state; &#125;&#125;;const reduxStore = createStore(reducers);reduxStore.dispatch(add(1)); 最简单的一个 mobx 操作 12345678910import &#123;observable, action&#125; from 'mobx';const mobxStore = observable(&#123; count: 0, add: action((num) =&gt; &#123; this.count += num; &#125;)&#125;);mobxStore.add(1);]]></content>
      <categories>
        <category>技术相关</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 下彻底解决 mysql 中文乱码问题]]></title>
    <url>%2F2017%2F11%2F14%2Fmysql-chinese-character-encoding.html</url>
    <content type="text"><![CDATA[数据库中文乱码是个比较常见的问题，今天笔者就遇到了。 系统环境：macOS Sierra 10.12.6MySQL 版本：5.7.18 Homebrew连接软件：Navicat Premium 12.0.12 TNT edition 1. MySQL程序问题 1234567891011121314151617181920#启动mysql.server start#关闭mysql.server stop#执行mysql命令mysql;#查看编码设置[下面显示的是已经设置好的]mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+--------------------------------------------------------+| Variable_name | Value |+--------------------------+--------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/Cellar/mysql/5.7.18_1/share/mysql/charsets/ |+--------------------------+--------------------------------------------------------+ 与客户端（网页或软件：web／终端／数据库管理工具）有关的： character_set_client：对客户端的请求字符串进行编码 character_set_connection：连接服务器时的默认编码，例如navicat连接阿里云服务器 character_set_results：表示客户端想以哪种编码接收查询结果 如果后两个没有特别指定，则默认和character_set_client是一样的 与服务器端（增删查改命令）有关的： character_set_server：服务器编码 character_set_database：创建数据库时的默认编码 如果后一个没有特别指定，则默认和character_set_server是一样的 其他： character_set_filesystem：以二进制文件进行设置，不影响字符显示 character_set_system：用于mysql存储标识符，一直是UTF8，也不影响字符显示 因此如果字符编码有异常，我们只需要在my.cnf中对character_set_client与character_set_server进行设置就ok了。 12345#默认路径下，配置文件加载的先后顺序/etc/my.cnf/etc/mysql/my.cnf/usr/local/etc/my.cnf~/.my.cnf 但是我的系统是通过 homebrew 安装的 MySQL，默认情况下没有 my.cnf 文件。 1cd /etc &amp;&amp; touch my.cnf 使用 vi 编辑器将下面内容写入 /etc/my.cnf 。 1234[client]default-character-set=utf8[mysqld]character-set-server=utf8 保存退出，然后停止 MySQL（mysql.server stop），并重新启动 MySQL（mysql.server start），并用以下命令校验字符编码信息。 1234#执行mysql命令mysql -uroot -proot;#查看编码设置[下面显示的是已经设置好的]mysql&gt; show variables like &apos;%char%&apos;; 2. MySQL 数据库数据问题 如果显示的数据查询结果还是乱码，可能就是之前创建的数据库或数据表有问题了，可以通过以下方式进行检查。 查询数据库支持的所有字符集 1show character set;或者show char set; 查看mysql服务器当前状态 1status或者\s 查看数据库编码 1show create database dbname; 查看数据表编码 1show create table tablename\G; 查看数据表字段编码 1show full columns from tablename; 如果发现编码不是 UTF-8，请重新创建相应的数据库／数据表／字段 。 3. Mac终端－iTerm2软件设置 这一种情况比较少见，就是Mac终端不支持显示中文，这样也会导致乱码。 一方面对终端软件如iterm2的软件偏好设置进行修改为utf-8。 另一方面就是在终端执行以下语句： 12LANG='zh_CN.UTF-8';export $LANG; 4. MySQL 管理工具—Navicat 软件设置 笔者这次遇到的问题就属于最后一种，前面的数据库配置，查看的编码都是正确的，并且使用程序查询出来的也没有乱码，偏偏 Navicat 显示数据表时中文便乱码了，那么请新建mysql服务器连接，Encoding那一栏不要选择默认的 UTF-8，选择Auto即可正常显示中文。 5. 参考 Mac系统解决MySQL乱码问题]]></content>
      <categories>
        <category>技术相关</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Druid 加速 oracle 的查询]]></title>
    <url>%2F2017%2F11%2F10%2Fdruid-oracle-pscache.html</url>
    <content type="text"><![CDATA[##1. 问题 最近，公司的 web 应用，查询数据有些慢，数据库使用的是 oracle，连接池采用了阿里巴巴温少开源的 Druid 连接池，于是开始寻找解决办法。 2. 方法 首先我们需要做的应该是通过 Druid 来监控我们应用中的慢 SQL，然后对其进行优化。从 SQL 监控和 SQL 防火墙中，我发现我们的 SQL 并没有多少慢 SQL。于是排除了慢 SQL 导致查询变慢的原因。 Druid 中支持配置 PSCache。我们的 web 程序并没有开启这个选项，我们将其开启，发现查询返回的结果速度快了 20% 左右。 3. 原理 oracle 支持游标，一个 PreparedStatement 对应服务器一个游标，如果 PreparedStatement 被缓存起来重复执行，PreparedStatement 没有被关闭，服务器端的游标就不会被关闭，性能提高非常显著。在类似 SELECT * FROM T WHERE ID = ? 这样的场景，启用 PSCache 和不启用 PSCache 的性能可能是相差一个数量级的。 连接 oracle 数据库，打开 PSCache，但是其他的数据库连接池都会存在内存占用过多的问题，Druid 是唯一解决这个问题的连接池。]]></content>
      <categories>
        <category>技术相关</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo前置知识：dubbo-admin 的安装]]></title>
    <url>%2F2017%2F11%2F08%2Fdubbo-admin-install.html</url>
    <content type="text"><![CDATA[dubbo-admin 是 dubbo 官方提供的一个的管控台程序，可以对 dubbo 服务进行监控，还可以对其进行权重分配、负载均衡策略等的调优操作，简而言之，我们可以通过 dubbo-admin，对我们的 dubbo 服务进行服务治理及服务监控。 现在，我们开始安装及配置 dubbo-admin。 首先启动我们之前安装了 zookeeper 集群的三台 Linux 虚拟机，并将虚拟机的 zookeeper 集群启动起来。 前往 GitHub 的 dubbo-ops 仓库 去 clone 最新的 dubbo 源码。 12# yangkai.shen @ localhost in ~/Documents/code/open [16:23:11]$ git clone https://github.com/apache/incubator-dubbo-ops.git 进入 dubbo 项目文件夹里的 dubbo-admin 文件夹中。 12# yangkai.shen @ localhost in ~/Documents/code/open [16:24:05] C:1$ cd incubator-dubbo-ops 使用 maven 编译打包项目，然后在 dubbo/dubbo-admin/target 目录中得到 dubbo-admin 的 war 包程序。 1234567891011121314151617181920# yangkai.shen @ localhost in ~/Documents/code/open/dubbo/dubbo-admin on git:master o [16:24:12]$ mvn package[INFO] Scanning for projects......省略中间一些日志信息...[INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO][INFO] dubbo-ops .......................................... SUCCESS [ 0.003 s][INFO] dubbo-admin ........................................ SUCCESS [ 3.612 s][INFO] dubbo-monitor-simple ............................... SUCCESS [ 2.491 s][INFO] dubbo-registry-simple .............................. SUCCESS [ 0.699 s][INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 6.941 s[INFO] Finished at: 2018-04-17T18:37:09+08:00[INFO] Final Memory: 22M/301M[INFO] ------------------------------------------------------------------------ 前往 Apache 的 Tomcat 主页，下载并解压一个新的 Tomcat 程序，专门用来启动 dubbo-admin 。 接下来我们开始对 Tomcat 以及 dubbo-admin 做一些配置。 可以直接将打包出来的 war 文件放在 webapps 目录下，但是为了后面访问 URL 的时候更简单（其实就是想偷懒）可以将其放入 ROOT 下，删除 webapps/ROOT 目录下的所有文件，然后将 打包的 dubbo-admin.war 程序解压至 webapps/ROOT 目录下，注意不需要 dubbo-admin 这个目录，只要将里面的 WEB-INF 这级目录及其子目录的文件放置在 webapps/ROOT 中。 配置 dubbo-admin 的一些启动配置，配置文件是 WEB-INF/dubbo.properties ，我们需要把之前的 zookeeper 集群地址配置上。 12345678# zookeeper 地址，这里是集群配置，如果 zookeeper 是 standalone 模式，那么则不需要 ?backup=*** 这部分内容dubbo.registry.address=zookeeper://172.16.15.129:2181?backup=172.16.15.130:2181,172.16.15.131:2181# dubbo-admin 程序 root 用户的密码dubbo.admin.root.password=root# dubbo-admin 程序 guest 用户的密码dubbo.admin.guest.password=guest 因为考虑到我们自己写程序可能会占用8080端口，因此我们对这个专门为 dubbo-admin 的 Tomcat 重新配置端口，配置文件是 tomcat/conf/server.xml。 修改 HTTP 端口 12345678&lt;!--&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;--&gt;&lt;Connector port="7777" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8444" /&gt; 修改 远程停服务 端口 1234&lt;!--&lt;Server port="8005" shutdown="SHUTDOWN"&gt;--&gt;&lt;Server port="8006" shutdown="SHUTDOWN"&gt; 修改 AJP 端口 1234&lt;!--&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8444" /&gt; --&gt;&lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8444" /&gt; 因为 dubbo-admin 程序较大，因此需要对 Tomcat 做一些调优准备， 在 tomcat/bin/catalina.sh 文件中的第二行加入 JAVA_OPTS='-Xms256m -Xmx512m' ，如下所示。 123#!/bin/shJAVA_OPTS='-Xms256m -Xmx512m'# 省略剩余内容 配置、调优结束，我们就可以运行 tomcat/bin/start.sh 或者 tomcat/bin/start.bat，启动 Tomcat 查看效果了，因为现在只是搭建了 dubbo-admin 还没有 dubbo 服务，因此我们现在只浏览首页和一些系统页面。 浏览器输入 http://localhost:7777 弹出验证信息。 dubbo-admin 首页 系统状态 系统日志 系统环境]]></content>
      <categories>
        <category>技术相关</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo前置知识：zookeeper集群搭建]]></title>
    <url>%2F2017%2F11%2F01%2Fzookeeper-cluster.html</url>
    <content type="text"><![CDATA[拖了一天一天又一天，终于在时隔3月之后，又迎来了一篇新博客。真的是懒癌晚期了。o(╯□╰)o dubbo 框架需要将服务统一注册到一个注册中心，才能被远程调用。这里注册中心可以使用 zookeeper 或者 redis。 这里我们以 zookeeper 为例。zookeeper 可以单机版也就是 standalone模式运行，也可以使用集群方式运行。为了实现高可用，本例采用集群方式部署，需要保证至少半数以上的机器存活，所以至少为3台机器。话不多说，让我们开始 zookeeper 集群的搭建吧： 官网下载 zookeeper-3.4.10.tar.gz ，将软件包分别放在三台 Linux 虚拟机的 /software 目录下。 进入 software 目录下，解压软件包。 123456[root@localhost ~]# cd /software [root@localhost software]# tar -zxvf zookeeper-3.4.10.tar.gz[root@localhost software]# ll total 34228 drwxr-xr-x. 10 1001 1001 4096 Mar 23 2017 zookeeper-3.4.10 -rw-r--r--. 1 root root 35042811 Nov 1 14:58 zookeeper-3.4.10.tar.gz 解压后的文件夹名字包含了版本号，我们将其删除。 12345[root@localhost software]# mv zookeeper-3.4.10 zookeeper [root@localhost software]# ll total 34228 drwxr-xr-x. 10 1001 1001 4096 Mar 23 2017 zookeeper -rw-r--r--. 1 root root 35042811 Nov 1 14:58 zookeeper-3.4.10.tar.gz 进入刚解压的 zookeeper 的目录中 12345678910111213141516171819202122[root@bogon software]# cd zookeeper/ [root@bogon zookeeper]# ll total 1580 drwxr-xr-x. 2 1001 1001 4096 Mar 23 2017 bin -rw-rw-r--. 1 1001 1001 84725 Mar 23 2017 build.xml drwxr-xr-x. 2 1001 1001 74 Mar 23 2017 conf drwxr-xr-x. 10 1001 1001 4096 Mar 23 2017 contrib drwxr-xr-x. 2 1001 1001 4096 Mar 23 2017 dist-maven drwxr-xr-x. 6 1001 1001 4096 Mar 23 2017 docs -rw-rw-r--. 1 1001 1001 1709 Mar 23 2017 ivysettings.xml -rw-rw-r--. 1 1001 1001 5691 Mar 23 2017 ivy.xml drwxr-xr-x. 4 1001 1001 4096 Mar 23 2017 lib -rw-rw-r--. 1 1001 1001 11938 Mar 23 2017 LICENSE.txt -rw-rw-r--. 1 1001 1001 3132 Mar 23 2017 NOTICE.txt -rw-rw-r--. 1 1001 1001 1770 Mar 23 2017 README_packaging.txt -rw-rw-r--. 1 1001 1001 1585 Mar 23 2017 README.txt drwxr-xr-x. 5 1001 1001 44 Mar 23 2017 recipes drwxr-xr-x. 8 1001 1001 4096 Mar 23 2017 src -rw-rw-r--. 1 1001 1001 1456729 Mar 23 2017 zookeeper-3.4.10.jar -rw-rw-r--. 1 1001 1001 819 Mar 23 2017 zookeeper-3.4.10.jar.asc -rw-rw-r--. 1 1001 1001 33 Mar 23 2017 zookeeper-3.4.10.jar.md5 -rw-rw-r--. 1 1001 1001 41 Mar 23 2017 zookeeper-3.4.10.jar.sha1 解释一下，几个常见目录里的内容： bin 目录里存放的是一些可执行文件，基本以 *.bat 和 *.sh 结尾的文件。 conf 目录里存放的是项目（软件）运行时的一些配置文件。 contrib 目录存放的内容官方未提供的一些附加软件。 dist-maven 目录存放的是 zookeeper 使用 maven 编译之后的源码和 jar文件 docs 目录里存放的是一些文档 lib 目录里存放的是依赖库 recipes 目录下存放的是使用 zookeeper 实现的分布式锁、高并发、队列的一些方案 src 目录里存放的是源码文件 在 conf 文件夹里对 zookeeper 进行配置，将示例配置文件复制并改名 1234567891011121314[root@bogon software]# cd zookeeper/conf/ [root@bogon conf]# ll total 12 -rw-rw-r--. 1 1001 1001 535 Mar 23 2017 configuration.xsl -rw-rw-r--. 1 1001 1001 2161 Mar 23 2017 log4j.properties -rw-rw-r--. 1 1001 1001 922 Mar 23 2017 zoo_sample.cfg[root@bogon conf]# cp zoo_sample.cfg zoo.cfg [root@bogon conf]# ll total 16 -rw-rw-r--. 1 1001 1001 535 Mar 23 2017 configuration.xsl -rw-rw-r--. 1 1001 1001 2161 Mar 23 2017 log4j.properties -rw-r--r--. 1 root root 922 Nov 2 14:40 zoo.cfg -rw-rw-r--. 1 1001 1001 922 Mar 23 2017 zoo_sample.cfg[root@bogon conf]# vim zoo.cfg 然后在 zoo.cfg 里加上一些配置 1234567891011121314151617181920212223242526272829303132333435363738tickTime=2000 # The number of ticks that the initial # synchronization phase can take initLimit=10 # The number of ticks that can pass between # sending a request and getting an acknowledgement syncLimit=5 # the directory where the snapshot is stored. # do not use /tmp for storage, /tmp here is just # example sakes. ################ 修改的地方1 ################ # dataDir=/tmp/zookeeper# 将原先的 dataDir 注释，并修改成自定义的路径 dataDir=/software/zookeeper/data # the port at which the clients will connect clientPort=2181 # the maximum number of client connections. # increase this if you need to handle more clients #maxClientCnxns=60 # # Be sure to read the maintenance section of the # administrator guide before turning on autopurge. # # http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance # # The number of snapshots to retain in dataDir #autopurge.snapRetainCount=3 # Purge task interval in hours # Set to "0" to disable auto purge feature #autopurge.purgeInterval=1 ################ 修改的地方2 ################ # 在文件的末尾加上 server.0=172.16.15.129:2888:3888 server.1=172.16.15.130:2888:3888 server.2=172.16.15.131:2888:3888 新建配置文件中的 dataDir 配置的目录 123456789101112131415161718192021222324[root@bogon conf]# cd ../ [root@bogon zookeeper]# mkdir data [root@bogon zookeeper]# ll total 1580 drwxr-xr-x. 2 1001 1001 4096 Mar 23 2017 bin -rw-rw-r--. 1 1001 1001 84725 Mar 23 2017 build.xml drwxr-xr-x. 2 1001 1001 88 Nov 2 14:57 conf drwxr-xr-x. 10 1001 1001 4096 Mar 23 2017 contrib drwxr-xr-x. 2 root root 6 Nov 2 14:58 data drwxr-xr-x. 2 1001 1001 4096 Mar 23 2017 dist-maven drwxr-xr-x. 6 1001 1001 4096 Mar 23 2017 docs -rw-rw-r--. 1 1001 1001 1709 Mar 23 2017 ivysettings.xml -rw-rw-r--. 1 1001 1001 5691 Mar 23 2017 ivy.xml drwxr-xr-x. 4 1001 1001 4096 Mar 23 2017 lib -rw-rw-r--. 1 1001 1001 11938 Mar 23 2017 LICENSE.txt -rw-rw-r--. 1 1001 1001 3132 Mar 23 2017 NOTICE.txt -rw-rw-r--. 1 1001 1001 1770 Mar 23 2017 README_packaging.txt -rw-rw-r--. 1 1001 1001 1585 Mar 23 2017 README.txt drwxr-xr-x. 5 1001 1001 44 Mar 23 2017 recipes drwxr-xr-x. 8 1001 1001 4096 Mar 23 2017 src -rw-rw-r--. 1 1001 1001 1456729 Mar 23 2017 zookeeper-3.4.10.jar -rw-rw-r--. 1 1001 1001 819 Mar 23 2017 zookeeper-3.4.10.jar.asc -rw-rw-r--. 1 1001 1001 33 Mar 23 2017 zookeeper-3.4.10.jar.md5 -rw-rw-r--. 1 1001 1001 41 Mar 23 2017 zookeeper-3.4.10.jar.sha1 在 data 目录中新建一个 myid 文件，这个文件中的内容存放配置文件中对应 IP 的 serverId。 1234[root@bogon zookeeper]# cd data [root@bogon data]# vim myid[root@bogon data]# cat myid 0 将 zookeeper 的目录配置在 Linux 系统的环境变量中 1[root@bogon data]# vim /etc/profile 在文件末尾添加 12export ZOOKEEPER_HOME=/software/zookeeperexport PATH=$ZOOKEEPER_HOME/bin:$PATH 然后让环境变量生效 1[root@bogon data]# source /etc/profile 将另外两台虚拟机也按照 2-7 的步骤配置，注意第6步的 myid 文件里存放的内容，应该与 zoo.cfg 配置文件末尾的 server.n=ip:2888:3888 的 n 对应 配置完环境变量之后，我们就可以不需要到 bin 目录下，直接在任意目录下执行 zookeeper 中 bin 目录下的文件了。 zkServer.sh status ：查看 zookeeper 的状态 zkServer.sh start ：启动 zookeeper zkServer.sh stop ：关闭 zookeeper 分别查看各个虚拟机的启动情况，以及启动后的状态。 虚拟机1：(follower) 123456789101112[root@bogon software]# zkServer.sh status ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Error contacting service. It is probably not running. [root@bogon software]# zkServer.sh start ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Starting zookeeper ... STARTED [root@bogon software]# zkServer.sh status ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Mode: follower 虚拟机2：(leader) 123456789101112[root@bogon ~]# zkServer.sh status ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Error contacting service. It is probably not running. [root@bogon ~]# zkServer.sh start ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Starting zookeeper ... STARTED [root@bogon ~]# zkServer.sh status ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Mode: leader 虚拟机3：(follower) 123456789101112[root@bogon ~]# zkServer.sh status ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Error contacting service. It is probably not running. [root@bogon ~]# zkServer.sh start ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Starting zookeeper ... STARTED [root@bogon ~]# zkServer.sh status ZooKeeper JMX enabled by default Using config: /software/zookeeper/bin/../conf/zoo.cfg Mode: follower 至此，zookeeper 集群的简单搭建已经正式结束了。当然还有一些个性化（调优）的配置参数，请自行参照 zookeeper 的官方文档 在 zoo.cfg 中配置。]]></content>
      <categories>
        <category>技术相关</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>zookeeper</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql启动报错问题]]></title>
    <url>%2F2017%2F08%2F31%2Fmysql-start-error.html</url>
    <content type="text"><![CDATA[今天公司 windows 服务器 MySQL 数据库启动异常，记录下原因。 1. 问题重现 执行 net start mysql 的时候出现如下错误： 123系统出错发生系统错误 1067进程意外终止 2. 排查问题 查阅资料，普遍的解决方法是，my.ini 文件中需要存在 basedir 和 datadir 这两个配置 但是我的 my.ini 原本就已经加入了这两个配置，仍然启动错误。 排查原因，发现是 mysql 的 3306 端口被IEXPLORE.exe占用了 1234# windows 下查看端口占用netstat -aon|findstr "3306"# windows 下根据 id 查看对应程序tasklist|findstr "2016" 3. 解决问题 打开任务管理器， IEXPLORE.exe 的程序杀死，重新 net start mysql MySQL 就愉快的重新启动了。]]></content>
      <categories>
        <category>技术相关</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义阻塞队列]]></title>
    <url>%2F2017%2F08%2F02%2Fcustomize-blocked-queue.html</url>
    <content type="text"><![CDATA[今天重温了下 java 多线程中的 notify() 方法以及 wait() 方法，一时兴起，决定通过这俩个方法，实现一个简易的自定义阻塞队列。 阻塞队列是什么，与普通队列的区别是什么？ 阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来。 新建一个 MyQueue.java 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.LinkedList;import java.util.concurrent.atomic.AtomicInteger;import com.xiaoleilu.hutool.util.StrUtil;/** * 使用 notify() 和 wait() 实现自定义阻塞队列 * * @author Yangkai.Shen * @version 1.0 * @date 2017.08.02 at 11:51:14 */public class MyQueue &#123; // 1. 承载数据的容器 private LinkedList&lt;Object&gt; queue = new LinkedList&lt;Object&gt;(); // 2. 计数器，用于判定边界 private AtomicInteger count = new AtomicInteger(0); private final int minSize = 0; // 3. 初始化一个对象，用于加锁 private final Object lock = new Object(); private final int maxSize; public MyQueue(int maxSize) &#123; this.maxSize = maxSize; &#125; /** * 添加一个元素到队列中，如果队列元素已满，则调用此方法的线程被阻塞，直到存在多余空间了，再进行添加 * * @param obj 添加 obj 到队列尾部 */ public void put(Object obj) &#123; synchronized (lock) &#123; // 1.没有多余空间，就阻塞线程 while (count.get() == this.maxSize) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 2.添加元素 queue.add(obj); // 3.计数器累加 count.incrementAndGet(); System.out.println(StrUtil.format("新加入的元素为：&#123;&#125;", obj)); // 4.唤醒其他线程（若本来元素为空，有线程调用 get 方法，那么原本被阻塞的，需要在此时被唤醒） lock.notify(); &#125; &#125; /** * 获取一个元素，如果队列元素为空，则调用此方法的线程被阻塞，直到添加新元素了，再进行获取 * * @return 返回队列的第一个元素 */ public Object get() &#123; Object ret = null; synchronized (lock) &#123; // 1.没有元素，就阻塞线程 while (count.get() == this.minSize) &#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 2.取第一个元素 ret = queue.removeFirst(); // 3.计数器递减 count.decrementAndGet(); System.out.println(StrUtil.format("移除的元素为：&#123;&#125;", ret)); // 4.唤醒其他线程（若元素本来已满，有线程调用 put 方法，那么原本被阻塞的，需要在此时被唤醒） lock.notify(); &#125; return ret; &#125; public int getSize() &#123; return this.count.get(); &#125;&#125; 新建一个测试类 MyQueueTest.java，测试类中，我们初始化一个队列，并将元素填满，然后启动一个线程 t1，去插入数据，中间休眠2s，再去启动一个线程 t2 取数据。 1234567891011121314151617181920import com.xiaoleilu.hutool.util.StrUtil;import java.util.concurrent.TimeUnit;public class MyQueueTest &#123; public static void main(String[] args) &#123; final MyQueue queue = new MyQueue(5); queue.put("a"); queue.put("b"); queue.put("c"); queue.put("d"); queue.put("e"); System.out.println(StrUtil.format("当前队列的长度: &#123;&#125;", queue.getSize())); Thread t1 = new Thread(() -&gt; &#123; queue.put("f"); queue.put("g"); queue.put("h"); &#125;, "t1"); Thread t2 = new Thread(() -&gt; { queue.get(); queue.get(); }); t1.start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } 启动测试类，查看运行结果。控制台如果应该出现的效果是，队列先初始化完成，然后休眠2s，接下来先取数据，再插入数据，则证明阻塞队列生效。下面是控制台运行的效果： 初始化队列 休眠2s后取队首元素，再插入队尾元素 此时我们会发现，程序还未停止，因为此时队列已满，但是线程 t1 还未插入 h 元素，因此线程被阻塞着，直至下次队列有空余空间才会被唤醒。 至此，一个自定义阻塞队列就已经实现了。 细心的朋友会发现，我打印的 log 里用到了一个 StrUtil.format() 方法，这个和 slf4j 的 log 用法一致，可以使用占位符。这个是用到了一个国产良心工具类，hutool，国产开源，需要大家的支持，觉得好用的话，期望可以去 码云 或者 github 上给个 Star 吧！]]></content>
      <categories>
        <category>代码片段</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-boot整合mybatis的时候使用logback打印日志]]></title>
    <url>%2F2017%2F07%2F19%2Fspring-boot-mybatis-logback.html</url>
    <content type="text"><![CDATA[最近在学习 spring boot ，日志用的是 logback ，至于为什么没有选常用的 log4j ，因为 logback 是 spring boot 官方推荐的日志系统。但是在整合 Mybatis 的时候一直打印不了 SQL 语句，查阅多方资料，终于解决了~ 先展示下 logback-spring.xml 的完整内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;【xkcoding】%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name="fileLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--输出路径--&gt; &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/log/online-study.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;【xkcoding】%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="fileErrorLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!--滚动策略--&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--输出路径--&gt; &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/error/online-study.%d.error&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;【xkcoding】%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logger 属性： 1)name:用来指定受此logger约束的某一个包或者具体的某一个类 2)level:用来设置打印级别，大小写无关（最常用的几种）：DEBUG, INFO, WARN, ERROR --&gt; &lt;!-- 用于打印 Spring 在启动的时候初始化各个 Bean 的信息 --&gt; &lt;logger name="org.springframework.web" level="DEBUG"/&gt; &lt;!-- mybatis 日志打印如果在 ssm 中，可能就需要下边的7行了。--&gt; &lt;!--&lt;logger name="com.ibatis" level="DEBUG" /&gt;--&gt; &lt;!--&lt;logger name="com.ibatis.common.jdbc.SimpleDataSource" level="DEBUG" /&gt;--&gt; &lt;!--&lt;logger name="com.ibatis.common.jdbc.ScriptRunner" level="DEBUG" /&gt;--&gt; &lt;!--&lt;logger name="com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate" level="DEBUG" /&gt;--&gt; &lt;!--&lt;logger name="java.sql.Connection" level="DEBUG" /&gt;--&gt; &lt;!--&lt;logger name="java.sql.Statement" level="DEBUG" /&gt;--&gt; &lt;!--&lt;logger name="java.sql.PreparedStatement" level="DEBUG" /&gt;--&gt; &lt;!-- 以下这一句至关重要如果没有，就无法输出 sql 语句 --&gt; &lt;!--注意：在 spring boot 中，想在控制台打印 mybatis 的 sql 语句，只需要配置下边这一句就好了。--&gt; &lt;!--如果想要记录更详细的 SQL 日志，只需要把下面的日志级别改成 TRACE 就可以了--&gt; &lt;!--即将 mapper 接口打入 logger 就行。--&gt; &lt;logger name="com.xkcoding.dao" level="DEBUG"&gt;&lt;/logger&gt; &lt;root level="info"&gt; &lt;appender-ref ref="consoleLog"/&gt; &lt;appender-ref ref="fileLog"/&gt; &lt;appender-ref ref="fileErrorLog"/&gt; &lt;/root&gt;&lt;/configuration&gt; 如果是 Log4J 实现的话可以参考Mybatis 日志 第一个节点 consoleLog 是在控制台显示的 Log 日志，在控制台显示 Log 日志需要在 appender 节点里配置 class=&quot;ch.qos.logback.core.ConsoleAppender&quot; ，格式化输出的配置在 pattern 节点中配置，各个参数的介绍如下： 123456%-5level: 显示 Log 级别，从左显示5个字符宽度，打印内容: TRACE/DEBUG/INFO/WARN/ERROR%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;: 显示时间戳，&#123;&#125;中内容代表时间戳格式%thread: 显示线程名字%logger&#123;36&#125;: 表示 logger 名字最长36个字符，否则按照句点分割%msg: 日志消息%n: 换行符 第二个节点 fileLog 是将日志保存为文件，需要在 appender 节点里配置 class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot; ，并且指定滚动策略，为每天一个文件，指定文件名为 %d.log 。 12345&lt;!--滚动策略--&gt;&lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!--输出路径--&gt; &lt;fileNamePattern&gt;$&#123;user.dir&#125;/logs/log/online-study.%d.log&lt;/fileNamePattern&gt;&lt;/rollingPolicy&gt; 第三个节点 fileErrorLog 是将错误日志记录在文件中，不保存其他级别的日志，需要配置一个 filter 节点。拦截内容如下（注意单词大小写，千万不能出错！）： 12345&lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;&lt;/filter&gt; 在这里再推荐一个 maven 依赖，lombok 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 在 idea 里安装 lombok 的相应插件 然后就可以在类名上方添加 @Slf4j 注解，这样就可以直接在代码中使用 log.info(&quot;....&quot;) 打印日志了。 再提示下 lombok 的其他使用技巧，如果使用了 lombok ，只要在实体类的类名上加上 @Data 注解，那么我们就不需要写 getter/ setter/toString 方法，lombok 会自动生成 getter/setter/toString 方法，我们直接调用就可以了，如果只需要生成 getter 或者 setter，就可以直接使用 @Getter 或者 @Setter 注解。并且 @Getter 和 @Setter 这两个注解不止可以用在 Class 上，还可以用在 Enum 上哦。 就介绍到这儿，enjoy it !!!]]></content>
      <categories>
        <category>技术相关</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 系统下载与激活]]></title>
    <url>%2F2017%2F07%2F18%2Fwin10-download.html</url>
    <content type="text"><![CDATA[windows 是目前我们用的最多一个系统，win10 现在也优化的越来越好，今天大姐的电脑有点问题，担心太蠢，不会下载和激活系统，所以整理并记录一下如何下载并激活 win10 系统，以供查阅。 微软各类软件下载地址（国人自己搞得，非微软官方） 选择 win10 更新版本 选择 win10 的具体版本 复制版本下载地址，使用迅雷下载 我已经把64位多版本的链接单独抠出来了，需要的直接拿去用~ 1ed2k://|file|cn_windows_10_multiple_editions_version_1703_updated_june_2017_x64_dvd_10724850.iso|5741144064|7717C389428734009E0350A1BB8F2508|/ 附赠一个激活工具下载地址 提取码：1pdp 这个激活工具很强大，可以激活 windows 系统 和 office 软件，并且提供 office 2016和 office 2013两个版本的自动安装功能。 激活工具的使用，下载激活工具，解压压缩包，得到一个名为 KMSTools.exe 的文件，然后右键，以管理员身份运行。（运行之前，注意关闭所有杀毒软件！） 打开之后，选择第二个 KMSAuto Lite 弹出另一个界面，点击 Activate Windows 选择，然后当下面的蓝框框输出 ACTIVATION SUCCESSFUL 的时候，就代表激活成功了。如果卡住了，可以多试几次。 have fun!]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap 的 JDK 源码探索]]></title>
    <url>%2F2017%2F07%2F12%2Fjdk-map-source-explore.html</url>
    <content type="text"><![CDATA[缘由：今天好友拿着下面的代码，问我为什么Map.Entry 这个接口没有实现 getKey() 和 getValue() 方法，却可以使用，由此，开启了一番查阅 JDK 源码的旅途… 12345678910111213Map map = new HashMap(); map.put(1, "张三");map.put(2, "李四");map.put(3, "王五");map.put(4, "赵六");map.put(5, "钱七"); Set set = map.entrySet();for (Object object : set) &#123; Map.Entry entry = (Map.Entry) object; System.out.println(entry.getKey() + "--&gt;" + entry.getValue());&#125; 首先，我们看 map 对象，这个 map 对象是 HashMap 的一个实例，然后下面的 Set set = map.entrySet(); 可以知道这其实用的 HashMap 实现的 entrySet() 方法，然后我们可以查看 HashMap 里 entrySet() 的源码 从源码可以看出，这里的返回了一个 EntrySet 对象，但是需要注意的是这个 EntrySet 是 HashMap 里的一个内部类，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; 从这里我们是可以看出，这个 EntrySet 其实是封装的一个 Node 类的实体。也就是说我们的 set 其实就是这个 Node 对象。 现在我们来说说这个 Node 对象，Node 对象也是 HashMap 里的一个内部类，源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 可以看出来，这个 Node 对象是 Map.Entry&lt;K,V&gt; 的实现类，我们可以看到这个 Node 对象实现了 getKey() 和 getValue() 的方法，所以后面调用的 entry.getKey() 以及 entry.getValue() 方法其实都是调用的 Node 对象里的getKey() 和 getValue() 方法，这里就是 Java 的多态的一种表现。 至此，打完收枪！]]></content>
      <categories>
        <category>技术相关</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 11gR2 RAC的JDBC连接串]]></title>
    <url>%2F2017%2F01%2F06%2Fconnect-oracle11g-rac-url.html</url>
    <content type="text"><![CDATA[今天tomcat启动时，连接oracle直接报错，出现ORA-12505的问题，最开始，我以为错误的原因是jdbc连接Oracle的连接串中的sid配置的不对，oracle不能解析连接串中的sid名字，所以拒绝了连接。在连接字串中写入正确的sid即可。 于是，查看数据库中当前的sid: 1select INSTANCE_NAME from v$instance; 发现sid果然不同，然后将url的sid换成查出来的sid，果然连接上了。 但是我仔细一想，我用原来的sid通过navicat是可以连上oracle的，为什么jdbc会连接不上呢？ 查资料得知，对于Oracle的JDBC连接，是支持EZ-Connect写法的，即jdbc:oracle:thin:@Server:1521/Database 但对于Oracle 11gR2 RAC系统，如果Server用了ScanName，Database用了数据库的ServiceName，并不能连接到数据库，而是报SID错误。 原因可能是此种写法，JDBC将Database解析为了数据库的SID。 经多方测试，可用如下写法实现11GR2的数据库连接的负载均衡，特此记录下： jdbc:oracle:thin:@(DESCRIPTION =(ADDRESS = (PROTOCOL = TCP)(HOST = scan-name)(PORT = 1521))(CONNECT_DATA = (SERVER = DEDICATED)(SERVICE_NAME = DatabaseServiceName)))]]></content>
      <categories>
        <category>技术相关</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch环境搭建及起步]]></title>
    <url>%2F2016%2F12%2F13%2Felasticsearch-get-start.html</url>
    <content type="text"><![CDATA[ElasticSearch 概述 ElasticSearch是一个高可扩展的开源的全文搜索分析引擎。 它允许你快速的存储、搜索和分析大量数据。ElasticSearch通常作为后端程序，为需要复杂查询的应用提供服务。 Elasticsearch是一个基于Lucene的开源分布式搜索引擎，具有分布式多用户能力。Elasticsearch是用java开发，提供Restful接口，能够达到实时搜索、高性能计算；同时Elasticsearch的横向扩展能力非常强，不需要重启服务，基本上达到了零配置。 ElasticSearch 安装 在VMware上安装centos7 安装vim，输入yum install -y vim 安装git，输入：yum install -y git 安装jdk1.8+ 查看CentOS自带JDK是否已安装，输入：yum list installed |grep java。 若有自带安装的JDK，卸载CentOS系统自带Java环境。 卸载JDK相关文件，输入：yum -y remove java-1.8.0-openjdk*。 卸载tzdata-java，输入：yum -y remove tzdata-java.noarch。当结果显示为Complete！即卸载完毕。 注：“*”表示卸载掉java1.8.0的所有openjdk相关文件。 新建目录mkdir /usr/java/ 将下载的jdk的rpm包上传至/usr/java文件夹中，修改权限，输入chmod +x jdk-8u111-linux-x64.rpm 输入rpm -ivh jdk-8u101-linux-x64.rpm安装 输入PATH=&quot;${PATH}:/usr/java/jdk1.8.0_111&quot;，修改环境变量 查看刚安装的Java版本信息，输入：java -version 可查看Java版本。 打开xshell通过xftp将elasticsearch-2.1.1.tar.gz传到虚拟机/opt中，cd到opt目录，输入tar zxvf elasticsearch-2.1.1.tar.gz，解压至当前目录。 注：不可以使用root用户启动elasticsearch，这是出于系统安全考虑设置的条件。由于ElasticSearch可以接收用户输入的脚本并且执行，为了系统安全考虑，建议创建一个单独的用户用来运行xkcoding 如果是用root账号启动，会报以下错误 1Exception in thread "main" java.lang.RuntimeException: don't run elasticsearch as root. at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:93) at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:144) at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:285) at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35) Refer to the log for complete error details. 创建xkcoding用户组及xkcoding用户 12groupadd xkcodinguseradd xkcoding -g xkcoding -p elasticsearch-2.1.1 更改elasticsearch-2.1.1文件夹及内部文件的所属用户及组为xkcoding:xkcoding 12cd /optchown -R xkcoding:xkcoding elasticsearch-2.1.1 切换到elsearch用户再启动 123su xkcodingcd elasticsearch-2.1.1./bin/elasticsearch -d #以守护进程的方式运行 打开一个新的终端进行测试 1curl 'http://localhost:9200/?pretty' 查看返回数据 123456789101112&#123; "name" : "node-1", "cluster_name" : "togeek", "version" : &#123; "number" : "2.1.1", "build_hash" : "40e2c53a6b6c2972b3d13846e450e66f4375bd71", "build_timestamp" : "2015-12-15T13:05:55Z", "build_snapshot" : false, "lucene_version" : "5.3.1" &#125;, "tagline" : "You Know, for Search"&#125; 需要从windows本机访问centos7虚拟机，因此需要关闭防火墙 CentOS 7.0默认使用的是firewall作为防火墙，使用iptables必须重新设置一下 直接关闭防火墙 12systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 设置 iptables service 1yum -y install iptables-services 如果要修改防火墙配置，如增加防火墙端口9200 1vi /etc/sysconfig/iptables 增加规则 1-A INPUT -m state --state NEW -m tcp -p tcp --dport 9200 -j ACCEPT 保存退出后 12systemctl restart iptables.service #重启防火墙使配置生效systemctl enable iptables.service #设置防火墙开机启动 最后重启系统使设置生效即可。 在windows的cmd中测试，返回json，测试通过！]]></content>
      <categories>
        <category>技术相关</category>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lenovo System X3250 M5服务器安装CentOS6.4]]></title>
    <url>%2F2016%2F08%2F31%2Fserver-install-centos6.html</url>
    <content type="text"><![CDATA[前言 第一次真正接触服务器，公司要求安装linux系统，花了2天时间，因为该服务器比较复杂，以此文记录下安装过程中出现的问题。 ### 问题一：安装系统时无法识别硬盘 问题描述： Lenovo System X3250 M5 该服务器最初是存在磁盘阵列的，也就是Raid模式，因此使用 U盘安装系统 时，有时会出现无法识别硬盘的状态。 问题解决： 手动加载驱动的方法 centos 6.2进入安装界面时Tab键进入高级选项，追加输入 linux dd，这样安装时会提示加载disk driver。用管理卡挂载驱动镜像即可。 centos 5.8进入安装界面直接在boot:后面输入 linux dd。 PXE安装自动加载驱动 ks文件中在开头附近增加driverdisk选项 driverdisk --source=http://$ip/driverimg.iso 问题二：使用U盘安装系统，安装过程中说找不到ISO文件 问题描述： 该问题是使用U盘安装系统时会出现的，使用U盘安装的步骤： 使用UltraISO（软碟通）将linux系统镜像写入U盘 ，并且将ISO文件放入U盘 设置U盘启动 安装 问题解决： 方法一：该问题是因为第一步中，U盘格式为FAT32格式，因此镜像大小需小于4G才可以放入U盘，一般系统64位的都会大于4G，选择32位的即可解决。 方法二： 采用外接光驱，使用UltraISO（软碟通）将镜像写入一张白盘 设置光盘启动 安装，亲测，成功！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实际项目中的代码规范]]></title>
    <url>%2F2016%2F04%2F05%2Fcoding-standards.html</url>
    <content type="text"><![CDATA[前言最近在准备软件杯的比赛项目，因为是担任的是项目组长，所以要求组员之间的项目代码必须要有规范，方便组员之间的团队合作，以及后期代码的维护。而且，我相信，如果我们代码规范能够做好的话，对于我们的开发水平也会提高多少。 ## 1. 代码的规范化好处多多 规范的代码可以促进团队合作 规范的代码可以减少bug处理 规范的代码可以降低维护成本 规范的代码有助于代码审查 养成代码规范的习惯，有助于程序员自身的成长 2. 开发前的准备 Eclipse中设置代码样式在 Window --&gt;Preferences 中设置 2.1. 设置工作空间编码为UTF-8 2.2. 设置文件编码为UTF-8 2.3. 方法变量名转化成成员变量名称时，变量名称前加m以示区分 2.4. 配置文档注释 Window --&gt;Preferences --&gt;Java --&gt;Code Style --&gt;Code Templates 2.4.1. Comments Files修改成如下内容 /** * @Title: ${file_name} * @Package ${package_name} * @Description: ${todo}(用一句话描述该文件做什么) * @author Yangkai.Shen（此处换成你自己的名字，格式参考我的） * @date ${date} ${time} * @version V1.0 */ Types修改成如下内容 /** * @ClassName: ${type_name} * @Description: ${todo}(这里用一句话描述这个类的作用) * @author Yangkai.Shen（此处换成你自己的名字，格式参考我的） * @date ${date} ${time} * ${tags} */ Fields修改成如下内容 /** * @Fields ${field} : ${todo}(用一句话描述这个变量表示什么) */ Constructors修改成如下内容 /** * &lt;p&gt;Title: &lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * ${tags} */ Methods修改成如下内容 /** * @Title: ${enclosing_method} * @Description: ${todo}(这里用一句话描述这个方法的作用) * ${tags} 参数说明 * ${return_type} 返回类型 * @throws */ Overriding methods修改成如下内容 /* * Title: ${enclosing_method} * Description: * ${tags} * ${see_to_overridden} */ Delegate methods修改成如下内容 /** * ${tags} * ${see_to_target} */ Getters修改成如下内容 /** * @return the ${bare_field_name} */ Setters修改成如下内容 /** * @param ${param} the ${bare_field_name} to set */ 2.4.2. Codes中只修改New Java files New Java files修改成如下内容 /** * @Title: ${file_name} * @Package ${package_name} * @Description: ${todo}(用一句话描述该文件做什么) * @author Yangkai.Shen（此处换成你自己的名字，格式参考我的） * @date ${date} ${time} * @version V1.0 */ 3. 开发时的规范 每个方法前添加文档注释（快捷方式：选中需要添加的方法名，再按alt+shift+j） SVN提交代码时，必须注明提交代码时所作的修改 尽可能少的使用全局的静态变量，以免常驻内存 方法变量名转化成成员变量名称时，变量名称前加m以示区分（可以在eclipse中已经设置，自动化解决）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中svn不需要进行版本控制的部分]]></title>
    <url>%2F2016%2F04%2F03%2Fandroid-svn-attention.html</url>
    <content type="text"><![CDATA[前言SVN是Subversion的简称，是一个开放源代码的版本控制系统，说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。但是SVN对于Android项目来说并不是所有文件都需要进行版本控制的。 > 1. bin，gen 两个文件夹不用提交，因为这两个文件夹是自动生成的，如果提交可能会产生编译异常。 > 1. .settings也是自动生成，也不用提交。 > 1. .git文件夹也不需要提交，这是存放git的配置信息 > 1. .svn同.git一样，是存放svn的配置信息的，同样不需要提交 bin目录 gen目录 .svn目录 .settings目录 .git目录 屏蔽上传的方式：window–&gt;preferences–&gt;team–&gt;Ignored Resources–&gt;Add Pattern最后添加完成点击Apply 具体需要添加的部分见下图]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>eclipse</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯感想]]></title>
    <url>%2F2016%2F03%2F28%2Flanqiao-exam.html</url>
    <content type="text"><![CDATA[前言今年是我第一次参加蓝桥杯。3月20号。 大一、大二的时候，我就对蓝桥杯有所耳闻，今年如愿以偿的报名了。曾经憧憬着可以在蓝桥杯轻松获得二等奖，兴许运气来了，一等也是有机会的。However，今晚（3月28号）成绩出来了，三等奖，GG了。大学从未有过的信心摧残。好了，炮灰就是炮灰，我也不会一直自怨自艾，我是个有态度的炮灰，总结一下失败的原因吧！ 1. 总结 自信心爆棚（自负） 比赛前一个月，室友和我说，蓝桥杯还有一个月了，不做做模拟？当时我正在做一个Android项目，再加上一直对自己实力的自信，就没有在意；比赛前2周，室友说紧张不，我说小case。。终于我成功的裸考了（在进考场之前未做甚至未看一题模拟题) 学艺不精(对简单的算法不够熟练，对复杂的算法没有深究) 想到再补（不是想不到，而是实在太多了） 2. 展望 蓝桥杯，如果大四还可以参战的话，明年我还想再战，那时我必将全力以赴，毕竟大学不想留有遗憾。大学剩下的一年，我会尽自己最大的努力提升自己，以最好的姿态迎接毕业。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 在eclipse中把局部变量变成成员变量前自动加m]]></title>
    <url>%2F2016%2F03%2F27%2Feclipse-tips-variable.html</url>
    <content type="text"><![CDATA[前言在开发过程中,开发规范很重要,这样有利于后期维护,而且如果离职后,新同事接收你项目时也方便阅读代码,比如我们命名一个成员变量,一般在都是m子母开头。 比如我们在一个方法中写一个变量,后来发现在其他地方也要用到此变量,这时我们就需要把这变量做成成员变量,我们只要按下ctrl+1,就会提示是否需要变成成员变量,如果要它自动在变量前加m，其实这也是可以配置的,如图:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volley开源框架的初体验]]></title>
    <url>%2F2016%2F03%2F25%2Ffirst-use-volley-demo.html</url>
    <content type="text"><![CDATA[前言Http网络数据交互请求是极其重要并且使用很频繁的一个模块，也是最基本的网络编程所需要学习的。网络请求方式的效率和性能直接影响到APP的整体用户体验流畅性，所以学习并掌握一款好的Http请求框架对我们的网络开发非常重要。Http请求在移动网络编程中主要是Get和Post请求接口数据的使用。所以，在学习好基础的Http请求知识后，为了提升开发效率，选择学习使用一款好的Http网络请求框架变得非常的重要。 > 什么是Volley？汉语译过来就是：齐射; 迸发的意思。可以看出来，Volley特别适合数据量不大但是通信频繁的场景。 > Volley是Google I/O 2013上Google官方发布的一款Android平台上的网络通信库。 > 以前的网络请求，要考虑开启线程、内存泄漏、性能等等复杂的问题。但是Volley框架已经帮我们把这些问题处理好了，对外提供了相应的完善的请求API ，我们只需要按照要求使用即可 1. Volley框架的特点 能使网络通信更快，更简单，更健壮 Get、Post网络请求及网络图像的高效率异步处理请求 可以对网络请求进行排序优先级管理 网络请求的缓存 多级别取消请求 和Activity生命周期的联动（Activity结束时同时取消所有网络请求） 使用Volley可以简化一些网络通信的开发，当然Volley不适合大数据（largepayloads）和流媒体的网络请求。例如上百兆的文件、视频下载。 Volley开源，可以进行定制修改也可以直接使用Jar包的形式。 2. Volley的用法 Volley的Get和Post请求方式的使用 Volley的网络请求队列建立和取消队列请求 Volley的Get和Post请求方式的使用 Get和Post用于与服务器间请求和发送数据。 建立请求首先建立队列，将请求添加到请求队列里。 然后进行相应的Get和Post请求，请求结果在回调里获取解析。 Volley的网络请求队列建立和取消队列请求 Volley有自己的请求队列管理机制，可以控制每个请求的建立与取消。非常方便和安全。 这样也就可以做到随时控制某个请求在什么时候结束，Activity生命周期关联，防止无谓的请求。 3. Volley的简单测试demo 1.新建一个MyApplication类，继承自Application ，用于返回一个全局的Volley网络请求队列 1234567891011121314151617181920212223242526272829303132333435package com.xkcoding.volley;import android.app.Application;import com.android.volley.RequestQueue;import com.android.volley.toolbox.Volley;/** * @ClassName: MyApplication * @Description: 用于生成一个全局的请求队列 * @author Yangkai.Shen * @date 2016-3-26 上午1:09:10 * */public class MyApplication extends Application &#123; public static RequestQueue queue; @Override public void onCreate() &#123; super.onCreate(); queue = Volley.newRequestQueue(getApplicationContext()); &#125; /** * @Title: getRequestQueue * @Description: 获取一个全局的请求队列 * @param @return 参数说明 * @return RequestQueue 返回类型 * @throws */ public static RequestQueue getRequestQueue() &#123; return queue; &#125;&#125; 2.在MainActivity中编写测试GET与POST请求的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.xkcoding.volley;import java.util.HashMap;import java.util.Map;import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.Menu;import android.widget.Toast;import com.android.volley.Request.Method;import com.android.volley.AuthFailureError;import com.android.volley.Response;import com.android.volley.Response.Listener;import com.android.volley.VolleyError;import com.android.volley.toolbox.StringRequest;/** * @ClassName: MainActivity * @Description: 1. Volley的Get和Post请求方式的使用 2. Volley的网络请求队列建立和取消队列请求 * @author Yangkai.Shen * @date 2016-3-26 上午1:08:27 * */public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); volley_Get(); volley_Post(); &#125; /** * @Title: volley_Get * @Description: 测试GET方法 * @param 参数说明 * @return void 返回类型 * @throws */ private void volley_Get() &#123; //测试url为聚合数据的手机归属地查询 String url = "http://apis.juhe.cn/mobile/get?phone=13429667914&amp;key=ebe4429a46cb136bc7fcee57806fe952"; StringRequest request = new StringRequest(Method.GET, url, new Listener&lt;String&gt;() &#123; // 成功时回调 @Override public void onResponse(String arg0) &#123; Log.i("volley_Get", arg0); Toast.makeText(getApplicationContext(), arg0, Toast.LENGTH_SHORT).show(); &#125; &#125;, new Response.ErrorListener() &#123; // 失败时回调 @Override public void onErrorResponse(VolleyError arg0) &#123; Toast.makeText(getApplicationContext(), "网络请求失败", Toast.LENGTH_SHORT).show(); &#125; &#125;); // 加标签，便于在Activity销毁时，断开网络请求 request.setTag("testGet"); // 将请求放入请求队列 MyApplication.getRequestQueue().add(request); &#125; private void volley_Post() &#123; //测试url为聚合数据的手机归属地查询 String url = "http://apis.juhe.cn/mobile/get?"; StringRequest request = new StringRequest(Method.POST, url, new Listener&lt;String&gt;() &#123; // 成功时回调 @Override public void onResponse(String arg0) &#123; Log.i("volley_Post", arg0); Toast.makeText(getApplicationContext(), arg0, Toast.LENGTH_SHORT).show(); &#125; &#125;, new Response.ErrorListener() &#123; // 失败时回调 @Override public void onErrorResponse(VolleyError arg0) &#123; Toast.makeText(getApplicationContext(), "网络请求失败", Toast.LENGTH_SHORT).show(); &#125; &#125;) &#123; // POST请求所附带的请求参数 @Override protected Map&lt;String, String&gt; getParams() throws AuthFailureError &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("phone", "13429667914"); map.put("key", "ebe4429a46cb136bc7fcee57806fe952"); return map; &#125; &#125;; // 加标签，便于在Activity销毁时，断开网络请求 request.setTag("testPost"); // 将请求放入请求队列 MyApplication.getRequestQueue().add(request); &#125; @Override protected void onStop() &#123; // Activity销毁时取消请求队列列的所有请求，通过Tags找到所有请求 MyApplication.getRequestQueue().cancelAll("testGet"); MyApplication.getRequestQueue().cancelAll("testPost"); super.onStop(); &#125;&#125; 3.在清单文件AndroidManifest.xml中注册刚刚的MyApplication并添加网络权限 1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 4.Ctrl+F11 成功在LogCat中打印出号码信息]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开源项目分类汇总]]></title>
    <url>%2F2016%2F03%2F25%2Fandroid-open-project.html</url>
    <content type="text"><![CDATA[目前包括： Android 开源项目第一篇——个性化控件(View)篇 包括：ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style、其他 Android 开源项目第二篇——工具库篇 包括：依赖注入、图片缓存、网络请求、数据库 ORM 工具包、Android 公共库、高版本向低版本兼容库、多媒体、事件总线、传感器、安全、插件化、文件、其他 Android 开源项目第三篇——优秀项目篇 比较有意思的完整的 Android 项目 Android 开源项目第四篇——开发及测试工具篇 包括：开发效率工具、开发自测相关、测试工具、开发及编译环境、其他 Android 开源项目第五篇——优秀个人和团体篇 乐于分享并且有一些很不错的开源项目的个人和组织，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛 提示 以下链接网址若存在不能访问，请自行尝试翻墙，推荐使用GreenVPN 第一部分 个性化控件(View) 主要介绍那些不错个性化的 View，包括 ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style 等等。 一、ListView android-pulltorefresh 一个强大的拉动刷新开源项目，支持各种控件下拉刷新，ListView、ViewPager、WebView、ExpandableListView、GridView、ScrollView、Horizontal ScrollView、Fragment 上下左右拉动刷新，比下面 johannilsson 那个只支持 ListView 的强大的多。并且它实现的下拉刷新 ListView 在 item 不足一屏情况下也不会显示刷新提示，体验更好。 项目地址：https://github.com/chrisbanes/Android-PullToRefresh Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/pull-to-refreshview-demo.apk?raw=true APP 示例：新浪微博各个页面 android-pulltorefresh-listview 下拉刷新 ListView，这个被很多人使用的项目实际有不少 bug，推荐使用 android-Ultra-Pull-to-Refresh 项目地址：https://github.com/johannilsson/android-pulltorefresh Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/pull-to-refresh-listview-demo.apk?raw=true android-Ultra-Pull-to-Refresh 下拉刷新，第一个项目已经停止维护了，并且使用起来相对复杂，定制性也差。这个是替代和改良方案。这个继承于 ViewGroup 可以包含任何 View。功能甚至比 SwipeRefreshLayout 强大。使用起来非常简单。良好的设计，如果你想定制自己的 UI 样式，非常简单，就像给 ListView 加一个 Header View 那么简单。支持 API LEVEL &gt;= 8 项目地址：https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh 原理剖析文档：[android-Ultra-Pull-to-Refresh](http://a.codekk.com/detail/Android/Grumoon/android-Ultra-Pull-To-Refresh 源码解析) Demo 地址：https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh/blob/master/ptr-demo/target/ultra-ptr-demo.apk?raw=true Android-PullToRefreshRecyclerView 支持下拉刷新的RecyclerView，同时支持滑动到底部自动加载数据、给RecyclerView添加Header。并且不更改原有RecyclerView的逻辑。 项目地址：https://github.com/HomHomLin/Android-PullToRefreshRecyclerView。 Demo地址：https://github.com/HomHomLin/Android-PullToRefreshRecyclerView/blob/master/sample.apk DragSortListView 拖动排序的 ListView，同时支持 ListView 滑动 item 删除，各个 Item 高度不一、单选、复选、CursorAdapter 做为适配器、拖动背景变化等 项目地址：https://github.com/bauerca/drag-sort-listview Demo 地址：https://play.google.com/store/apps/details?id=com.mobeta.android.demodslv APP 示例：Wordpress Android SwipeListView 支持定义 ListView 左右滑动事件，支持左右滑动位移，支持定义动画时间 项目地址：https://github.com/47deg/android-swipelistview Demo 地址：https://play.google.com/store/apps/details?id=com.fortysevendeg.android.swipelistview APP 示例：微信 SlideAndDragListView 支持ListView的Item的拖动排序、左右滑动事件，可自定义左右滑动显示文字、图标、位移，同时支持onItemClick、onItemLongClick等监听器，提供丰富的回调接口。 项目地址：https://github.com/yydcdut/SlideAndDragListView Demo 地址：https://github.com/yydcdut/SlideAndDragListView/blob/master/apk/sdlv.apk?raw=true APP 示例：Android 手机QQ 5.0 Android-SwipeToDismiss 滑动 Item 消失 ListView，支持 3.0 以下版本见：https://github.com/JakeWharton/SwipeToDismissNOA 项目地址：https://github.com/romannurik/Android-SwipeToDismiss Demo 地址：https://github.com/JakeWharton/SwipeToDismissNOA/SwipeToDismissNOA.apk/qr_code RecyclerViewSwipeDismiss 轻量级支持 support-v7 中的 RecyclerView 的滑动删除(Swipe to dismiss)行为，不需要修改源代码，只要简单的绑定onTouchListener 项目地址：https://github.com/CodeFalling/RecyclerViewSwipeDismiss PinnedHeaderExpandableListView 首先它是一个 ExpandableListView，但是它的头部可以固定，其次，在它的上面还有一个头部可以来回伸缩 项目地址：https://github.com/singwhatiwanna/PinnedHeaderExpandableListView APP 示例：百度手机卫士垃圾清理界面 StickyListHeaders GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ExpandListView，支持快速滑动，支持 Android2.3 及以上 项目地址：https://github.com/emilsjolander/StickyListHeaders APP 示例：Android 4.0 联系人 pinned-section-listview GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ExpandListView 项目地址：https://github.com/beworker/pinned-section-listview PinnedHeaderListView GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ExpandListView 项目地址：https://github.com/JimiSmith/PinnedHeaderListView QuickReturn ListView/ScrollView 的 header 或 footer，当向下滚动时消失，向上滚动时出现 项目地址：https://github.com/lawloretienne/QuickReturn Demo 地址：https://play.google.com/store/apps/details?id=com.etiennelawlor.quickreturn QuickReturnHeader ListView/ScrollView 的 header 或 footer，当向下滚动时消失，向上滚动时出现 项目地址：https://github.com/ManuelPeinado/QuickReturnHeader Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/quick-return-header-demo.apk?raw=true APP 示例：google plus IndexableListView ListView 右侧会显示 item 首字母快捷索引，点击可快速滑动到某个 item 项目地址：https://github.com/woozzu/IndexableListView Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/indexable-listview.apk?raw=true APP 示例：微信通讯录、小米联系人 CustomFastScrollView ListView 快速滑动，同时屏幕中间 PopupWindows 显示滑动到的 item 内容或首字母 项目地址：https://github.com/nolanlawson/CustomFastScrollViewDemo Android-ScrollBarPanel ListView 滑动时固定的 Panel 指示显示在 scrollbar 旁边 项目地址：https://github.com/rno/Android-ScrollBarPanel SlideExpandableListView 用户点击 listView item 滑出固定区域，其他 item 的区域收缩 项目地址：https://github.com/tjerkw/Android-SlideExpandableListView Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/slide-expandable-listView-demo.apk?raw=true JazzyListView ListView 及 GridView item 以特殊动画效果进入屏幕，效果包括 grow、cards、curl、wave、flip、fly 等等 项目地址：https://github.com/twotoasters/JazzyListView Demo 地址：https://play.google.com/store/apps/details?id=com.twotoasters.jazzylistview.sample 在线演示：http://lab.hakim.se/scroll-effects/ ListViewAnimations 带 Item 显示动画的 ListView，动画包括底部飞入、其他方向斜飞入、下层飞入、渐变消失、滑动删除等 项目地址：https://github.com/nhaarman/ListViewAnimations Demo 地址：https://play.google.com/store/apps/details?id=com.haarman.listviewanimations APP 示例：Google plus、Google Now 卡片式进入、小米系统中应用商店、联系人、游戏中心、音乐、文件管理器的 ListView、Ultimate、Light Flow Lite、TreinVerkeer、Running Coach、Pearl Jam Lyrics、Calorie Chart、Car Hire、Super BART、DK FlashCards、Counter Plus、Voorlees Verhaaltjes 2.0 DevsmartLib-Android 横向 ListView 项目地址：https://github.com/dinocore1/DevsmartLib-Android Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/horizontal-listview-demo.apk?raw=true TwoWayView 横向 ListView 的效果，继承自 AdapterView 项目地址：https://github.com/lucasr/twoway-view HorizontalVariableListView 支持 Item 宽度不一致的 ListView 项目地址：https://github.com/sephiroth74/HorizontalVariableListView LinearListView 用 LinearLayout 实现的 ListView，可解决多个 ListView 并存等问题。目前自己也有需要，等亲自尝试过后会再具体介绍 项目地址：https://github.com/frankiesardo/LinearListView MultiChoiceAdapter 支持多选的 ListView Adapter 项目地址：https://github.com/ManuelPeinado/MultiChoiceAdapter Demo 地址：https://play.google.com/store/apps/details?id=com.manuelpeinado.multichoiceadapter.demo EnhancedListView 支持横向滑动删除列表项以及撤销删除的 ListView，该项目的前身是SwipeToDismissUndoList 项目地址：https://github.com/timroes/EnhancedListView Demo 地址：https://play.google.com/store/apps/details?id=de.timroes.android.listviewdemo&amp;rdid=de.timroes.android.listviewdemo ListBuddies 自动滚动的双列 ListView ，两个 ListView 滚动速度不一致，有视差效果 项目地址：https://github.com/jpardogo/ListBuddies Demo 地址：https://play.google.com/store/apps/details?id=com.jpardogo.android.listbuddies SwipeMenuListView 针对 ListView item 的侧滑菜单 项目地址：https://github.com/baoyongzhang/SwipeMenuListView APP 示例：手机 QQV5.0 PagingListView 分页加载的 ListView。当滑动到 ListView 底部最后一个元素时，显示一个进度行，然后加载下一页数据，并显示。 项目地址：https://github.com/nicolasjafelle/PagingListView PullZoomView 支持下拉时 HeaderView 缩放的 ListView、ScrollView 项目地址：https://github.com/Frank-Zhu/PullZoomView PullToZoomInListView 滑动 ListView 时使其 HeaderView 跟随滑动缩放 项目地址：https://github.com/matrixxun/PullToZoomInListView CalendarListview 实现每个月一行日历效果的 ListView 项目地址：https://github.com/traex/CalendarListview 原理剖析文档：CalendarListview sticky-headers-recyclerview GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ListView，采用 support-v7 中的 RecyclerView 实现 项目地址：https://github.com/timehop/sticky-headers-recyclerview PullSeparateListView 到达顶部或底部继续拉动时，实现 Item 间的相互分离，两种模式：(1) 全部分离的模式，即屏幕内所有 Item 都会分离 (2)部分分离模式，以点击位置为分界点，部分 item 分离 项目地址：https://github.com/chiemy/PullSeparateListView ExpandableLayout Header 和 Content Item 都可以展开的 ExpandableListview 项目地址：https://github.com/traex/ExpandableLayout PagedHeadListView 支持 paginated header 以及 material page indicator 的 ListView. 项目地址：https://github.com/JorgeCastilloPrz/PagedHeadListView CustomSwipeListView 支持左滑弹出自定义菜单，右滑删除且允许撤销，同时可以自定义滑动动画时间和滑动触发事件的时机等。 项目地址：https://github.com/xyczero/Android-CustomSwipeListView Demo 地址：Download here Pull-to-Refresh.Rentals-Android 提供一个简单可以自定义的下拉刷新实现，Yalantis 出品。 项目地址：https://github.com/Yalantis/Pull-to-Refresh.Rentals-Android ScrollerCalendar 实现每行显示一年的 12 个月份的 RecyclerView 年历 项目地址：https://github.com/guanchao/ScrollerCalendar ExtractWordView 一个可以提取单词的 ListView,支持&quot;放大镜&quot;效果。 项目地址：https://github.com/jcodeing/ExtractWordView Demo 地址：Download here FlyRefresh 支持 ListView, GridView, RecyclerView, ScrollView 的下拉刷新 项目地址：https://github.com/race604/FlyRefresh MVCHelper 实现下拉刷新，滚动底部自动加载更多，分页加载，自动切换显示网络失败布局，暂无数据布局，支持任意 view，真正的 MVC 架构 支持切换主流下拉刷新框架 Android-PullToRefresh-Library,android-Ultra-Pull-To-Refresh-library，SwipeRefreshLayout 项目地址：https://github.com/LuckyJayce/MVCHelper Demo 地址：https://github.com/LuckyJayce/MVCHelper/blob/master/raw/MVCHelper_Demo.apk?raw=true RecyclerViewSwipeDismiss 支持滑动 Item 操作、点击展开、拖动排序、展开后拖动排序等特性的 RecyclerView 项目地址：https://play.google.com/store/apps/details?id=com.h6ah4i.android.example.advrecyclerview 视频：http://www.youtube.com/watch?feature=player_embedded&amp;v=S7cSwMArjUQ WaterDropListView 模仿 iOS 下拉刷新“水滴”效果，支持下拉刷新和上拉加载 项目地址：https://github.com/THEONE10211024/WaterDropListView PopupListView 實現ListItem 點擊後置頂並可顯示客製化添加的item的內部View 的ListView 项目地址：https://github.com/s8871404/PopupListView Demo 地址：https://play.google.com/store/apps/details?id=com.baobomb.popuplistview_sample CircleRefreshLayout 一个包含有趣的动画的自定义下拉刷新布局 项目地址：https://github.com/tuesda/CircleRefreshLayout EasyRecyclerView 一款简单易用的EasyRecyclerView 1.提供EasyRecyclerView，不需要写太多RecyclerView的配置代码 2.提供好一个可以适配单布局和多布局的RecyclerViewAdapter 3.提供了分割线的实现类，只需要传入一个DrawableId 项目地址：https://github.com/CaMnter/EasyRecyclerView CanRefresh 可适配所有视图的下拉刷新上拉加载，并支持各种风格 项目地址：https://github.com/canyinghao/CanRefresh 二、ActionBar ActionBarSherlock 为 Android 所有版本提供统一的 ActionBar，解决 4.0 以下 ActionBar 的适配问题 项目地址：https://github.com/JakeWharton/ActionBarSherlock Demo 地址：https://play.google.com/store/apps/details?id=com.actionbarsherlock.sample.demos 标签：兼容库, ActionBar ActionBar-PullToRefresh 下拉刷新，ActionBar 出现加载中提示 项目地址：https://github.com/chrisbanes/ActionBar-PullToRefresh Demo 地址：https://play.google.com/store/apps/details?id=uk.co.senab.actionbarpulltorefresh.samples.stock APP 示例：Gmail，Google Plus，知乎等 FadingActionBar ListView 向下滚动逐渐显现的 ActionBar 项目地址：https://github.com/ManuelPeinado/FadingActionBar Demo 地址：https://play.google.com/store/apps/details?id=com.manuelpeinado.fadingactionbar.demo APP 示例：google music，知乎 NotBoringActionBar google music 下拉收缩的 ActionBar 项目地址：https://github.com/flavienlaurent/NotBoringActionBar Demo 地址：http://flavienlaurent.com/blog/2013/11/20/making-your-action-bar-not-boring/ APP 示例：Google 音乐 RefreshActionItem 带进度显示和刷新按钮的 ActionBar 项目地址：https://github.com/ManuelPeinado/RefreshActionItem Demo 地址：https://play.google.com/store/apps/details?id=com.manuelpeinado.refreshactionitem.demo APP 示例：The New York Times，DevAppsDirect GlassActionBar 类似玻璃的有一定透明度的 ActionBar 项目地址：https://github.com/ManuelPeinado/GlassActionBar Demo 地址：https://play.google.com/store/apps/details?id=com.manuelpeinado.glassactionbardemo APP 示例：google music 三、Menu MenuDrawer 滑出式菜单，通过拖动屏幕边缘滑出菜单，支持屏幕上下左右划出，支持当前 View 处于上下层，支持 Windows 边缘、ListView 边缘、ViewPager 变化划出菜单等。 项目地址：https://github.com/SimonVT/android-menudrawer Demo 地址：http://simonvt.github.io/android-menudrawer/ APP 示例：Gmail、Google Music 等大部分 google app SlidingMenu 滑出式菜单，通过拖动屏幕边缘滑出菜单，支持屏幕左右划出，支持菜单 zoom、scale、slide up 三种动画样式出现。与 MenuDrawer 相比而言，SlidingMenu 支持菜单动画样式出现，MenuDrawer 支持菜单 view 处于内容的上下层 项目地址：https://github.com/jfeinstein10/SlidingMenu 原理剖析文档：[SlidingMenu](http://a.codekk.com/detail/Android/huxian99/SlidingMenu 源码解析) Demo 地址：https://play.google.com/store/apps/details?id=com.slidingmenu.example APP 示例：Foursquare, LinkedIn, Zappos, Rdio, Evernote Food, Plume, VLC for Android, ESPN ScoreCenter, MLS MatchDay, 9GAG, Wunderlist 2, The Verge, MTG Familiar, Mantano Reader, Falcon Pro (BETA), MW3 Barracks ArcMenu 支持类似 Path 的左下角动画旋转菜单及横向划出菜单、圆心弹出菜单 项目地址：https://github.com/daCapricorn/ArcMenu https://dl.dropboxusercontent.com/u/11369687/preview1.png https://dl.dropboxusercontent.com/u/11369687/raymenu.png APP 示例：Path android-satellite-menu 类似 Path 的左下角动画旋转菜单 项目地址：https://github.com/siyamed/android-satellite-menu Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/satellite-menu-demo.apk?raw=true APP 示例：Path radial-menu-widget 圆形菜单，支持二级菜单 项目地址：https://code.google.com/p/radial-menu-widget/ Android Wheel Menu 圆形旋转选取菜单 项目地址：https://github.com/anupcowkur/Android-Wheel-Menu FoldingNavigationDrawer 滑动并以折叠方式打开菜单 项目地址：https://github.com/tibi1712/FoldingNavigationDrawer-Android Demo 地址：https://play.google.com/store/apps/details?id=com.ptr.folding.sample AndroidResideMenu 仿 Dribbble 的边栏菜单 项目地址：https://github.com/SpecialCyCi/AndroidResideMenu CircularFloatingActionMenu 一个可定制的圆形的浮动菜单控件，类似于 Path 的圆形菜单。这个控件的可定制性更强，可以很容易的定制菜单出现消失时的动画，起始角度和半径。 项目地址：https://github.com/oguzbilgener/CircularFloatingActionMenu 原理剖析文档：[CircularFloatingActionMenu](http://a.codekk.com/detail/Android/cpacm/CircularFloatingActionMenu 源码解析) Demo 地址：https://github.com/oguzbilgener/CircularFloatingActionMenu/tree/master/samples NavigationDrawerSI Navigation Drawer 的一个简单实现，滑动并以折叠方式打开菜单 项目地址：https://github.com/mmBs/NavigationDrawerSI Demo 地址：https://play.google.com/store/apps/details?id=mmbialas.pl.navigationdrawersi APP 示例：https://play.google.com/store/apps/details?id=mmbialas.pl.navigationdrawersi DragLayout 使用 support.v4 包下的 ViewDragHelper 实现 QQ5.0 侧滑 项目地址：https://github.com/BlueMor/DragLayout LDrawer Material Design 形式的展开折叠 Icon 项目地址：https://github.com/ikimuhendis/LDrawer Floating Action Button 悬浮的圆形菜单栏，支持组建滚动时自动隐藏及其他设置 项目地址：https://github.com/shamanland/floating-action-button Side-Menu.Android 分类侧滑菜单，Yalantis 出品。 项目地址：https://github.com/Yalantis/Side-Menu.Android 原理剖析文档：[Side-Menu.Android](http://a.codekk.com/detail/Android/cpacm/Side Menu.Android 源码解析) Context-Menu.Android 可以方便快速集成漂亮带有动画效果的上下文菜单，Yalantis出品。 项目地址：https://github.com/Yalantis/Context-Menu.Android Droppy 支持多种样式的下拉菜单 项目地址：https://github.com/shehabic/Droppy MaterialDrawer Material Design 风格的导航抽屉，提供简便且强大的定制功能 项目地址：https://github.com/mikepenz/MaterialDrawer Demo 地址：https://play.google.com/store/apps/details？id=com.mikepenz.materialdrawer.app SlideBottomPanel 底部划出菜单，滑动时背景图透明度渐变，支持嵌套 LiewView 或 ScrollView 项目地址：https://github.com/kingideayou/SlideBottomPanel Demo 地址：SlideBottomPanelDemo 下载 FlowingDrawer 带手势流动效果侧滑菜单 项目地址：https://github.com/mxn21/FlowingDrawer 四、ViewPager 、Gallery AdvancedPagerSlidingTabStrip 一个完美兼容ViewPager的导航栏组件；可以自定义TabView；能动态加载Tab上的Icon图片； 能显示Tab的消息数量和提示小圆点。 项目地址：https://github.com/HomHomLin/AdvancedPagerSlidingTabStrip ConvenientBanner 通用的广告栏控件，让你轻松实现广告头效果。支持无限循环，可以设置自动翻页和时间(而且非常智能，手指触碰则暂停翻页，离开自动开始翻页。你也可以设置在界面onPause的时候不进行自动翻页，onResume之后继续自动翻页)，并且提供多种翻页特效。 对比其他广告栏控件，大多都需要对源码进行改动才能加载网络图片，或者帮你集成不是你所需要的图片缓存库。而这个库能让有代码洁癖的你欢喜，不需要对库源码进行修改你就可以使用任何你喜欢的网络图片库进行配合。 项目地址：https://github.com/saiwu-bigkoo/Android-ConvenientBanner Android-ViewPagerIndicator 配合 ViewPager 使用的 Indicator，支持各种位置和样式 项目地址：https://github.com/JakeWharton/Android-ViewPagerIndicator Demo 地址：https://play.google.com/store/apps/details?id=com.viewpagerindicator.sample APP 示例：太多了。。 JazzyViewPager 支持 Fragment 切换动画的 ViewPager，动画包括转盘、淡入淡出、翻页、层叠、旋转、方块、翻转、放大缩小等，效果类似桌面左右切换的各种效果，不过桌面并非用 ViewPager 实现而已 项目地址：https://github.com/jfeinstein10/JazzyViewPager Demo 地址：https://github.com/jfeinstein10/JazzyViewPager/blob/master/JazzyViewPager.apk?raw=true JellyViewPager 特殊切换动画的 ViewPager 项目地址：https://github.com/chiemy/JellyViewPager Android-DirectionalViewPager 支持横向和纵向(垂直)的 ViewPager 项目地址：https://github.com/JakeWharton/Android-DirectionalViewPager Demo 地址：https://market.android.com/details?id=com.directionalviewpager.sample FancyCoverFlow 支持 Item 切换动画效果的类似 Gallery View 项目地址：https://github.com/davidschreiber/FancyCoverFlow Demo 地址：https://play.google.com/store/apps/details?id=at.technikum.mti.fancycoverflow.samples AndroidTouchGallery 支持双击或双指缩放的 Gallery(用 ViewPager 实现)，相比下面的 PhotoView，在被放大后依然能滑到下一个 item，并且支持直接从 url 和文件中获取图片， 项目地址：https://github.com/Dreddik/AndroidTouchGallery Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/touch-gallery-demo.apk?raw=true APP 示例：类似微信中查看聊天记录图片时可双击放大，并且放大情况下能正常左右滑动到前后图片 Android Auto Scroll ViewPager Android 自动滚动 轮播循环的 ViewPager 项目地址：https://github.com/Trinea/android-auto-scroll-view-pager Demo 地址：https://play.google.com/store/apps/details?id=cn.trinea.android.demo 文档介绍：http://www.trinea.cn/android/auto-scroll-view-pager/ Android PagerSlidingTabStrip 配合 ViewPager 使用的 Indicator，支持 ViewPager Scroll 时 Indicator 联动 项目地址：https://github.com/astuetz/PagerSlidingTabStrip 原理剖析文档：[Android PagerSlidingTabStrip](http://a.codekk.com/detail/Android/ayyb1988/PagerSlidingTabStrip 源码解析) Demo 地址：https://play.google.com/store/apps/details?id=com.astuetz.viewpager.extensions.sample ViewPager3D ViewPager3D 效果 项目地址：https://github.com/inovex/ViewPager3D AnimaTabsview 仿网易云音乐标签切换的动画,带透明小三角 项目地址：https://github.com/wuyexiong/transparent-over-animtabsview 在线演示：http://v.youku.com/v_show/id_XNzA4MjY5NjA0.html LoopingViewPager 无限循环的 ViewPager 项目地址：https://github.com/imbryk/LoopingViewPager android_page_curl 翻书卷曲效果 项目地址：https://github.com/harism/android_page_curl 在线演示：https://www.youtube.com/watch?v=iwu7P5PCpsw APP 示例：iReader ViewPagerIndicator 简化并实现 android 的 TabHost 效果，顶部滑动 tab，引导页，支持自定义 tab 样式,自定义滑动块样式和位置,自定义切换 tab 的过渡动画,子界面的预加载和界面缓存,设置界面是否可滑动 项目地址：https://github.com/LuckyJayce/ViewPagerIndicator ScreenSlideIndicator 轻量级的圆形 Indicadtor，位置可以自由调整，不会对 ViewPager 产生任何影响。 项目地址：ScreenSlidePager SmartTabLayout 自定义的 Tab title strip，基于 Google Samples 中的 android-SlidingTabBasic 项目，滑动时 Indicator 可平滑过渡。 项目地址：https://github.com/ogaclejapan/SmartTabLayout Demo 地址：https://play.google.com/store/apps/details?id=com.ogaclejapan.smarttablayout.demo AndroidImageSlider Android 图片滑动 项目地址：https://github.com/daimajia/AndroidImageSlider App示例：https://github.com/daimajia/AndroidImageSlider/releases/download/v1.0.8/demo-1.0.8.apk RecyclerViewPager 完全继承自 RecyclerView，可以自定义触发翻页的距离，可自定义翻页速度，支持垂直方向的 ViewPager，支持 Fragment。 项目地址：RecyclerViewPager CircleIndicator 轻量级ViewPager指示器,支持三种不同的模式 项目地址：CircleIndicator EasySlidingTabs 一款简单、易用的滑动标签页 项目地址： https://github.com/CaMnter/EasySlidingTabs 五、GridView StaggeredGridView 允许非对齐行的 GridView，类似 Pinterest 的瀑布流，并且跟 ListView 一样自带 View 缓存，继承自 ViewGroup 项目地址：https://github.com/maurycyw/StaggeredGridView Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/staggered-gridview-demo.apk?raw=true APP 示例：Pinterest 等 AndroidStaggeredGrid 允许非对齐行的 GridView，类似 Pinterest 的瀑布流，继承自 AbsListView 项目地址：https://github.com/etsy/AndroidStaggeredGrid APP 示例：Pinterest 等 PinterestLikeAdapterView 允许非对齐行的 GridView，类似 Pinterest 的瀑布流，允许下拉刷新 项目地址：https://github.com/GDG-Korea/PinterestLikeAdapterView APP 示例：Pinterest 等 DraggableGridView Item 可拖动交换位置的 GridView，实际是自己继承 ViewGroup 实现，类似桌面的单屏效果，可屏幕自动上下滚动进行 Item 移动交换，多屏效果见下面 PagedDragDropGrid 项目地址：https://github.com/thquinn/DraggableGridView Demo 地址：https://github.com/thquinn/DraggableGridView/blob/master/bin/DraggableGridViewSample.apk?raw=true 也可以自定义item的宽高和每行的个数，并且修改交换逻辑，当移动到另一个item时就进行交换，删除滚动逻辑。 项目地址：DraggableGridView StickyGridHeaders GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 GridView 项目地址：https://github.com/TonicArtos/StickyGridHeaders PagedDragDropGrid Item 可拖动交换位置、拖动删除的自定义控件，实际是自己继承 ViewGroup 实现，类似桌面的多屏效果，可拖动到屏幕边缘，屏幕自动左右滚动进行 Item 移动交换，可拖动进行删除，单屏效果见上面 DraggableGridView 项目地址：https://github.com/mrKlar/PagedDragDropGrid 在线演示：http://youtu.be/FYTSRfthSuQ Android-DraggableGridViewPager Item 可拖动交换位置的 GridView，实际是自己继承 ViewGroup 实现，类似桌面的多屏效果，可屏幕自动左右滚动进行 Item 移动交换，单屏效果见上面 DraggableGridView 项目地址：https://github.com/zzhouj/Android-DraggableGridViewPager Demo 地址：https://github.com/Trinea/trinea-download/blob/master/draggable-grid-viewpager-demo.apk?raw=true TwoWayGridView 可横向滚动的 GridView 项目地址：https://github.com/jess-anders/two-way-gridview PagingGridView 分页加载的 GridView。当滑动到 GridView 底部最后一个行时，显示一个进度行，然后加载下一页数据，并显示。 项目地址：https://github.com/nicolasjafelle/PagingGridView AsymmetricGridView 一个支持跨行和跨列可变 Item 大小的 GridView 项目地址：https://github.com/felipecsl/AsymmetricGridView Demo 地址：https://play.google.com/store/apps/details?id=com.felipecsl.asymmetricgridview.app GridView with Header and Footer 和ListView一样带头部和底部的GridView，用法和ListView一样 项目地址：https://github.com/liaohuqiu/android-GridViewWithHeaderAndFooter 六、ImageView PhotoView 支持双击或双指缩放的 ImageView，在 ViewPager 等 Scrolling view 中正常使用，相比上面的 AndroidTouchGallery，不仅支持 ViewPager，同时支持单个 ImageView 项目地址：https://github.com/chrisbanes/PhotoView 原理剖析文档：[PhotoView](http://a.codekk.com/detail/Android/dkmeteor/PhotoView 源码解析) Demo 地址：https://play.google.com/store/apps/details?id=uk.co.senab.photoview.sample APP 示例：photup Fresco-ImageView Fresco-ImageView是一种Android平台的图像控件，底层是对Fresco的封装，可以异步加载网络图片、项目资源和本地图片，并且支持双指缩放、图片的基本处理以及Fresco的所有特性。 项目地址：https://github.com/HomHomLin/FrescoImageView。 android-gif-drawable 支持 gif 显示的 view，用 jni 实现的，编译生成 so 库后直接 xml 定义 view 即可，而且本身不依赖于其他开源项目所以相对下面的 ImageViewEx 简单的多 项目地址：https://github.com/koral--/android-gif-drawable ImageViewEx 支持 Gif 显示的 ImageView，依赖很多，编译过程很繁琐 项目地址：https://github.com/frapontillo/ImageViewEx Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/imageviewex-demo.apk?raw=true RoundedImageView 带圆角的 ImageView 项目地址：https://github.com/vinc3m1/RoundedImageView SelectableRoundedImageView ImageView 允许四个角的每一个有不同的半径值。也允许椭圆形、圆形的形状或者边 项目地址：https://github.com/pungrue26/SelectableRoundedImageView Demo 地址：https://play.google.com/store/apps/details?id=com.joooonho ColorArt 根据图片的均色设置背景色显示文字和图片，类似 itune11 中效果 项目地址：https://github.com/MichaelEvans/ColorArt Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/color-art-demo.apk?raw=true CircleImageView 圆形的 ImageView 项目地址：https://github.com/hdodenhof/CircleImageView ImageViewZoom 支持放大和平移的 ImageView 项目地址：https://github.com/sephiroth74/ImageViewZoom APP 示例：https://play.google.com/store/apps/details?id=com.aviary.android.feather KenBurnsView 实现 Ken Burns effect 效果，达到身临其境效果的 ImageView 项目地址：https://github.com/flavioarfaria/KenBurnsView CustomShapeImageView 各种形状的 ImageView, 相比上面的圆形 ImageView，多了更多形状 项目地址：https://github.com/MostafaGazar/CustomShapeImageView Shape Image View 可以自定义各种形状的 ImageView, 并且支持边框 项目地址：https://github.com/siyamed/android-shape-imageview TextDrawable 一个用于生成带有文本或者字母的图片的轻量级库。扩展自 Drawable，因此可用于现有/自定义/网络等 ImageView 类，并且包含一个流接口用于创建 drawables 以及一个定制的 ColorGenerator 项目地址：https://github.com/amulyakhare/TextDrawable android-smart-image-view 可从 URL 或 contact address book 加载图片的 ImageView，支持缓存 项目地址：https://github.com/loopj/android-smart-image-view PhotoView 支持双指/双击缩放的ImageView,支持从一个PhotoView缩放到另外一个PhotoView(点击图片放大预览),相对于其他PhototView有更加平滑的缩放,平移的动画,并且支持所有的ScaleType,可以作为普通的ImageView使用 项目地址：https://github.com/bm-x/PhotoView 七、ProgressBar SmoothProgressBar 水平进度条 项目地址：https://github.com/castorflex/SmoothProgressBar Demo 地址：https://play.google.com/store/apps/details?id=fr.castorflex.android.smoothprogressbar.sample MaterialProgessBar Material Design 的进度条，支持 Android 4.0 项目地址：https://github.com/DreaminginCodeZH/MaterialProgressBar Demo 地址：https://github.com/DreaminginCodeZH/MaterialProgressBar/blob/master/dist/sample.apk ProgressWheel 支持进度显示的圆形 ProgressBar 项目地址：https://github.com/Todd-Davies/ProgressWheel Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/progress-wheel-demo.apk?raw=true android-square-progressbar 在图片周围显示进度 项目地址：https://github.com/mrwonderman/android-square-progressbar Demo 地址：https://play.google.com/store/apps/details?id=net.yscs.android.square_progressbar_example APP 示例：square HoloCircularProgressBar Android4.1 时钟 App 样式 项目地址：https://github.com/passsy/android-HoloCircularProgressBar APP 示例：Android4.1 时钟 App ProgressButton 通过图钉的不同状态显示进度 项目地址：https://github.com/f2prateek/progressbutton 文档介绍：http://f2prateek.com/progressbutton/ GoogleProgressBar 类似 google 多个圆形卡片翻转的 progressBar 项目地址：https://github.com/jpardogo/GoogleProgressBar TH-ProgressButton 带圆形进度显示的按钮 项目地址：https://github.com/torryharris/TH-ProgressButton NumberProgressBar 带数字进度的进度条 项目地址：https://github.com/daimajia/NumberProgressBar CircularProgressDrawable 带圆形进度显示的进度条 项目地址：https://github.com/Sefford/CircularProgressDrawable Android-RoundCornerProgressBar Android 圆角 ProgressBar，可自定义圆角颜色和半径，包括带 Icon 和不带 Icon 两种类型。 项目地址：https://github.com/akexorcist/Android-RoundCornerProgressBar circular-progress-button 带进度显示的 Button 项目地址：https://github.com/dmytrodanylyk/circular-progress-button WaveView 一个波纹效果的 View，可用来做 ProgressBar 项目地址：https://github.com/john990/WaveView Demo 地址：https://raw.github.com/john990/WaveView/master/screenshot%26apk/demo.unaligned.apk MaterialLoadingProgressBar 抽取自 SwipeRefreshLayout 的 Material Design 进度指示器 项目地址：https://github.com/lsjwzh/MaterialLoadingProgressBar MetaballLoading A 2d metaball loading 项目地址：https://github.com/dodola/MetaballLoading SectorProgressView 一个圆形或环形的进度显示控件，用圆中扇形的角度大小来表示进度信息 项目地址：https://github.com/timqi/SectorProgressView Demo：apk download CircularFillableLoaders 一个可以用于闪屏或者其他地方加载的控件 项目地址：https://github.com/lopspower/CircularFillableLoaders Demo地址：(https://play.google.com/store/apps/details?id=com.mikhaellopez.circularfillableloaderssample) PinWheel 一个旋转的大风车Dialog 项目地址：https://github.com/codingWang/PinWheel ColorArcProgressBar 一个可定制的圆形进度条，通过xml参数配置可实现QQ健康中步数的弧形进度显示、仪盘表显示速度、最常见的下载进度条等功能。 项目地址：https://github.com/Shinelw/ColorArcProgressBar 八、TextView 包括 TextView 及所有继承自 TextView 控件，如 EditText、Button、RadioButton android-flowtextview 文字自动环绕其他 View 的 Layout 项目地址：https://github.com/deano2390/FlowTextView Android Form EditText 验证输入合法性的编辑框，支持输入、英文、ip、url 等多种正则验证 项目地址：https://github.com/vekexasia/android-edittext-validator Demo 地址：https://play.google.com/store/apps/details?id=com.andreabaccega.edittextformexample Emojicon 支持 emojis 的 TextView 和 EditText 项目地址：https://github.com/rockerhieu/emojicon 文档介绍：http://rockerhieu.com/emojicon/ android-circlebutton Android 圆形按钮，实际实现是继承自 ImageView 项目地址：https://github.com/markushi/android-circlebutton Demo 地址：https://github.com/markushi/android-circlebutton/blob/master/example/example.apk Segmented Radio Buttons for Android iOS’s segmented controls 的实现 项目地址：https://github.com/vinc3m1/android-segmentedradiobutton Demo 地址：https://github.com/thquinn/DraggableGridView/blob/master/bin/DraggableGridViewSample.apk?raw=true Chips EditText Library 支持国家名字联想从而选择显示该国国旗的 EditText，实际就是通过 SpannableStringBuilder 实现 项目地址：https://github.com/kpbird/chips-edittext-library Demo 地址：https://github.com/kpbird/chips-edittext-library/tree/master/ChipsEditTextDemo/bin AutoFitTextView 可固定边界内容字体大小自适应的 TextView 项目地址：https://github.com/grantland/android-autofittextview Shimmer for Android 文字发淡光的 TextView 项目地址：https://github.com/RomainPiel/Shimmer-android Titanic 可以显示水位上升下降(不知道该怎么描述 囧)的 TextView 项目地址：https://github.com/RomainPiel/Titanic android-iconify 提供带 Icon 的 TextView,Menu,Button 等 项目地址：https://github.com/JoanZapata/android-iconify Calligraphy 让我们在 android 开发中使用自定义字体变得更加简单 项目地址：https://github.com/chrisjenx/Calligraphy CreditsRoll 类似星球大战字幕效果的 TextView 项目地址：https://github.com/frakbot/CreditsRoll android-process-buton 带加载或提交进度的 Button 项目地址：https://github.com/dmytrodanylyk/android-process-buton FButton 扁平化的 Button 项目地址：https://github.com/hoang8f/android-flat-button Demo 地址：https://play.google.com/store/apps/details?id=info.hoang8f.fbutton.demo FloatingActionButton 一个类似 Android 版 Google+浮动功能按钮的控件，可以响应 ListView 的滚动事件。当列表向上滚动的时候会自动显示，向下滚动的时候自动隐藏。 项目地址：https://github.com/makovkastar/FloatingActionButton Demo 地址：https://github.com/makovkastar/FloatingActionButton/tree/master/ Android Saripaar Android 表单验证 项目地址：https://github.com/ragunathjawahar/android-saripaar/ JumpingBeans 文字像 Mexican beans 一样跳动 项目地址：https://github.com/frakbot/JumpingBeans Demo 地址：http://play.google.com/store/apps/details?id=net.frakbot.jumpingbeans.demo FancyButtons 一个不用图片就可以帮助我们创建出漂亮按钮的库。 项目地址：https://github.com/medyo/fancybuttons Demo 地址：https://github.com/medyo/fancybuttons/tree/master/samples Android-RobotoTextView 一个实现了所有 Roboto 字体的 TextView，包括新出的 Roboto Slab 字体。 项目地址：https://github.com/johnkil/Android-RobotoTextView Demo 地址：http://play.google.com/store/apps/details?id=com.devspark.robototextview Demo 项目：https://github.com/johnkil/Android-RobotoTextView/tree/master/robototextview-sample Android-WizardPager 一个表单向导库 项目地址：https://github.com/romannurik/android-wizardpager Demo 项目：https://github.com/str4d/android-wizardpager/tree/textfield RippleView 一个实现了 Android L 上才引入的点击按钮后出现水波纹效果的按钮 项目地址：https://github.com/siriscac/RippleView Demo 项目：https://github.com/siriscac/RippleView/tree/master/RippleViewExample RippleEffect 一个实现 Material Design Ripple 效果的库，支持 Android API 9+以上版本。 项目地址：https://github.com/traex/RippleEffect Demo 项目：https://github.com/traex/RippleEffect/tree/master/sample RippleCompat 使用易于移植的方式为UI控件实现波纹效应，可以适配控件原背景及Palette支持。api简单，可自定义效果，兼容至Android API 7+。 项目地址：https://github.com/desmond1121/RippleCompat Demo 项目：https://github.com/desmond1121/RippleCompat/tree/master/app Android Floating Label Widgets 包含一系列控件，这些控件特点是：有默认值，当值不为空时默认值浮动到上面变为提示 项目地址：https://github.com/marvinlabs/android-floatinglabel-widgets Demo 地址：https://play.google.com/store/apps/details?id=com.marvinlabs.widget.floatinglabel.demo 在线演示：http://www.youtube.com/watch?v=hpZD9gJcRg0&amp;feature=youtu.be MaterialEditText EditText 的 Material Design 实现。包含 Google Material Design Spec中的 UI 效果和一些新增特性。 项目地址：https://github.com/rengwuxian/MaterialEditText MaterialEditText 实现 Material Design 中 Ripple 效果线条背景的 EditText。直接替换原生 EditText 即可集成。 项目地址：https://github.com/DreamingInCodeZH/MaterialEditText MultiActionTextView 可以分别给 TextView 中的某几个字设置点击事件的 TextView 项目地址：https://github.com/ajaysahani/MultiActionTextView ToggleButton 状态切换的 Button，类似 iOS，用 View 实现 项目地址：https://github.com/zcweng/ToggleButton SwitchButton 状态切换的 Button，类似 iOS，拥有良好的用户界面 项目地址：https://github.com/kyleduo/SwitchButton SlideSwitch 状态切换的开关，可以设置为类似 IOS 的圆形，也可以设置为矩形，用 View 实现 项目地址：https://github.com/Leaking/SlideSwitch ExpandableTextView 可展开和收缩内容的 TextView。 项目地址：https://github.com/Manabu-GT/ExpandableTextView TagCloudView(支持 SingleLine 模式的标签云) 标签云效果，只需要一行代码即可设置为 SingleLine 模式，轻松实现知乎问题话题列表效果。SingleLine 模式时末尾文字及图片可自定义。 项目地址：https://github.com/kingideayou/TagCloudView 示例APK地址：https://github.com/kingideayou/TagCloudView/raw/master/apk/Demo.apk APP示例：知乎 BubbleTextView Android Bubble View 项目地址：https://github.com/dupengtao/BubbleTextView shadow-layout Android Shadow Layout 解决了CardView：1.不能画圆的阴影。2.设置阴影的位置。3.设置阴影颜色。 项目地址：https://github.com/dmytrodanylyk/shadow-layout 九、ScrollView Discrollview 支持滚动时 Item 淡入淡出，平移，缩放效果的 ScrollView 项目地址：https://github.com/flavienlaurent/discrollview Demo 地址：https://github.com/flavienlaurent/discrollview/raw/master/sample.apk PullScrollView 仿照新浪微博 Android 客户端个人中心的 ScrollView，下拉背景伸缩回弹效果。 项目地址：https://github.com/MarkMjw/PullScrollView ArcLayout 一个非常简单的弧布局库 项目地址：https://github.com/ogaclejapan/ArcLayout Demo 地址：https://play.google.com/store/apps/details?id=com.ogaclejapan.arclayout.demo ParallaxScrollView 支持视差滚动的 ScrollView ，背景图片的滚动速度小于 ScrollView 中子控件的滚动速度 项目地址：https://github.com/chrisjenx/ParallaxScrollView Demo 地址：http://cloud.github.com/downloads/chrisjenx/ParallaxScrollView/ParallaxScrollViewDemo-v1.0.5.apk AKParallax-Android 支持视差滚动的 ScrollView 项目地址：https://github.com/ideaismobile/AKParallax-Android Demo 地址：https://play.google.com/store/apps/details?id=com.appkraft.parallax_sample Android-ObservableScrollView 监听滚动视图滚动事件的库，帮助与 Toolbar 的交互动效处理与 Material Design 的实现 项目地址：https://github.com/ksoichiro/Android-ObservableScrollView Demo 地址：https://play.google.com/store/apps/details?id=com.github.ksoichiro.android.observablescrollview.samples2 OverScrollView 有弹性的 ScrollView，实现了当手指滑动到 ScrollView 的顶部、底部时，可以继续的向上、向下拉伸。当释放手指的时候，向上、下回弹 项目地址：https://github.com/EverythingMe/OverScrollView 十、TimeView 包括 TimePicker、DatePicker、CalendarView、Clock 等时间相关控件 android-times-square Android 日历时间部件，支持选取单个日期，多个日期，及日期区间段和对话框形式显示 项目地址：https://github.com/square/android-times-square Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/times-square-demo.apk?raw=true android-calendar-card 日历 项目地址：https://github.com/kenumir/android-calendar-card Demo 地址：https://play.google.com/store/apps/details?id=com.wt.calendarcardsample AndroidWheel Android Wheel 支持城市、多种日期时间、密码、图片 项目地址：https://code.google.com/p/android-wheel/ GoogleDateTimePickers 时间选择部件 项目地址：https://github.com/Mirkoddd/GoogleDateTimePickers 文档介绍：https://play.google.com/store/apps/details?id=com.mirko.sample&amp;hl=it DateTimePicker 日期选择部件(Google Agenda 的样式风格) 项目地址：https://github.com/flavienlaurent/datetimepicker Demo 地址：https://raw.github.com/biboune/datetimepicker/master/datetimepicker-sample.apk android-betterpickers 提供日期、数字、时间（数字方式和钟表方式）、重复周期（闹钟的周期重复）、HMS（时、分、秒）的选择，支持以 DialogFragment 的弹窗选择 项目地址：https://github.com/derekbrameyer/android-betterpickers Demo 地址：https://play.google.com/store/apps/details?id=com.doomonafireball.betterpickers.sample Android Week View 日期控件，支持周，天视图，支持自定义样式 项目地址：https://github.com/alamkanak/Android-Week-View PickerView 仿 iOS 的 PickerView 控件，有时间选择和选项选择并支持一二三级联动效果，TimePopupWindow 时间选择器，支持年月日时分，年月日，时分等格式；OptionsPopupWindow 选项选择器，支持一，二，三级选项选择，并且可以设置是否联动 项目地址：https://github.com/saiwu-bigkoo/Android-PickerView CountdownView Android 倒计时控件，使用Canvas绘制，支持多种样式 项目地址：https://github.com/iwgang/CountdownView 十一、TipView 包括 Toast、角标、UndoBar 等提示性控件 SVProgressHUD SVProgressHUD For Android 精仿iOS的提示库 SVProgressHUD，api也几乎一样。 项目地址：https://github.com/saiwu-bigkoo/Android-SVProgressHUD Crouton 丰富样式的 Toast，允许 alert、comfirm、info 样式及点击消失样式，允许设置 Toast 显示时间，允许自定义 View。 本文 32. SuperToasts 为其扩展版 项目地址：https://github.com/keyboardsurfer/Crouton Demo 地址：http://play.google.com/store/apps/details?id=de.keyboardsurfer.app.demo.crouton supertooltips 带动画效果的 Tips 显示 项目地址：https://github.com/nhaarman/supertooltips Demo 地址：https://play.google.com/store/apps/details?id=com.haarman.supertooltips Android ViewBadger 为其他 View 添加角标（消息圆点）等 项目地址：https://github.com/jgilfelt/android-viewbadger Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/android-viewbadger.apk?raw=true SuperToasts 更丰富样式的 toast，支持 Button、Progress、Horizontal Progress 样式、支持进入动画、支持撤销及其动画设置 项目地址：https://github.com/JohnPersano/SuperToasts Demo 地址：https://play.google.com/store/apps/details?id=com.supertoastsdemo UndoBar 屏幕底部显示取消或是确认的 PopupWindows 项目地址：https://github.com/soarcn/UndoBar UndoBar 屏幕底部显示取消或是确认某操作 项目地址：https://github.com/jenzz/Android-UndoBar Android-ActionItemBadge 可以在 ActionBar 的 MenuItem 上显示一个小角标 项目地址：https://github.com/mikepenz/Android-ActionItemBadge SnackBar Material Design 风格的 Toast，类似 Google inbox 中的提示 项目地址：https://github.com/MrEngineer13/SnackBar Demo 地址：https://play.google.com/store/apps/details?id=com.mrengineer13.snackbar.sample HeadsUp 在 2.3 上使用 android 5.0 的 HeadsUp 效果 项目地址：https://github.com/zzz40500/HeadsUp 十二、FlipView android-flip 类似 Flipboard 翻转动画的实现 项目地址：https://github.com/openaphid/android-flip Demo 地址：https://github.com/openaphid/android-flip/blob/master/FlipView/Demo/APK/Aphid-FlipView-Demo.apk?raw=true APP 示例：flipboard FlipImageView 支持 x、y、z 及动画选择的翻转动画的实现 项目地址：https://github.com/castorflex/FlipImageView Demo 地址：https://play.google.com/store/apps/details?id=fr.castorflex.android.flipimageview FoldableLayout Flip 翻转效果的 ListView，目前还不支持 ListView 缓存 项目地址：https://github.com/alexvasilkov/FoldableLayout Demo 地址：http://play.google.com/store/apps/details?id=com.alexvasilkov.foldablelayout.sample FlipViewPager.Draco Flip 翻转效果的 ViewPager 项目地址：https://github.com/Yalantis/FlipViewPager.Draco 十三、ColorPickView ColorPickerView 颜色选择器，支持 PopupWindows 或新的 Activity 中打开 项目地址：https://code.google.com/p/color-picker-view/ HoloColorPicker 颜色选择器 项目地址：https://github.com/LarsWerkman/HoloColorPicker Demo 地址：https://docs.google.com/file/d/0BwclyDTlLrdXRzVnTGJvTlRfU2s/edit ColorPickerPreference 颜色选择器 项目地址：https://github.com/attenzione/android-ColorPickerPreference ColorPicker 颜色选择器（Google Agenda 中的样式风格） 项目地址：https://github.com/flavienlaurent/colorpicker Demo 地址：https://raw.github.com/biboune/colorpicker/master/colorpicker-sample.apk 十四、GraphView MPAndroidChart 强大的图表绘制工具，支持折线图、面积图、散点图、时间图、柱状图、条图、饼图、气泡图、圆环图、范围（高至低）条形图、网状图等；支持图的拖拽缩放；支持 Android 2.2 以上，支持横纵轴缩放，多指缩放，展现动画、高亮、保存到 sdcard、从文件读取图表 项目地址：https://github.com/PhilJay/MPAndroidChart Demo 地址：https://play.google.com/store/apps/details?id=com.xxmassdeveloper.mpchartexample Demo 项目：https://github.com/PhilJay/MPAndroidChart/tree/master/MPChartExample 在线演示：https://www.youtube.com/watch?v=ufaK_Hd6BpI achartengine 强大的图表绘制工具，支持折线图、面积图、散点图、时间图、柱状图、条图、饼图、气泡图、圆环图、范围（高至低）条形图、拨号图/表、立方线图及各种图的结合 项目地址：https://code.google.com/p/achartengine/ 官网网址：http://www.achartengine.org/ APP 示例：Wordpress Android，Google Analytics GraphView 绘制图表和曲线图的 View，可用于 Android 上的曲形图、柱状图、波浪图展示 项目地址：https://github.com/jjoe64/GraphView Demo 项目：https://github.com/jjoe64/GraphView-Demos APP 示例：Wordpress Android，Google Analytics HoloGraphLibrary 绘制现状图、柱状图、饼状图 项目地址：https://bitbucket.org/danielnadeau/holographlibrary/src 文档介绍：https://bitbucket.org/danielnadeau/holographlibrary/wiki/Home XCL-Charts XCL-Charts 基于原生的 Canvas 来绘制各种图表,在设计时，尽量在保证开发效率的同时，给使用者提供足够多的定制化能力。因此使用简便,同时具有相当灵活的定制能力。目前支持 3D/非 3D 柱形图(Bar Chart)、3D/非 3D 饼图(Pie Chart)、堆积图(Stacked Bar Chart)、面积图(Area Chart)、 折线图(Line Chart)、曲线图(Spline Chart)、环形图(Dount Chart)、南丁格尔玫瑰图(Rose Chart)、仪表盘(Dial Chart)、刻度盘(Gauge Chart)、雷达图(Radar Chart)、圆形图(Circle Chart)等图表。其它特性还包括支持图表缩放、手势移动、动画显示效果、高密度柱形显示、图表分界定制线、多图表的混合显示及同数据源不同类型图表切换等。 项目地址：https://github.com/xcltapestry/XCL-Charts Demo 地址：https://github.com/xcltapestry/XCL-Charts/blob/master/XCL-Charts-demo/bin/XCL-Charts-demo.apk?raw=true EazeGraph Android 图表库，支持柱状图、分层柱状图、饼状图、线性图 项目地址：https://github.com/blackfizz/EazeGraph Demo 地址：https://play.google.com/store/apps/details?id=org.eazegraph.app WilliamChart 绘制图表的库，支持 LineChartView、BarChartView 和 StackBarChartView 三中图表类型，并且支持 Android 2.2 及以上的系统。 项目地址：https://github.com/diogobernardino/WilliamChart Demo 地址：https://play.google.com/store/apps/details?id=com.db.williamchartdemo Demo 项目：https://github.com/diogobernardino/WilliamChart/tree/master/sample HelloCharts for Android 支持折线图、柱状图、饼图、气泡图、组合图；支持预览、放大缩小，滚动，部分图表支持动画；支持 Android 2.2 以上 项目地址：https://github.com/lecho/hellocharts-android Demo 地址：https://play.google.com/store/apps/details?id=lecho.lib.hellocharts.samples 在线演示：https://www.youtube.com/watch?v=xbSBjyjH2SY PieChartView 比较简单直接的饼状统计报表图，使用方便，设置相应的属性参数即可 项目地址：https://github.com/wuseal/PieChartView Demo 地址：https://github.com/wuseal/PieChartView 十五、UI Style 不同样式的系统 UI 风格，如 IOS、Bootstrap 风格 UITableView ios 风格控件，包括 Button、ListView、TableView 项目地址：https://github.com/thiagolocatelli/android-uitableview Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/ui-tableview-demo.apk?raw=true ATableView ios 风格控件 项目地址：https://github.com/dmacosta/ATableView Demo 地址：https://play.google.com/store/apps/details?id=com.nakardo.atableview.demo Cards-UI 卡片式 View，支持单个卡片，item 为卡片的 ListView 项目地址：https://github.com/afollestad/Cards-UI Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/cards-ui-demo.apk?raw=true cardslib 卡片式 View，支持单个卡片，item 为卡片的 ListView 和 GridView 项目地址：https://github.com/gabrielemariotti/cardslib Demo 地址：https://play.google.com/store/apps/details?id=it.gmariotti.cardslib.demo Android-Bootstrap Bootstrap 风格的按钮 项目地址：https://github.com/Bearded-Hen/Android-Bootstrap Material Design Android Library Android L 中 Material Design 风格的组件适配到 Android 2.2+ 项目地址：https://github.com/navasmdc/MaterialDesignLibrary Android FlatUI Android 扁平化风格的组件，支持一些自定义样式 项目地址：https://github.com/eluleci/FlatUI cheesesquare 全新 Android 设计库演示 Demo，包括 Collapsing Toolbar、FloatingActionButton、View anchoring、NavigationView、Snackbar 项目地址：https://github.com/chrisbanes/cheesesquare 十六、其他 SnappingStepper 一种漂亮的UI控件，能更灵活的控制数字的增减。可用于购物车商品数量控制。 项目地址：https://github.com/saiwu-bigkoo/Android-SnappingStepper SwipeBackLayout 左右或向上滑动返回的 Activity 项目地址：https://github.com/Issacw0ng/SwipeBackLayout Demo 地址：https://play.google.com/store/apps/details?id=me.imid.swipebacklayout.demo APP 示例：知乎 android-styled-dialogs 可自定义样式的 dialog，默认与 Holo 主题样式一致，在 Android2.2 以上同一样式 项目地址：https://github.com/inmite/android-styled-dialogs Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/styled-dialogs-demo.apk?raw=true Android Sliding Up Panel 可拖动的 View，能在当前 Activity 上扶起一个可拖动的 Panel 项目地址：https://github.com/umano/AndroidSlidingUpPanel Demo 地址：https://play.google.com/store/apps/details?id=com.sothree.umano APP 示例：Google Music 精简播放栏 TableFixHeaders 第一列固定的 Table 项目地址：https://github.com/InQBarna/TableFixHeaders Demo 地址：http://bit.ly/13buAIq Inscription 可用于展示应用 change 和 new feature 信息 项目地址：https://github.com/MartinvanZ/Inscription ActivityTransition Activity 切换动画，包括渐变、flip、某个位置进入等等 项目地址：https://github.com/ophilbert/ActivityTransition 文档介绍：https://github.com/jfeinstein10/JazzyViewPager/blob/master/JazzyViewPager.apk?raw=true EasyAndroidAnimations 针对 View 的各种动画 项目地址：https://github.com/2359media/EasyAndroidAnimations ViewAnimation 对android view 动画进行封装,实现起更简单，自带三种常见运动路径，其他的可自定义 项目地址：https://github.com/guohuanwen/ViewAniamtion APP 示例：QQ名片圈圈效果 AndroidLoadingAnimation 多种android加载动画 项目地址：https://github.com/guohuanwen/AndroidLoadingAnimation android-lockpattern Android 的图案密码解锁 项目地址：https://code.google.com/p/android-lockpattern/ 原理剖析文档：[android-lockpattern](http://a.codekk.com/detail/Android/爱早起/Android Lock Pattern 源码解析) Demo 地址：https://play.google.com/store/apps/details?id=group.pals.android.lib.ui.lockpattern.demo 文档介绍：https://code.google.com/p/android-lockpattern/wiki/QuickUse APP 示例：Android 开机的图案密码解锁，支付宝的密码解锁 PatternLock 另一个 Android 图案解锁库 项目地址：https://github.com/DreaminginCodeZH/PatternLock Demo 地址：https://github.com/DreaminginCodeZH/PatternLock/raw/master/dist/sample.apk APP 示例：Android 开机的图案密码解锁，支付宝的密码解锁 RangeBar 类似于 SeekBar，不同的是可以选择一个范围内的值而不是单个值 项目地址：https://github.com/edmodo/range-bar Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/range-bar-demo.apk?raw=true ChromeView 利用 Chromium 实现的 WebView，解决各个 Android 版本 WebView 不同的问题，同时利用最新 Chrome 代码 项目地址：https://github.com/pwnall/chromeview android-phased-seek-bar 支持预先定义状态的 SeekBar 项目地址：https://github.com/ademar111190/android-phased-seek-bar Android Slider Preference Library 可添加到设置中的基于对话框的 RankBar 小部件 项目地址：https://github.com/jayschwa/AndroidSliderPreference ShowcaseView library 用于高亮显示应用程序的特定部分，从而突出突出重点 项目地址：https://github.com/amlcurran/ShowcaseView android-segmented-control Android 上的 Segmented Controls，相当于 RadioButton 组 项目地址：https://github.com/hoang8f/android-segmented-control Swipeable Cards 类似 Tinder 的卡片效果，可以加载图片并动画效果展示，向左滑动表示喜欢，向右表示不喜欢 项目地址：https://github.com/kikoso/Swipeable-Cards Demo 地址：https://play.google.com/store/apps/details?id=info.hoang8f.fbutton.demo EdgeEffectOverride 改变 ScrollView, ListView, ExpandableListView, GridView, ViewPager 等滚动控件滚动到边缘的颜色效果 项目地址：https://github.com/AndroidAlliance/EdgeEffectOverride android-pinned-header-listviews 使 ExpandListView 的 Group 滑动到顶端时会固定不动直到另外一个 Group 到达顶端 项目地址：https://github.com/rtyley/android-pinned-header-listviews AndroidSwipeLayout 滑动 Layout，支持单个 View，ListView，GridView 项目地址：https://github.com/daimajia/AndroidSwipeLayout Demo 地址：Download Demo DynamicCardLayout 在 Android 中实现的类似 Windows8 的瓷片布局 项目地址：https://github.com/dodola/DynamicCardLayout Emoticons-Keyboard 带表情情符号的自定义键盘 项目地址：https://github.com/chiragjain/Emoticons-Keyboard Android Typeface Helper 可以帮你轻松实现自定义字体的库 项目地址：https://github.com/norbsoft/android-typeface-helper Android-Anim-Playground 几个动画效果，其中第二个基于 android-svg 的绘制效果非常好 项目地址：https://github.com/Tibolte/Android-Anim-Playground AlertView 仿iOS的AlertViewController 几乎完美还原iOS 的 AlertViewController ，同时支持Alert和ActionSheet模式，每一个细节都是精雕细琢，并把api封装成懒到极致模式，一行代码就可以进行弹窗. 项目地址：https://github.com/saiwu-bigkoo/Android-AlertView NiftyDialogEffects 支持自定义飞入动画样式的 Dialog 项目地址：https://github.com/sd6352051/NiftyDialogEffects 在线演示：http://tympanus.net/Development/ModalWindowEffects/ PostOffice 创建 Holo 及 Material Design 样式的 Dialog 项目地址：https://github.com/r0adkll/PostOffice Swipecards 类似 Tinder 的卡片效果，可以加载图片并动画效果展示，向左滑动表示喜欢，向右表示不喜欢，根据 Kikoso’s Swipeable-Cards 改造而来 项目地址：https://github.com/Diolor/Swipecards SeekArc 圆形的 SeekBar 项目地址：https://github.com/TriggerTrap/SeekArc BlurDialogFragment 显示 DialogFragment 时背景模糊效果 项目地址：https://github.com/tvbarthel/BlurDialogFragment Demo 地址：https://play.google.com/store/apps/details?id=fr.tvbarthel.lib.blurdialogfragment.sample range-seek-bar 随机值选取的 SeekBar 项目地址：https://github.com/yahoo/android-range-seek-bar MaterialRangeBar 可以选择一个范围内的值而不是单个值的 SeekBar，RangeBar 的 Material Design 风格适配 项目地址：https://github.com/oli107/material-range-bar MaterialList Material Design 风格的 CardView 项目地址：https://github.com/dexafree/MaterialList Demo 地址：https://play.google.com/store/apps/details?id=com.dexafree.materiallistviewexample road-trip 设置 path 的各种动画效果，以及如何实现复杂路径动画，类似于 ios 中的指纹注册界面的指纹动画效果 项目地址：https://github.com/romainguy/road-trip dialogplus 一个简单的 Android 对话框，支持不同的弹出模式 项目地址：https://github.com/orhanobut/dialogplus FlowLayout 一个简单的流式布局，用法类似 LinearLayout，但是能够让子元素根据宽度自动换行 项目地址：FLowLayout CircleSeekbar 一个环形Seekbar组件,支持叠加复合使用 项目地址：CircleSeekbar FinestWebView 美麗的和可定制的Android的活動，顯示在一個應用程序的網頁。 项目地址: https://github.com/TheFinestArtist/FinestWebView-Android Sample 地址: https://play.google.com/store/apps/details?id=com.thefinestartist.finestwebview.sample YouTubePlayerActivity 只需通過一個URL來在新的活動播放YouTube視頻。它支持屏幕方向，媒體音量控制等。 项目地址: https://github.com/TheFinestArtist/YouTubePlayerActivity Sample 地址: https://play.google.com/store/apps/details?id=com.thefinestartist.ytpa.sample material-camera material风格的camera。能使camera使用起来更简单的库。 项目地址：https://github.com/afollestad/material-camera material-dialogs 各种material风格的dialog。 漂亮的的、易于使用的和可定制的Dialog API，你能够使用Material designed风格的Dialog到API 8。 项目地址：https://github.com/afollestad/material-dialogs Sample地址：https://github.com/afollestad/material-dialogs/blob/master/sample/sample.apk NotifyUtil 最常见的通知样式库 项目地址:https://github.com/wenmingvs/NotifyUtil demo地址：https://github.com/wenmingvs/NotifyUtil#notifydemo CanPhotos 使用fresco选取多张图片并可预览图片 项目地址：https://github.com/canyinghao/CanPhotos CanDialog 仿照系统Dialog所写，继承于FrameLayout，添加一些动画，一些显示类型。 项目地址：https://github.com/canyinghao/CanDialog 第二部分 工具库 主要包括那些不错的开发库，包括依赖注入框架、图片缓存、网络请求、数据库 ORM 建模、Android 公共库、Android 高版本向低版本兼容、多媒体相关及其他。 一、依赖注入 DI 通过依赖注入减少 View、服务、资源简化初始化，事件绑定等重复繁琐工作 AndroidAnnotations(Code Diet) android 快速开发框架 项目地址：https://github.com/excilys/androidannotations 文档介绍：https://github.com/excilys/androidannotations/wiki 官网网址：http://androidannotations.org/ 特点：(1) 依赖注入：包括 view，extras，系统服务，资源等等 (2) 简单的线程模型，通过 annotation 表示方法运行在 ui 线程还是后台线程 (3) 事件绑定：通过 annotation 表示 view 的响应事件，不用在写内部类 (4) REST 客户端：定义客户端接口，自动生成 REST 请求的实现 (5) 没有你想象的复杂：AndroidAnnotations 只是在在编译时生成相应子类 (6) 不影响应用性能：仅 50kb，在编译时完成，不会对运行时有性能影响。 其他：与 roboguice 的比较：roboguice 通过运行时读取 annotations 进行反射，所以可能影响应用性能，而 AndroidAnnotations 在编译时生成子类，所以对性能没有影响 roboguice 帮你处理了很多代码异常，利用 annotation 使得更少的代码完成项目 项目地址：https://github.com/roboguice/roboguice 文档介绍：https://github.com/roboguice/roboguice/wiki butterknife 利用 annotation 帮你快速完成 View 的初始化，减少代码 项目地址：https://github.com/JakeWharton/butterknife 文档介绍：http://jakewharton.github.io/butterknife/ Dagger 依赖注入，适用于 Android 和 Java 项目地址：https://github.com/square/dagger 原理剖析文档：[Dagger](http://a.codekk.com/detail/Android/扔物线/Dagger 源码解析) 文档介绍：http://square.github.io/dagger/ AutoParcel 注解自动生成Parcelable实现代码的库 项目地址：https://github.com/frankiesardo/auto-parcel 这篇文章详细介绍了它的使用方法：AutoParcel 作者认为使用AutoParcel的好处是，可以简化构造函数，方便IDE代码自动完成，方便测试，前向兼容，生成不可变的对象。 文档介绍：https://github.com/frankiesardo/auto-parcel 二、图片缓存 Android-Universal-Image-Loader 图片缓存，目前使用最广泛的图片缓存，支持主流图片缓存的绝大多数特性。 项目地址：https://github.com/nostra13/Android-Universal-Image-Loader 原理剖析文档：[Android-Universal-Image-Loader](http://a.codekk.com/detail/Android/huxian99/Android Universal Image Loader 源码分析) Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/universal-imageloader-demo.apk?raw=true 文档介绍：http://www.intexsoft.com/blog/item/74-universal-image-loader-part-3.html picasso square 开源的图片缓存 项目地址：https://github.com/square/picasso 文档介绍：http://square.github.io/picasso/ 特点：(1)可以自动检测 adapter 的重用并取消之前的下载 (2)图片变换 (3)可以加载本地资源 (4)可以设置占位资源 (5)支持 debug 模式 Cube ImageLoader 阿里巴巴一淘使用的图片加载，综合了 Android-Universal-Image-Loader 和 square 等组件优点，简单易用，良好的中文文档支持 项目地址：https://github.com/etao-open-source/cube-sdk Demo 地址：https://github.com/liaohuqiu/cube-sdk/raw/master/cube-sdk-sample.apk 文档介绍：http://cube-sdk.liaohuqiu.net/ fresco 一款强大的图片缓存工具，由 Facebook 开发 项目地址：https://github.com/facebook/fresco 文档介绍：http://frescolib.org/ 特点：(1) 两个内存缓存加上磁盘缓存构成了三级缓存 (2) 支持流式，可以类似网页上模糊渐进式显示图片 (3) 对多帧动画图片支持更好，如 Gif、WebP (4) 更多样的显示，如圆角、进度条、点击重试、自定义对焦点 (5) 更多样的加载，如支持 EXIF、全面支持 WebP (6) 支持 Android 2.3+ Glide Glide 是一个 android 平台上的快速和高效的开源的多媒体资源管理库,提供 多媒体文件的压缩,内存和磁盘缓存, 资源池的接口。 它可以最大性能地在 Android 设备上读取、解码、显示图片和视频。Glide 可以将远程的图片、视频、动画图片等缓存在设备本地便于提高用户浏览图片的流畅体验。 项目地址：https://github.com/bumptech/glide 特点： (1) GIF 动画的解码 (2) 本地视频剧照的解码 (3) 支持缩略图 (4) Activity 生命周期的集成 (5) 转码的支持 (6) 动画的支持 (7) OkHttp 和 Volley 的支持 三、网络请求 Volley Google 提供的网络通信库，使得网络请求更简单、更快速 项目地址：https://android.googlesource.com/platform/frameworks/volley 文档介绍：http://commondatastorage.googleapis.com/io-2013/presentations/110 - Volley- Easy, Fast Networking for Android.pdf Asynchronous Http Client for Android Android 异步 Http 请求 项目地址：https://github.com/loopj/android-async-http 文档介绍：http://loopj.com/android-async-http/ 特点：(1) 在匿名回调中处理请求结果 (2) 在 UI 线程外进行 http 请求 (3) 文件断点上传 (4) 智能重试 (5) 默认 gzip 压缩 (6) 支持解析成 Json 格式 (7) 可将 Cookies 持久化到 SharedPreferences android-query 异步加载，更少代码完成 Android 加载 项目地址：https://github.com/androidquery/androidquery 或 https://code.google.com/p/android-query/ Demo 地址：https://play.google.com/store/apps/details?id=com.androidquery 文档介绍：https://code.google.com/p/android-query/#Why_AQuery? 特点：https://code.google.com/p/android-query/#Why_AQuery? Async Http Client Java 异步 Http 请求 项目地址：https://github.com/AsyncHttpClient/async-http-client 文档介绍：http://sonatype.github.io/async-http-client/ Ion 支持图片、json、http post 等异步请求 项目地址：https://github.com/koush/ion 文档介绍：https://github.com/koush/ion#more-examples Http Request 项目地址：https://github.com/kevinsawicki/http-request 文档介绍：https://github.com/kevinsawicki/http-request#examples okhttp square 开源的 http 工具类 项目地址：https://github.com/square/okhttp 文档介绍：http://square.github.io/okhttp/ 特点：(1) 支持 SPDY( http://zh.wikipedia.org/wiki/SPDY )协议。SPDY 协议是 Google 开发的基于传输控制协议的应用层协议，通过压缩，多路复用(一个 TCP 链接传送网页和图片等资源)和优先级来缩短加载时间。 (2) 如果 SPDY 不可用，利用连接池减少请求延迟 (3) Gzip 压缩 (4) Response 缓存减少不必要的请求 Retrofit RESTFUL API 设计 项目地址：https://github.com/square/retrofit 文档介绍：http://square.github.io/retrofit/ RoboSpice Android 异步网络请求工具，支持缓存、REST 等等 项目地址：https://github.com/stephanenicolas/robospice Demo 地址：https://github.com/stephanenicolas/RoboDemo/downloads TwistVolley TwistVolley 是对 Volley 的一个封装库。提供类似 Picasso 一样的串联式 API。使得使用 Volley 更加方便。 项目地址：https://github.com/TwistedEquations/TwistVolley 四、数据库 orm 工具包 orm 的 db 工具类，简化建表、查询、更新、插入、事务、索引的操作 greenDAO Android Sqlite orm 的 db 工具类 项目地址：https://github.com/greenrobot/greenDAO 文档介绍：http://greendao-orm.com/documentation/ 官网网址：http://greendao-orm.com/ 特点：(1) 性能佳 (2) 简单易用的 API (3) 内存小好小 (4) 库大小小 GreenDaoUpgradeHelper greenDAO的数据库升级帮助类，只需一行代码解决数据库升级 项目地址：https://github.com/yuweiguocn/GreenDaoUpgradeHelper ActiveAndroid Android Sqlite orm 的 db 工具类 项目地址：https://github.com/pardom/ActiveAndroid 文档介绍：https://github.com/pardom/ActiveAndroid/wiki/_pages Sprinkles Android Sqlite orm 的 db 工具类，比较显著的特点就是配合 https://github.com/square/retrofit 能保存从服务器获取的数据 项目地址：https://github.com/emilsjolander/sprinkles 文档介绍：http://emilsjolander.github.io/blog/2013/12/18/android-with-sprinkles/ Realm 移动端的数据库，适用于 Phone、Tablet、Wearable，支持 ORM，线程安全、支持连表及数据库加密，比 SQLite 性能更好 项目地址：https://github.com/realm/realm-java 文档介绍：http://realm.io/docs/java/0.72.0/ ormlite-android 项目地址：https://github.com/j256/ormlite-android 文档介绍：http://ormlite.com/sqlite_java_android_orm.shtml Schematic 根据 SQLite 生成 ContentProvider 项目地址：https://github.com/SimonVT/schematic DBFlow Android SQLite ORM 工具库。综合了 Active Android, Schematic, Ollie,Sprinkles 等库的优点；通过注解实现，性能好；能生成 ContentProvider。 项目地址：https://github.com/Raizlabs/DBFlow 文档介绍：https://github.com/Raizlabs/DBFlow#usage-docs SnappyDB SnappyDB是一个key-value数据库，非常流行的NoSQL数据库。 项目地址：https://github.com/nhachicha/SnappyDB 演示Demo：https://play.google.com/store/apps/details?id=com.snappydb.snippets.app 五、Android 公共库 Guava Google 的基于 java1.6 的类库集合的扩展项目，包括 collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O 等等. 这些高质量的 API 可以使你的 JAVa 代码更加优雅，更加简洁 项目地址：https://code.google.com/p/guava-libraries/ 文档介绍：https://code.google.com/p/guava-libraries/wiki/GuavaExplained AndroidCommon Android 公共库 项目地址：https://github.com/Trinea/AndroidCommon Demo 地址：https://play.google.com/store/apps/details?id=cn.trinea.android.demo 文档介绍：http://www.trinea.cn/android/android-common-lib/ 包括：a. ImageCache 图片缓存，包含内存和 Sdcard 缓存 http://www.trinea.cn/android/android-imagecache/ 特点：(1)支持预取新图片，支持等待队列 (2)包含二级缓存，可自定义文件名保存规则 (3)可选择多种缓存算法(FIFO、LIFO、LRU、MRU、LFU、MFU 等 13 种)或自定义缓存算法 (4)可方便的保存及初始化恢复数据 (5)支持不同类型网络处理 (6)可根据系统配置初始化缓存等 HttpCache Http 缓存 文档介绍：http://www.trinea.cn/android/android-http-cache 特点是：(1) 根据 cache-control、expires 缓存 http 请求 (2) 支持同步、异步 Http 请求 (3) 在匿名回调中处理请求结果 (4) 在 UI 线程外进行 http 请求 (5) 默认 gzip 压缩 (2) 公共 View(下拉及底部加载更多 ListView、底部加载更多 ScrollView、滑动一页 Gallery) (3) Android 常用工具类(网络、下载、Android 资源操作、shell、文件、Json、随机数、Collection 等等) DropDownListView 下拉刷新及滑动到底部加载更多 ListView 文档介绍：http://www.trinea.cn/android/dropdown-to-refresh-and-bottom-load-more-listview/ shipfaster 整合了 Dagger Otto Retrofit Robolectric Picasso OkHttp，方便快速开发 项目地址：https://github.com/pyricau/shipfaster CleanAndroidCode 整合了 Dagger Otto AndroidAnnotations，方便快速开发 项目地址：https://github.com/pyricau/CleanAndroidCode xUtils 基于 Afinal，包含 DbUtils、ViewUtils、HttpUtils、BitmapUtils 四大模块，可用于快速开发 项目地址：https://github.com/wyouflf/xUtils 原理剖析文档：[xUtils](http://a.codekk.com/detail/Android/Caij/xUtils 源码解析) Afinal Afinal 是一个 android 的 ioc，orm 框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过 finalActivity，我们可以通过注解的方式进行绑定 ui 和事件。通过 finalBitmap，我们可以方便的加载 bitmap 图片，而无需考虑 oom 等问题。通过 finalDB 模块，我们一行代码就可以对 android 的 sqlite 数据库进行增删改查。通过 FinalHttp 模块，我们可以以 ajax 形式请求 http 数据 项目地址：https://github.com/yangfuhai/afinal 官网网址：http://www.afinal.org UltimateAndroid UltimateAndroid 是一个快速开发 Android 应用的框架，框架目前主要包含的功能有 View Injection,ORM,异步网络请求和图片加载，自动化脚本测试,磁盘 LRU 等功能.同时提供了类似于 TripleDes、Webview 快速设置、Md5 处理、String 处理,Https 处理等常用工具类，还有超过 100 多种 UI 控件效果。 项目地址：https://github.com/cymcsg/UltimateAndroid 官网网址：http://blog.marshalchen.com/UltimateAndroid/ SAF SAF(Simple Android Framework)是一个简单的 android 框架，它为开发 Android app 提供了基础性组件。 项目地址：https://github.com/fengzhizi715/SAF 官网网址：http://www.salesuite.cn/ 包括：(1)Event Bus(事件总线) (2) Rest Client(http 的框架) (3) Image Cache(图片缓存) (4) Dependency Injection(依赖注入) (5) Sqlite ORM(sqlite 的 orm) (6) Router(Activity、Fragment 的 Router) (7) Utils(各种常用的工具类) Barber Custom View 神器。通过简单的注解帮助你大大减少 Custom View 中的代码量。由于和 ButterKnife 一样使用了 Annotation Proccessor ，所以对程序性能没有影响。 项目地址：https://github.com/hzsweers/barber device-year-class A library that analyzes an Android device’s specifications and calculates which year the device would be considered &quot;high end”.(facebook 开发的检测手机主流配置工具) 项目地址：https://github.com/facebook/device-year-class RxAndroid 对RxJava在Android上的扩展，使得Android上也很容易实现reactive components，简化线程操作，从而写出很漂亮的代码。 项目地址：https://github.com/ReactiveX/RxAndroid 文档介绍：给Android 开发者的 RxJava 详解 MultiImageSelector 一个本地图片选择器，支持图片的单选和多选，直接返回所选图片的路径。 项目地址：https://github.com/lovetuzitong/MultiImageSelector.git 六、Android 高版本向低版本兼容 Nine Old Androids 将 Android 3.0(Honeycomb)所有动画 API(ObjectAnimator ValueAnimator 等)兼容到 Android1.0 项目地址：https://github.com/JakeWharton/NineOldAndroids 原理剖析文档：[Nine Old Androids](http://a.codekk.com/detail/Android/Mr.Simple/NineOldAnimations 源码解析) Demo 地址：https://play.google.com/store/apps/details?id=com.jakewharton.nineoldandroids.sample 文档介绍：http://nineoldandroids.com/ HoloEverywhere 将 Android 3.0 的 Holo 主题兼容到 Android2.1++ 项目地址：https://github.com/Prototik/HoloEverywhere Demo 地址：https://raw.github.com/Prototik/HoloEverywhere/repo/org/holoeverywhere/demo/2.1.0/demo-2.1.0.apk 文档介绍：http://android-developers.blogspot.com/2012/01/holo-everywhere.html SherlockNavigationDrawer 将 Android NavigationDrawer 和 ActionbarSherlock 结合，解决 4.0 以下 NavigationDrawer 的适配问题 项目地址：https://github.com/tobykurien/SherlockNavigationDrawer 文档介绍：http://developer.android.com/training/implementing-navigation/nav-drawer.html Notifications4EveryWhere 将 Android 4.1 的 Notification 兼容到 Android2.2++ 项目地址：https://github.com/youxiachai/Notifications4EveryWhere Android Switch Widget Backport 将 Android Switch 和 SwitchPreference 的兼容到 Android2.1++ 项目地址：https://github.com/BoD/android-switch-backport Demo 地址：https://play.google.com/store/apps/details?id=org.jraf.android.backport.switchwidget.sample 文档介绍：https://github.com/BoD/android-switch-backport#using-the-switch android-datepicker 将 Android 4.0 的 datepicker 兼容到 Android2.2++ 项目地址：https://github.com/SimonVT/android-datepicker Transitions Everywhere Android 4.4 的 Transitions API 兼容到 Android 2.2 以上 项目地址：https://github.com/andkulikov/transitions-everywhere KShareViewActivityManager 一个兼容Android 5.0 以下Shared Element Transition （页面间共享元素位移动画）库 项目地址：https://github.com/kot32go/KShareViewActivityManager 七、多媒体相关 cocos2d-x 跨平台的 2d 游戏框架，支持 Android、IOS、Linux、Windows 等众多平台 项目地址：https://github.com/cocos2d/cocos2d-x 文档介绍：http://www.cocos2d-x.org/wiki 官网网址：http://www.cocos2d-x.org/ JustWeEngine Android的轻量级游戏框架，能大大缩减编写原生游戏的代码量和难度，仍在持续更新中。 项目地址: https://github.com/lfkdsk/JustWeEngine Demo地址: https://github.com/lfkdsk/EngineDemo Vitamio 是一款 Android 与 iOS 平台上的全能多媒体开发框架 项目地址：https://github.com/yixia/VitamioBundle 网站介绍：http://www.vitamio.org/docs/ 特点：(1) 全面支持硬件解码与 GPU 渲染 (2) 能够流畅播放 720P 甚至 1080P 高清 MKV，FLV，MP4，MOV，TS，RMVB 等常见格式的视频 (3) 在 Android 与 iOS 上跨平台支持 MMS, RTSP, RTMP, HLS(m3u8)等常见的多种视频流媒体协议，包括点播与直播。 VDPlayerSDK 最容易集成的开源播放器组件，支持直播，支持软硬解切换，支持清晰度切换 项目地址：https://github.com/SinaVDDeveloper/ Demo 地址：https://github.com/SinaVDDeveloper/demo 文档介绍：https://github.com/SinaVDDeveloper/sinavideo_playersdk 特点： (1) 使用自定义控件方式提供播放器UI，不需要视频相关知识，能编写android应用就能使用 (2) 软硬解切换、点播直播支持 (3) 解码内核小于4M，更方便集成到非专业视频app中 (4) 修正一些vitaimio的问题，比如m3u8可以拖动等等 VideoPlayerManager 帮助实现VideoPlayer控制，使得它更容易使用ListView和recyclerview。它还可以跟踪滚动列表中可见的项。当列表中的新项可见域最大时，该库给出了接口来跟踪它。 项目地址：https://github.com/danylovolokh/VideoPlayerManager 文档介绍：https://medium.com/@v.danylo/implementing-video-playback-in-a-scrolled-list-listview-recyclerview-d04bc2148429#.hs5n0geqn UniversalVideoView Android上定义播放器控件,支持自定义控制UI, 全屏播放, 重力感应自动切换横竖屏. 项目地址：https://github.com/linsea/UniversalVideoView PhotoProcessing 利用 ndk 处理图片库，支持 Instafix、Ansel、Testino、XPro、Retro、BW、Sepia、Cyano、Georgia、Sahara、HDR、Rotate(旋转)、Flip(翻转)等各种特效 项目地址：https://github.com/lightbox/PhotoProcessing Demo 地址：https://github.com/Trinea/TrineaDownload/blob/master/photo-processing.apk?raw=true Android StackBlur 图片模糊效果工具类 项目地址：https://github.com/kikoso/android-stackblur Demo 地址：https://github.com/kikoso/android-stackblur/blob/master/StackBlurDemo/bin/StackBlurDemo.apk?raw=true 文档介绍：https://github.com/kikoso/android-stackblur#usage Bitmap Smart Clipping using OpenCV 图片智能裁剪保留重要部分显示 项目地址：https://github.com/beartung/tclip-android 利用淘宝的 http://code.taobao.org/p/tclip/ 库完成 一淘玩客正在使用的图片裁剪，自动识别图片中的重要区域，并且在图片裁剪时保留重要区域 特点：(1). 能进行人脸识别。图片中有人脸，将自动视为人脸区域为重要区域，将不会被裁剪掉 (2).自动其它重要区域。如果图片中未识别出人脸，则会根据特征分布计算出重区域 Cropper 图片局部剪切工具，可触摸控制选择区域或旋转 项目地址：https://github.com/edmodo/cropper 文档介绍：https://github.com/edmodo/cropper/wiki uCrop Yalantis 出品的强大的图片裁剪库 ，支持缩放，旋转图片，支持各种比例的裁剪框 项目地址：https://github.com/Yalantis/uCrop android-crop 图片裁剪 Activity 项目地址：https://github.com/jdamcd/android-crop TileView 可分块显示大图，支持 2D 拖动、双击、双指放大、双指捏合 项目地址：https://github.com/moagrius/TileView Demo 地址：http://moagrius.github.io/TileView/TileViewDemo.apk BlurEffectForAndroidDesign 图片模糊效果 项目地址：https://github.com/PomepuyN/BlurEffectForAndroidDesign android-eye PC 端网页查看同一局域网内的手机摄像头内容，可以用来监控哦 项目地址：https://github.com/Teaonly/android-eye Demo 地址：https://play.google.com/store/apps/details?id=teaonly.droideye libpng for Android PNG 图片的 jni 库，支持几乎 png 的所有特性 项目地址：https://github.com/julienr/libpng-android 文档介绍：http://www.libpng.org/pub/png/libpng.html android-gpuimage 基于 GPU 的图片滤镜 项目地址：https://github.com/CyberAgent/android-gpuimage AndroidFaceCropper 图片脸部自动识别，将识别后的局部图片返回 项目地址：https://github.com/lafosca/AndroidFaceCropper Android Video Crop 利用 TextureView 播放和剪切视频，类似 ImageView.setScaleType 项目地址：https://github.com/dmytrodanylyk/android-video-crop Demo 地址：https://github.com/lafosca/AndroidFaceCropper/releases/download/1.0/FaceCropper-sample-debug-unaligned.apk svg-android Android Svg 矢量图形支持 项目地址：https://github.com/japgolly/svg-android https://github.com/japgolly/svg-android Android Visualizer 从 Android MediaPlayer 获得音频，然后像 iTunes 及 WinAmp 一样展示音轨 项目地址：https://github.com/felixpalmer/android-visualizer ExoPlayer 包括仪表板和 SmoothStreaming 自适应回放，缓存持久化和自定义渲染器，方便自定义和扩展，并且可以通过应用商店更新 项目地址：https://github.com/google/ExoPlayer DanmakuFlameMaster android 上开源弹幕解析绘制引擎项目 项目地址：https://github.com/ctiao/DanmakuFlameMaster OpenDanmaku android 上一个轻量级的更简单的开源弹幕控件 项目地址：https://github.com/linsea/OpenDanmaku 八、事件总线(订阅者模式) 通过发布/订阅事件解耦事件发送和接受，从而简化应用程序组件(Activities, Fragments 及后台线程)之间的通信 EventBus greenrobot 的开源项目 项目地址：https://github.com/greenrobot/EventBus 原理剖析文档：[EventBus](http://a.codekk.com/detail/Android/Trinea/EventBus 源码解析) 文档介绍：https://github.com/greenrobot/EventBus#general-usage-and-api 特点：(1) 支持在不同类型的线程中处理订阅，包括发布所在线程，UI 线程、单一后台线程、异步线程 (2) 支持事件优先级定义，支持优先级高的订阅者取消事件继续传递，支持粘性事件，是不是跟系统的有序广播、粘性广播很像啊 (3) 不是基于 annotations (4) 性能更优 (5) 体积小 (6) 支持单例创建或创建多个对象 (7) 支持根据事件类型订阅 Otto Square 的开源项目，基于 Guava 的 Android 优化 项目地址：https://github.com/square/otto 文档介绍：http://square.github.io/otto/ EventBus 与 Otto 的功能及性能对比文档 EventBus 与 Otto 性能对比 Demo Apk 九、传感器 Great Android Sensing Toolkit Android 感应器工具包，包含示例及使用过程中可能需要的算法 项目地址：https://github.com/gast-lib/gast-lib Demo 地址：https://play.google.com/store/apps/details?id=root.gast.playground 文档介绍：https://github.com/gast-lib/gast-lib#documentation SensorManager Android 传感器管理 项目地址：https://github.com/nlathia/SensorManager 文档介绍：https://docs.google.com/document/d/1TqThJULb-4e6TGb1gdkAaPCfyuXStjJpbnt7a0OZ9OE/edit GPSLogger 记录 GPS 信息 项目地址：https://github.com/mendhak/gpslogger Demo 地址：https://play.google.com/store/apps/details?id=com.mendhak.gpslogger 文档介绍：http://code.mendhak.com/gpslogger/ Pedometer 计步器，使用硬件计步感应器 项目地址：https://github.com/j4velin/Pedometer leapcast ChromeCast 模拟器的 App 项目地址：https://github.com/dz0ny/leapcast Arduino-Communicator 与 Arduino 通信的 App 项目地址：https://github.com/jeppsson/Arduino-Communicator android-pedometer Android 计步器 项目地址：https://github.com/bagilevi/android-pedometer Demo 地址：http://pedometer.googlecode.com/files/Pedometer-1.4.apk OwnTracks for Android 自己的轨迹记录 项目地址：https://github.com/owntracks/android Shake Detector library for Android Android 手机震动摇晃检测库，提供供 UI 线程调用的回调接口 项目地址：https://github.com/tbouron/ShakeDetector Demo 地址：https://play.google.com/store/apps/details?id=com.github.tbouron.shakedetector.example Android heart rate monitor Android 心跳检测 项目地址：https://github.com/phishman3579/android-heart-rate-monitor Bluetooth LE Library for Android 蓝牙源信息，包括宝库 Mac、更新时间、RSSI、UUID、信号源距离、影响范围等信息 项目地址：https://github.com/alt236/Bluetooth-LE-Library---Android Demo 地址：https://play.google.com/store/apps/details?id=uk.co.alt236.btlescan farebot 通过 NFC 从公交卡中读取数据的一个应用 项目地址：https://github.com/codebutler/farebot 十、安全 SQLCipher Sqlite 加密工具 项目地址：https://github.com/sqlcipher/sqlcipher 文档介绍：http://sqlcipher.net/sqlcipher-for-android/ Conceal 快速高效的进行文件加密解密 项目地址：https://github.com/facebook/conceal 文档介绍：https://github.com/facebook/conceal#usage Android-PasscodeLock 应用锁，每次启动或从任何 Activity 启动应用都需要输入四位数字的密码方可进入 项目地址：https://github.com/wordpress-mobile/Android-PasscodeLock Demo 地址：https://play.google.com/store/apps/details?id=org.wordpress.android APP 示例：Wordpress Android，支付宝，挖财 GlowPadBackport 将 Android4.2 的锁屏界面解锁扩展到 Android1.6 及 1.6+ 项目地址：https://github.com/rock3r/GlowPadBackport Demo 地址：https://play.google.com/store/apps/details?id=net.sebastianopoggi.samples.ui.GlowPadSample GlowPadView Android 4 锁屏界面解锁 项目地址：https://github.com/nadavfima/GlowPadView Android-InsecureBank 关于 Android 不安全性的示例 项目地址：https://github.com/dineshshetty/Android-InsecureBankv2 十一、插件化 更多见：Android 插件化作用、概念以及不错的资料(包括开源项目)和解决方案 dynamic-load-apk Android 动态加载 Apk，热部署，利用 ClassLoader 以及 Activity 代理的方式解决 项目地址：https://github.com/singwhatiwanna/dynamic-load-apk 原理剖析文档：[dynamic-load-apk](http://a.codekk.com/detail/Android/FFish/DynamicLoadApk 源码解析) 文档介绍：http://blog.csdn.net/singwhatiwanna/article/details/22597587 Android Dynamic Loader 点评的实现方式，和上面不同的是：他不是用代理 Activity 的方式实现而是用 Fragment 以及 Schema 的方式实现 项目地址：https://github.com/mmin18/AndroidDynamicLoader Demo 地址：https://github.com/mmin18/AndroidDynamicLoader/raw/master/host.apk xCombine Android App 插件式插件开发，插件必须先安装，更推荐看上面两个开源项目 项目地址：https://github.com/wyouflf/xCombine 文档介绍：http://my.oschina.net/u/1171837/blog/155377 Android Plugin Framework Android 插件式开发，开放的源码目前不完整 项目地址：https://github.com/umeng/apf Android OpenAtlas Android插件框架，基于OSGI，非代理方式，组件需要在宿主中声明 项目地址：https://github.com/bunnyblue/OpenAtlas Demo 地址：https://github.com/bunnyblue/OpenAtlasExtension/blob/master/Dist/OpenAtlasLauncher.apk multidex 安装多 dex 的 classloader 项目地址：https://github.com/casidiablo/multidex ANR-WatchDog Android ANR 监听，通过监听自己的 UI Thread 是否被执行确定是否发生了 ANR，并可以设置相关事件 项目地址：https://github.com/SalomonBrys/ANR-WatchDog 十二、文件 对不同文档类型的处理，包括 PDF、Word、EPub、Html、Zip 等 purePDF 允许从任何运行的 SWF 文件读取和创建 PDF 文档 项目地址：https://github.com/sephiroth74/purePDF android-pdfview 快速解析 pdf 的 view，默认支持手势缩放和相关动画 项目地址：https://github.com/JoanZapata/android-pdfview Office 365 SDK for Android Preview 可支持 Microsoft SharePoint Lists, Microsoft SharePoint Files, Microsoft Exchange Calendar, Microsoft Exchange Contacts, Microsoft Exchange Mail 项目地址：https://github.com/OfficeDev/Office-365-SDK-for-Android OpenSpritz-Android EPub 阅读器 项目地址：https://github.com/OnlyInAmerica/OpenSpritz-Android jsoup 一个解析 html 的 java 库，可方便的提取和操作数据 项目地址：https://github.com/jhy/jsoup 官网网址：http://jsoup.org/ 作用：(1) 从一个 url、文件或 string 获得 html 并解析 (2) 利用 dom 遍历或 css 选择器查找、提取数据 (3) 操作 html 元素 (4) 根据白名单去除用于提交的非法数据防止 xss 攻击 (5) 输出整齐的 html ZIP java 压缩和解压库 项目地址：https://github.com/zeroturnaround/zt-zip 文档介绍：https://github.com/zeroturnaround/zt-zip#examples 作用：(1) 解压和压缩，并支持文件夹内递归操作 (2) 支持包含和排除某些元素 (3) 支持重命名元素 (4) 支持遍历 zip 包内容 (5) 比较两个 zip 包等功能 Image File Selector 轻量级的图片文件选择器，用系统api选取，压缩和裁切图片，可以方便的得要指定尺寸的图片 项目地址：https://github.com/sw926/ImageFileSelector 十三、其他 FragmentStack 一个封装了启动模式的Fragment便捷使用库,方便构建单Activity+多Fragment轻量级框架 项目地址：https://github.com/Mr-wangyong/FragmentStack App示例：南瓜电影 CustomTabsHelper 快速集成 CustomTabs 的工具类 项目地址：https://github.com/DreaminginCodeZH/CustomTabsHelper Salvage view 带 View 缓存的 Viewpager PagerAdapter，很方便使用 项目地址：https://github.com/JakeWharton/salvage Android Priority Job Queue Android 后台任务队列 项目地址：https://github.com/path/android-priority-jobqueue 文档介绍：https://github.com/path/android-priority-jobqueue#getting-started Cobub Razor 开源的 mobile 行为分析系统，包括 web 端、android 端，支持 ios 和 window phone 项目地址：https://github.com/cobub/razor Demo 地址：http://demo.cobub.com/razor 官网网址：http://dev.cobub.com/ Countly Android 移动端数据采集分析系统 项目地址：https://github.com/Countly/countly-sdk-android 官网网址：https://count.ly/ aFileChooser 文件选择器，可内嵌到程序中，而无需使用系统或三方文件选择器。 项目地址：https://github.com/iPaulPro/aFileChooser androidpn 基于 xmpp 协议的消息推送解决方案，包括服务器端和 android 端。 项目地址：https://github.com/dannytiehui/androidpn Bolts Android 的异步编程模式 项目地址：https://github.com/BoltsFramework/Bolts-Android/ 与 AsyncTask 比较：(1) 使用的是无大小限制的线程池 (2) 任务可组合可级联，防止了代码耦合 CastCompanionLibrary-android 使 Android 程序中更快的接入 Google Cast 项目地址：https://github.com/googlecast/CastCompanionLibrary-android 文档介绍：https://developers.google.com/cast/ CastVideos-android 从 Android 设备分享 Video 通过 Google Cast 项目地址：https://github.com/googlecast/CastVideos-android 文档介绍：https://developers.google.com/cast/ Uninstall_Statics Android 应用自身被卸载监听及打开浏览器等反馈功能实现 项目地址：https://github.com/sevenler/Uninstall_Statics 文档介绍：http://www.cnblogs.com/zealotrouge/p/3157126.html http://www.cnblogs.com/zealotrouge/p/3159772.html Memento 保证在系统配置改变时，Activity 中的某些数据可以简单安全的保持不变 项目地址：https://github.com/mttkay/memento 文档介绍：https://github.com/mttkay/memento#usage FreeFlow 布局引擎，更简单的创建自定义布局，并且当数据和布局改变时更美观的过渡动画 项目地址：https://github.com/Comcast/FreeFlow Demo 地址：https://github.com/Comcast/FreeFlow/releases Android Gesture Detectors Framework Android 手势框架，支持双指旋转、移动、平移、缩放等 项目地址：https://github.com/Almeros/android-gesture-detectors Mapbox Android SDK Android Map 的替代版 项目地址：https://github.com/mapbox/mapbox-android-sdk Activity animation Activity 跳转动画，支持各个方向波浪的效果 项目地址：https://github.com/flavienlaurent/activityanimation 在线演示：https://www.youtube.com/watch?v=-E0sc6w_Jck KryoNet 通过 NIO 提供客户端和服务器端 TCP/UDP 网络传输的 Java 库 项目地址：https://github.com/EsotericSoftware/kryonet Rebound 一个模仿弹簧反弹的 Java 库，可用于创建动画 项目地址：https://github.com/facebook/rebound Android Social Networks 社交网络接入统一管理器，可方便的从 Twitter, LinkedIn, Facebook, Google Plus 登陆、获得个人信息、发送消息、发送专篇、添加或删除好友 项目地址：https://github.com/antonkrasov/AndroidSocialNetworks Demo 地址：https://play.google.com/store/apps/details?id=com.github.androidsocialnetworks.apidemos SmartAppUpdates Android App 增量升级，包含前后端方案、Demo、以及 so 库，可用于商店或大体积 App 差分升级 项目地址：https://github.com/cundong/SmartAppUpdates Magnet 创建类似 Facebook 聊天桌面悬浮窗的效果 项目地址：https://github.com/premnirmal/Magnet AcDisplay 将 Android 的通知都集中到锁屏显示 项目地址：https://github.com/AChep/AcDisplay Demo 地址：https://play.google.com/store/apps/details?id=com.achep.acdisplay QrCodeScan ZXing 和 ZBar 结合的二维码扫描项目，提高了扫描效率 项目地址：https://github.com/SkillCollege/QrCodeScan Android-ScreenShot 实现 android 系统截屏功能 项目地址：https://github.com/Android-ScreenShot/AndroidScreenShotService 文档介绍：http://blog.csdn.net/buptgshengod/article/details/39155979 card.io SDK for Android 信用卡扫描 Android SDK 项目地址：https://github.com/card-io/card.io-Android-SDK Demo 项目：https://github.com/card-io/card.io-Android-SDK/tree/master/SampleApp ASNE Twitter, Facebook, Google Plus, LinkedIn, Instagram, Vkontakte, Odnoklassniki 的集成库，包括他们的大多数功能 项目地址：https://github.com/gorbin/ASNE Demo 地址：https://play.google.com/store/apps/details?id=com.gorbin.androidsocialnetworksextended.asne Android Signature Pad Android 自定义的签名 View，可自定义笔颜色和大小 项目地址：https://github.com/gcacace/android-signaturepad Demo 项目：https://github.com/gcacace/android-signaturepad/tree/master/SignaturePad-Example Teleport Android Wear 数据同步和消息传送库 项目地址：https://github.com/Mariuxtheone/Teleport DebugLog 可以帮你创建更简单和更容易理解的调试日志，能够友好的显示调试信息所在类和函数。 项目地址：https://github.com/MustafaFerhan/DebugLog Logger 简单、美观而且十分强大的 Android 日志工具 项目地址：https://github.com/orhanobut/logger Demo 地址：https://github.com/orhanobut/logger/tree/master/app jlog 可以灵活配置的日志工具，支持JSON打印，日志保存到指定文件，日志显示调用位置（混淆模式下依然有效） 项目地址：https://github.com/JiongBull/jlog Demo 地址：apk地址 Phrase square 组开源大牛写的字符串替换类 项目地址：https://github.com/square/phrase ColorPhrase 模仿 phrase 写的对字符串个别字符颜色改变的类，高效强大！ 项目地址：https://github.com/THEONE10211024/ColorPhrase PinyinSearch 一个为 T9 搜索和 Qwerty 搜索,提供数据解析与匹配等方法的拼音搜索 java 库。 项目地址： https://github.com/handsomezhou/PinyinSearchLibrary Demo 地址： ContactsSearch AppSearch APP 示例： 通讯录应用，微信电话本 PrainView PaintView 是一个画图工具: 可直接使用设定按钮来实现已拥有的方法，且拓展性强 基础功能：更换颜色、更换橡皮、以及更换橡皮和笔的粗细、清屏、倒入图片 特殊功能：保存画笔轨迹帧动画、帧动画导入导出、ReDo和UnDo 项目地址：Paintview demo地址：apk地址 原理解析：PaintView 绘图控件解析 CodeView CodeView代码查看／修改工具: 基于WebView制作的代码编辑器,实现代码高亮，暗色主题 项目地址：CodeView demo地址：apk地址 ExplorerView 文件浏览器：继承自ListView，可拓展性强，可进行文件类型分析 项目地址：CodeView demo地址：apk地址 ReadView 小说阅读器，支持文字字体、颜色、背景、进度等多种调整，支持一键设置。 项目地址：ReadView demo地址：apk地址 MarkDownView 支持MarkDown语法的渲染器,基于WebView的MarkDown渲染器,支持标准化的MarkDown语法, 调用接口和CodeView保持一致使用简便 项目地址：ReadView demo地址：apk地址 VerTextView竖行排版的TextView: 支持竖行排版，添加了下划线功能，开启简便，下划线粗细、颜色、间距均可自定义， 接口调用方式与TextView相似，使用简便。 项目地址：ReadView demo地址：apk地址 GHDownload下载框架 支持单线程和多线程断点下载，简单易用。 项目地址：GHDownload 第三部分 优秀项目 主要介绍那些 Android 还不错的完整项目，目前包含的项目主要依据是项目有意思或项目分层规范比较好。 一、系统及平台 Linux 项目地址：https://github.com/torvalds/linux Android 项目地址：https://android.googlesource.com/ 二、项目 ZXing 二维码扫描工具 项目地址：https://github.com/zxing/zxing 或 https://code.google.com/p/zxing/ APK 地址：https://play.google.com/store/apps/details?id=com.google.zxing.client.android 其他：现在市面上很多应用的二维码扫描功能都是从这个修改而来 photup 编辑机批量上传照片到 facebook 上 项目地址：https://github.com/chrisbanes/photup APK 地址：https://play.google.com/store/apps/details?id=uk.co.senab.photup 其他：代码分包合理，很棒。不过这个项目依赖的开源项目比较多，比较难编译 github-android Github 的 Android 客户端项目 项目地址：https://github.com/github/android APK 地址：https://play.google.com/store/apps/details?id=com.github.mobile Notes MIUI 便签 项目地址：https://github.com/MiCode/Notes APK 地址：https://github.com/Trinea/TrineaDownload/blob/master/miui-note-demo.apk?raw=true 其他：项目分包比较合理，相比较 miui 的文件管理器 https://github.com/MiCode/FileExplorer 代码规范较好得多 weicuiyuan 四次元-新浪微博客户端 项目地址：https://github.com/qii/weiciyuan APK 地址：https://play.google.com/store/apps/details?id=org.qii.weiciyuan Douya 豆芽——Material Design 的豆瓣客户端 项目地址：https://github.com/DreaminginCodeZH/Douya gnucash-android 一个记账理财软件 项目地址：https://github.com/codinguser/gnucash-android APK 地址：http://play.google.com/store/apps/details?id=org.gnucash.android AntennaPod 支持 rss 订阅、音乐订阅 项目地址：https://github.com/danieloeh/AntennaPod APK 地址：https://play.google.com/store/apps/details?id=de.danoeh.antennapod ChaseWhisplyProject 打鬼游戏 项目地址：https://github.com/tvbarthel/ChaseWhisplyProject APK 地址：https://play.google.com/store/apps/details?id=fr.tvbarthel.games.chasewhisply Tweet Lanes 功能完整的 Twitter 客户端 项目地址：https://github.com/chrislacy/TweetLanes APK 地址：https://play.google.com/store/apps/details?id=com.tweetlanes.android Financius 简单易用的记账程序 项目地址：https://github.com/mvarnagiris/Financius APK 地址：https://play.google.com/store/apps/details?id=com.code44.finance todo.txt-android todo.txt 的官方 Android 应用 项目地址：https://github.com/ginatrapani/todo.txt-android APK 地址：https://play.google.com/store/apps/details?id=com.todotxt.todotxttouch simpletask 基于 todo.txt 官方应用的另一个客户端 项目地址：https://github.com/mpcjanssen/simpletask-android APK 地址：https://play.google.com/store/apps/details?id=nl.mpcjanssen.todotxtholo Muzei Live Wallpaper 定时更换桌面精美壁纸 项目地址：https://github.com/romannurik/muzei APK 地址：https://play.google.com/store/apps/details?id=net.nurik.roman.muzei Scanbook 扫描搜索查询图书信息 项目地址：https://github.com/JayFang1993/ScanBook APK 地址：http://www.wandoujia.com/apps/com.scanbook iosched The Google I/O 2014 Android App 项目地址：https://github.com/google/iosched APK 地址：https://play.google.com/store/apps/details?id=com.google.samples.apps.iosched 第四部分 开发工具及测试工具 主要介绍和 Android 开发工具和测试工具相关的开源项目。 一、开发效率工具 Parceler 通过注解及工具类自动完成实体类 Parcelable 及值传递 项目地址：https://github.com/johncarl81/parceler Json2Java 根据 JSon 数据自动生成对应的 Java 实体类，还支持 Parcel、Gson Annotations 对应代码自动生成。期待后续的提取父类以及多 url 构建整个工程的功能 项目地址：https://github.com/jonfhancock/JsonToJava 在线演示：http://jsontojava.appspot.com/ IntelliJ Plugin for Android Parcelable boilerplate code generation Android studio 插件，生成 Parcelable 代码 项目地址：https://github.com/mcharmas/android-parcelable-intellij-plugin Android Holo Colors IntelliJ Plugin Android studio 插件，生成 holo 样式 9 patch 图片 项目地址：https://github.com/jeromevdl/android-holo-colors-idea-plugin Android Drawable Factory 用于生成各个分辨率的图片 项目地址：https://github.com/tizionario/AndroidDrawableFactory SelectorChapek for Android Android Studio 插件，可根据固定文件名格式资源自动生成 drawable selectors xml 文件。 项目地址：https://github.com/inmite/android-selector-chapek Android Action Bar Style Generator Android ActionBar 样式生成器，可在线选择 ActionBar 样式自动生成所需要的图片资源及 xml 文件 项目地址：https://github.com/jgilfelt/android-actionbarstylegenerator 在线演示：http://jgilfelt.github.io/android-actionbarstylegenerator/ ButterKnifeZelezny 用于快速生成ButterKnifeView 注入代码的 Android Studio/IDEA 插件 项目地址：https://github.com/inmite/android-butterknife-zelezny RoboCoP 利用 Gradle task 根据固定格式的 json 文件生成 ContentProvider 项目地址：https://github.com/mediarain/RoboCoP appiconsizes 用于生成各个分辨率的图片 项目地址：http://www.appiconsizes.com/ AndroidUtiles 集合了所有常用的安卓工具类 项目地址：https://github.com/l123456789jy/Lazy Gradle Retrolambda Plugin Retrolambda是将 Java8 的 Lambdas 应用于 Java7 的工具，本项目是 Gradle 插件，通过 Retrolambda 从而使 Java 或 Android 项目用 Java8 的 Lambdas 编写，将编译后的字节码转换为 Java6 和 7 的字节码从而正常运行 项目地址：https://github.com/evant/gradle-retrolambda Dagger IntelliJ Plugin dagger 的 intellij 插件 项目地址：https://github.com/square/dagger-intellij-plugin Android Gen Drawable Maven plugin 在编译时根据 SVG 描述文件生成不同分辨率的 jpg、png 或点 9 图片 项目地址：https://github.com/avianey/androidgendrawable-maven-plugin Android Asset Studio 各种 Android 资源自动生成器，包括启动图标、ActionBar 图标、通知栏图标、点 9 等 项目地址：https://github.com/romannurik/AndroidAssetStudio 在线演示：http://romannurik.github.io/AndroidAssetStudio/ jsonschema2pojo 根据 Json 内容生成 java 对象，支持 jackjson 和 gson 项目地址：https://github.com/joelittlejohn/jsonschema2pojo 在线演示：http://www.jsonschema2pojo.org/ GsonFormat 根据 JSONObject 格式的字符串,自动生成实体类参数的 Android Studio/IntelliJ IDEA 插件 项目地址：https://github.com/zzz40500/GsonFormat 9-Patch-Resizer 自动生成 png 及点 9 图片的不同分辨率版本 项目地址：https://github.com/redwarp/9-Patch-Resizer AndroidLocalizationer 可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件 项目地址：https://github.com/westlinkin/AndroidLocalizationer Material Palette 一个将现有的色彩方案组合成材料设计的调色板方案，提供下载。选取两个主要色彩后便可以提供下载，提供下载的格式可以是 android 的资源 xml 文件，以色彩的方式提供，也可以是 CSS、SVG、PNG 等常见格式文件。 项目地址：http://www.materialpalette.com/ 二、开发自测相关 Quality Tools for Android Android 测试及自测工具集合和示例 项目地址：https://github.com/stephanenicolas/Quality-Tools-for-Android android-test-kit Google 的 Android 测试工具 包括 GoogleInstrumentationTestRunner(增强版的 InstrumentationTestRunner)和 Espresso(用于快速写出可靠测试用例的 API) 项目地址：https://code.google.com/p/android-test-kit/ 文档介绍：https://code.google.com/p/android-test-kit/w/list robolectric 测试用例编写框架 项目地址：https://github.com/robolectric/robolectric Demo 地址：https://github.com/robolectric/robolectricsample 文档介绍：http://robolectric.org/ 特点：(1). 不需要模拟器在一般 JVM 就可以运行测试用例 (2). 能完成在真机上的大部分测试包括感应器 其他的测试用例及相关模块 Mock 可见：android-mock, mockito, easy-mock Android FEST 提供一些列方便的断言，可用于提高编写 Android 自测代码效率 项目地址：https://github.com/square/fest-android BoundBox 可用于测试类各种访问权限的属性、方法。实际是通过 BoundBox 这个 annotation 生成一个属性和方法都是 public 权限的中间类并对此类进行测试完成的 项目地址：https://github.com/stephanenicolas/boundbox Hugo 用于打印函数信息及执行时间的工具，仅在 debug 模式生效 项目地址：https://github.com/JakeWharton/hugo scalpel 在应用下面添加一层用于界面调试 项目地址：https://github.com/JakeWharton/scalpel Android Screenshot library Android 截图工具类，用于在持续集成时截图 项目地址：https://github.com/rtyley/android-screenshot-lib sonar-android-lint-plugin 将 android lint 的错误在 sonar 中展现 项目地址：https://github.com/SonarCommunity/sonar-android 三、测试工具 Spoon 可用于 android 不同机型设备自动化测试，能将应用 apk 和测试 apk 运行在不同机器上并生成相应测试报告。 项目地址：https://github.com/square/spoon Tencent APT APT 是腾讯开源的一个 Android 平台高效性能测试组件，提供丰富实用的功能，适用于开发自测、定位性能瓶颈；测试人员完成性能基准测试、竞品对比测试 项目地址：https://github.com/stormzhang/APT Emmagee 网易开源的性能测试工具，包括 CPU、内存、网络流量、启动时间、电池状态等 项目地址：https://github.com/NetEase/Emmagee Android py-uiautomator py-uiautomator 是一个对 Android uiautomator 用 python 进行封装的测试框架. 项目地址：https://github.com/xiaocong/uiautomator Augmented Traffic Control 模拟网络状况，包括带宽、时延抖动、丢包率、错包率、包重排率 项目地址：https://github.com/facebook/augmented-traffic-control stetho 强大的 Android Debug 工具。支持网络请求监控以及数据库查看，可以和 Chrome DevTools 结合或者命令行模式。 项目地址：https://github.com/facebook/stetho 四、开发及编译环境 Buck facebook 开源的 Android 编译工具，效率是 ant 的两倍。主要优点在于： (1) 加快编译速度，通过并行利用多核 cpu 和跟踪不变资源减少增量编译时间实现 (2) 可以在编译系统中生成编译规则而无须另外的系统生成编译规则文件 (3) 编译同时可生成单元测试结果 (4) 既可用于 IDE 编译也可用于持续集成编译 (5) facebook 持续优化中 项目地址：https://github.com/facebook/buck Android Maven Plugin Android Maven 插件，可用于对 android 三方依赖进行管理。在 J2EE 开发中，maven 是非常成熟的依赖库管理工具，可统一管理依赖库。 项目地址：https://github.com/jayway/maven-android-plugin umeng-muti-channel-build-tool 渠道打包工具 项目地址：https://github.com/umeng/umeng-muti-channel-build-tool 另可参见 Google 的构建系统 Gradle：http://tools.android.com/tech-docs/new-build-system/user-guide Genymotion 目前最好用最快的 android 模拟器 项目地址：http://www.genymotion.com/ Android studio 集成控件： http://plugins.jetbrains.com/plugin/7269?pr=idea Cyril Mottier 推荐：http://cyrilmottier.com/2013/06/27/a-productive-android-development-environment/ gradle-mvn-push 方便的将 Gradle 的 Artifacts 上传到 Maven 仓库 项目地址：https://github.com/chrisbanes/gradle-mvn-push 文档介绍：https://github.com/chrisbanes/gradle-mvn-push#usage Android Emulator Plugin for Jenkins Android 模拟器 jenkins 插件，用于 Jenkins 做持续集成时跑模拟器测试 项目地址：https://github.com/jenkinsci/android-emulator-plugin Android Maven Plugin 管理应用所需要的依赖库。包括的构建工具有 Maven、Gradle、ant、sbt 项目地址：https://github.com/mosabua/maven-android-sdk-deployer SDK Manager Plugin 下载和管理 Android SDK 的 Gradle 插件 项目地址：https://github.com/JakeWharton/sdk-manager-plugin Gradle Protobuf Plugin 将.proto 文件转换成 Java 文件的 gradle 插件 项目地址：https://github.com/andrewkroh/gradle-protobuf-plugin ChromeADB Chrome 的 Adb 插件，当登录后，能看到所有连接的设备并操作，可以看应用、进程、内存及磁盘使用情况等 项目地址：https://github.com/importre/chromeadb 五、其他 GT APP的随身调试平台，它是直接运行在手机上的“集成调试环境”(IDTE, Integrated Debug Environment)。 项目地址：https://github.com/TencentOpen/GT 文档介绍：http://gt.qq.com/docs.html ViewServer 允许 app 运行在任何手机上都可以用 HierarchyViewer 查看 项目地址：https://github.com/romainguy/ViewServer GridWichterle for Android 在整个系统上显示一个 grid，用来帮助查看应用布局及使得布局更美观，可设置 grid 网格大小和颜色，android 推荐 48dp 和 8dp，可见 Android Design Guidelines – Metrics and Grids，比起 hierarchyviewer 相差甚远，不过偶尔可用来作为布局查看工具。 项目地址：https://github.com/inmite/android-grid-wichterle Demo 地址：https://play.google.com/store/apps/details?id=eu.inmite.android.gridwichterle Catlog 手机端 log 查看工具，支持不同颜色显示、关键字过滤、级别过滤、进程 id 过滤、录制功能等 项目地址：https://github.com/nolanlawson/Catlog 在线演示：https://play.google.com/store/apps/details?id=com.nolanlawson.logcat PID Cat 根据 package 查看 logcat 日志 项目地址：https://github.com/JakeWharton/pidcat ACRA 应用崩溃信息日志上报到 GoogleDoc 工具，网页版展现结果三方开源地址 https://github.com/BenoitDuffez/crashreportsviewer 项目地址：https://github.com/ACRA/acra 文档介绍：https://github.com/ACRA/acra/wiki/BasicSetup Crashlytics 提供丰富的应用崩溃信息日志收集 轻量级，丰富，可自定义应用崩溃信息收集器，附有邮件通知 项目地址：http://www.crashlytics.com/ 集成插件：Android Studio, Eclipse and IntelliJ Android Resource Navigator chrome 插件，可以方便的查看 github 上 android 源码工程的 styles.xml 和 themes.xml。主要功能： (1) 快速打开 android styles.xml themes.xml (2) 方便在资源间跳转。styles.xml themes.xml 文件中资源链接跳转，可以方便跳转到某个资源 (3) 方便查找某个 style 和 theme。chrome 地址栏输入 arn+tab+搜索内容回车即可 (4) 自动下载不同分辨率下的 drawable (5) 通过映射查找那些不是按照固定命名规则命名的 style 和 theme 项目地址：https://github.com/jgilfelt/android-resource-navigator 在线演示：https://chrome.google.com/webstore/detail/android-resource-navigato/agoomkionjjbejegcejiefodgbckeebo?hl=en&amp;gl=GB android-resource-remover 根据 lint 的提示删除项目中无用的资源，减少包的大小 项目地址：https://github.com/KeepSafe/android-resource-remover Telescope 通过手势截图以特定主题发送到特定邮箱地址报告 Bug 项目地址：https://github.com/mattprecious/telescope Complete Android Fragment &amp; Activity Lifecycle 完整的 Android Fragment/Activity 生命周期图 项目地址：https://github.com/xxv/android-lifecycle Bugsnag Notifier for Android 通过Thread.UncaughtExceptionHandler捕获应用未处理的异常崩溃 Bug 并用 Notification 展示同时上传到后台服务器 项目地址：https://github.com/bugsnag/bugsnag-android 文档介绍：https://github.com/bugsnag/bugsnag-android#installation--setup Material Design Icons Google Material Design 规范中的 Icon 项目地址：https://github.com/google/material-design-icons scrollscreenshot Android 滚动屏幕自动截图 jar 包，支持纵向、横向滚动截屏拼接 项目地址：https://github.com/PGSSoft/scrollscreenshot droidicon 1600+的海量 Icon，包括 750+的 Material Design icons 项目地址：https://github.com/theDazzler/droidicon leakcanary Android 内存泄露检测工具，集成方便，出现泄露后报告直观 项目地址：https://github.com/square/leakcanary CacheUtilsLibrary 将任何Java Object类型的数据序列化后写入缓存文件，将来使用时读取缓存文件并反序列化成对应Java Object的库 项目地址：https://github.com/westlinkin/CacheUtilsLibrary BlockCanary BlockCanary是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。 项目地址: https://github.com/moduth/blockcanary 第五部分 主要介绍那些乐于分享并且有一些很不错的开源项目的个人和组织。Follow 大神，深挖大神的项目和 following，你会发现很多。 一、个人 JakeWharton 就职于 Square，绝对牛逼的大神，项目主要集中在 Android 版本兼容，ViewPager 及开发工具上 Github 地址：https://github.com/JakeWharton 代表作：ActionBarSherlock，Android-ViewPagerIndicator，Nine Old Androids，SwipeToDismissNOA，hugo，butterknife，Android-DirectionalViewPager, scalpel pidcat 另外对 square 及其他开源项目有很多贡献 主页：http://jakewharton.com/ Chris Banes Github 地址：https://github.com/chrisbanes 代表作：ActionBar-PullToRefresh，PhotoView，Android-BitmapCache，Android-PullToRefresh 主页：http://chris.banes.me/ Koushik Dutta 就职于 ClockworkMod Github 地址：https://github.com/koush 代表作：Superuser，AndroidAsync，UrlImageViewHelper，ion, 另外对 https://github.com/CyanogenMod 的开源项目有很多贡献 主页：http://koush.com/ Simon Vig Github 地址：https://github.com/SimonVT 代表作：android-menudrawer，MessageBar 主页：http://simonvt.net/ Manuel Peinado Github 地址：https://github.com/ManuelPeinado 代表作：FadingActionBar，GlassActionBar，RefreshActionItem，QuickReturnHeader Emil Sj?lander Github 地址：https://github.com/emilsjolander 代表作：StickyListHeaders，sprinkles，android-FlipView 主页：http://emilsjolander.se/ greenrobot Github 地址：https://github.com/greenrobot 代表作：greenDAO，EventBus 主页：http://greenrobot.de/ Jeff Gilfelt Github 地址：https://github.com/jgilfelt 代表作：android-mapviewballoons，android-viewbadger，android-actionbarstylegenerator，android-sqlite-asset-helper 主页：http://jeffgilfelt.com Romain Guy Android team 成员(2013.10 已离开 Android team，仍在 Google) Github 地址：https://github.com/romainguy 代表作：ViewServer 主页：http://www.curious-creature.org/category/android/ 個人攝影作品：http://www.flickr.com/photos/romainguy sephiroth74 就职于 Aviary.com Github 地址：https://github.com/sephiroth74 代表作：ImageViewZoom，HorizontalVariableListView，AndroidWheel，purePDF 主页：http://www.sephiroth.it/ Cyril Mottier Google 开发者专家认证，发布一些 Android 技巧及文章 Github 地址：https://github.com/cyrilmottier 代表作：GreenDroid，Polaris 主页：http://cyrilmottier.com/ 二、组织 Square 有态度有良心的企业，很多不错的分享 Github 地址：https://github.com/square 代表作：okhttp、fest-android，android-times-square、picasso、dagger、spoon 等等 主页：http://square.github.io/ Inmite s.r.o. Github 地址：https://github.com/inmite 代表作：android-styled-dialogs，android-grid-wichterle，android-selector-chapek 主页：http://www.inmite.eu/ 三、博客 部分国外著名 Android 开发者信息 注意 本文转自——Trinea 汇总的开源项目 欢迎大家关注他的微信公众号：codekk。二维码如下： 专注于 Android 开源分享、源码解析、框架设计、Android 内推。 他的网站：www.codekk.com 关于trinea，欢迎关注 微博：Trinea 主页：trinea.cn 推荐 Android 开源项目源码解析(Volley、UIL、Dagger、EventBus、插件化库等分析) Android 职位内部推荐(阿里、腾讯、百度、京东、滴滴、美团、58、华为、网易、魅族等)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu-15.04安装jdk]]></title>
    <url>%2F2016%2F03%2F23%2Fubuntu-15.04-install-jdk.html</url>
    <content type="text"><![CDATA[前言最近在Linux上学习Python，而PyCharm需要java环境的支持，本文记录了在Ubuntu-15.04上安装jdk1.8版本的步骤与遇到的问题。 ## 1. 方式一 Ubuntu安装JDK **系统版本：**Ubuntu 15.04 x64 **JDK版本：**jdk-8u60-linux-x64 步骤详解 查看系统位数，输入以下命令即可 getconf LONG_BIT 下载对应的JDK文件，我这里下载的是jdk-8u60-linux-64.tar.gz 创建目录作为JDK的安装目录，这里选择安装位置为:/usr/java/ sudo mkdir /usr/java 解压文件带/usr/java/目录下，文件下载的位置是在download目录下的 cd download sudo tar zxvf jdk-8u60-linux-x64.tar.gz -C /usr/java/ 进入到**/usr/java/**目录，给文件夹改名（这一步并非必须，但是为了配置环境变量方便，建议这样做） cd /usr/java/ sudo mv jdk1.8.0_60 jdk_8u60 配置系统环境变量 sudo gedit /etc/environment 加入以下的内容 PATH=&quot;:$JAVA_HOME/bin&quot; export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib export JAVA_HOME=/usr/java/jdk_8u60 修改完成后保存并关闭，输入以下命令使环境变量生效 source /etc/environment 使用echo命令检查环境变量的配置情况 echo $JAVA_HOME 输出 /usr/java/jdk_8u60 echo $CLASSPATH 输出 .:/usr/java/jdk_8u60/lib:/usr/java/jdk_8u60/jre/lib echo $PATH 输出 /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/java/jdk_8u60/bin 查看安装版本: java -version Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar java version “1.8.0_60” Java™ SE Runtime Environment (build 1.8.0_60-b27) Java HotSpot™ 64-Bit Server VM (build 25.60-b23, mixed mode) 设置所有用户的环境变量，不然重启之后依然找不到java命令 sudo gedit /etc/profile 添加以下内容即可(注意替换路径): #set Java environment JAVA_HOME=/usr/java/jdk_8u60 export JRE_HOME=/usr/java/jdk_8u60/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 重启电脑，使配置生效。 结束了？没有！！！ 如果使用Myeclipse等IDE的或者安装了多个jdk版本的请继续向下看↓↓↓ 修改默认的JDK(注意替换路径) sudo update-alternatives --install &quot;/usr/bin/java&quot; &quot;java&quot; &quot;/usr/java/jdk_8u60/bin/java&quot; 300 sudo update-alternatives --install &quot;/usr/bin/javac&quot; &quot;javac&quot; &quot;/usr/java/jdk_8u60/bin/javac&quot; 300 sudo update-alternatives --install &quot;/usr/bin/javaws&quot; &quot;javaws&quot; &quot;/usr/java/jdk_8u60/bin/javaws&quot; 300 以上是为不同的命令建立链接，如果存在多个JDK只需要替换路径重新执行一遍即可建立链接，执行以下命令选择链接，如果每个选项只建立了一个链接，系统不会提供选项，如果存在多个链接，请根据需要选择不同选项 sudo update-alternatives --config java sudo update-alternatives --config javac sudo update-alternatives --config javaws 2. 方式二 如果在 Ubuntu 软件中心安装过 OpenJDK，使用如下命令将其删除： sudo apt-get purge openjdk* 添加源和更新 sudo add-apt-repository ppa:webupd8team/java sudo apt-get update 安装java 8 sudo apt-get install Oracle-java8-installer 3. 安装时常见错误处理 安装时VirtualBox异常退出，重进时报如下错误： dpkg 被中断,您必须手工运行 sudo dpkg --configure -a 解决此问题。 解决方法： sudo rm /var/lib/dpkg/updates/* sudo apt-get update sudo apt-get upgrade 运行java -version出现如下错误: Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar。 解决方法： sudo rm /usr/share/upstart/sessions/jayatana.conf sudo add-apt-repository ppa:danjaredg/jayatana sudo apt-get update sudo apt-get install jayatana 再正常运行正常： xkcoding@Yangkai:~$ ~/workspace$ java -version java version &quot;1.8.0_60&quot; Java(TM) SE Runtime Environment (build 1.8.0_60-b27) Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[helloworld]]></title>
    <url>%2F2016%2F03%2F21%2Fhelloworld.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
</search>